import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS
} from "./chunk-OROXOI2D.js";

// node_modules/@babel/runtime/helpers/interopRequireDefault.js
var require_interopRequireDefault = __commonJS({
  "node_modules/@babel/runtime/helpers/interopRequireDefault.js"(exports, module) {
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }
    module.exports = _interopRequireDefault;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "node_modules/@babel/runtime/helpers/typeof.js"(exports, module) {
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        module.exports = _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
        module.exports["default"] = module.exports, module.exports.__esModule = true;
      } else {
        module.exports = _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
        module.exports["default"] = module.exports, module.exports.__esModule = true;
      }
      return _typeof(obj);
    }
    module.exports = _typeof;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js
var require_objectWithoutPropertiesLoose = __commonJS({
  "node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js"(exports, module) {
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    module.exports = _objectWithoutPropertiesLoose;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/objectWithoutProperties.js
var require_objectWithoutProperties = __commonJS({
  "node_modules/@babel/runtime/helpers/objectWithoutProperties.js"(exports, module) {
    var objectWithoutPropertiesLoose = require_objectWithoutPropertiesLoose();
    function _objectWithoutProperties(source, excluded) {
      if (source == null)
        return {};
      var target = objectWithoutPropertiesLoose(source, excluded);
      var key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    module.exports = _objectWithoutProperties;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/classCallCheck.js
var require_classCallCheck = __commonJS({
  "node_modules/@babel/runtime/helpers/classCallCheck.js"(exports, module) {
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    module.exports = _classCallCheck;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/createClass.js
var require_createClass = __commonJS({
  "node_modules/@babel/runtime/helpers/createClass.js"(exports, module) {
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    module.exports = _createClass;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/@babel/runtime/helpers/defineProperty.js"(exports, module) {
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    module.exports = _defineProperty;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/core-js/internals/global.js
var require_global = __commonJS({
  "node_modules/core-js/internals/global.js"(exports, module) {
    var check = function(it) {
      return it && it.Math == Math && it;
    };
    module.exports = check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof global == "object" && global) || function() {
      return this;
    }() || Function("return this")();
  }
});

// node_modules/core-js/internals/fails.js
var require_fails = __commonJS({
  "node_modules/core-js/internals/fails.js"(exports, module) {
    module.exports = function(exec) {
      try {
        return !!exec();
      } catch (error) {
        return true;
      }
    };
  }
});

// node_modules/core-js/internals/descriptors.js
var require_descriptors = __commonJS({
  "node_modules/core-js/internals/descriptors.js"(exports, module) {
    var fails = require_fails();
    module.exports = !fails(function() {
      return Object.defineProperty({}, 1, { get: function() {
        return 7;
      } })[1] != 7;
    });
  }
});

// node_modules/core-js/internals/object-property-is-enumerable.js
var require_object_property_is_enumerable = __commonJS({
  "node_modules/core-js/internals/object-property-is-enumerable.js"(exports) {
    "use strict";
    var $propertyIsEnumerable = {}.propertyIsEnumerable;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
    exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
      var descriptor = getOwnPropertyDescriptor(this, V);
      return !!descriptor && descriptor.enumerable;
    } : $propertyIsEnumerable;
  }
});

// node_modules/core-js/internals/create-property-descriptor.js
var require_create_property_descriptor = __commonJS({
  "node_modules/core-js/internals/create-property-descriptor.js"(exports, module) {
    module.exports = function(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value
      };
    };
  }
});

// node_modules/core-js/internals/classof-raw.js
var require_classof_raw = __commonJS({
  "node_modules/core-js/internals/classof-raw.js"(exports, module) {
    var toString = {}.toString;
    module.exports = function(it) {
      return toString.call(it).slice(8, -1);
    };
  }
});

// node_modules/core-js/internals/indexed-object.js
var require_indexed_object = __commonJS({
  "node_modules/core-js/internals/indexed-object.js"(exports, module) {
    var fails = require_fails();
    var classof = require_classof_raw();
    var split = "".split;
    module.exports = fails(function() {
      return !Object("z").propertyIsEnumerable(0);
    }) ? function(it) {
      return classof(it) == "String" ? split.call(it, "") : Object(it);
    } : Object;
  }
});

// node_modules/core-js/internals/require-object-coercible.js
var require_require_object_coercible = __commonJS({
  "node_modules/core-js/internals/require-object-coercible.js"(exports, module) {
    module.exports = function(it) {
      if (it == void 0)
        throw TypeError("Can't call method on " + it);
      return it;
    };
  }
});

// node_modules/core-js/internals/to-indexed-object.js
var require_to_indexed_object = __commonJS({
  "node_modules/core-js/internals/to-indexed-object.js"(exports, module) {
    var IndexedObject = require_indexed_object();
    var requireObjectCoercible = require_require_object_coercible();
    module.exports = function(it) {
      return IndexedObject(requireObjectCoercible(it));
    };
  }
});

// node_modules/core-js/internals/is-object.js
var require_is_object = __commonJS({
  "node_modules/core-js/internals/is-object.js"(exports, module) {
    module.exports = function(it) {
      return typeof it === "object" ? it !== null : typeof it === "function";
    };
  }
});

// node_modules/core-js/internals/to-primitive.js
var require_to_primitive = __commonJS({
  "node_modules/core-js/internals/to-primitive.js"(exports, module) {
    var isObject = require_is_object();
    module.exports = function(input, PREFERRED_STRING) {
      if (!isObject(input))
        return input;
      var fn, val;
      if (PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject(val = fn.call(input)))
        return val;
      if (typeof (fn = input.valueOf) == "function" && !isObject(val = fn.call(input)))
        return val;
      if (!PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject(val = fn.call(input)))
        return val;
      throw TypeError("Can't convert object to primitive value");
    };
  }
});

// node_modules/core-js/internals/to-object.js
var require_to_object = __commonJS({
  "node_modules/core-js/internals/to-object.js"(exports, module) {
    var requireObjectCoercible = require_require_object_coercible();
    module.exports = function(argument) {
      return Object(requireObjectCoercible(argument));
    };
  }
});

// node_modules/core-js/internals/has.js
var require_has = __commonJS({
  "node_modules/core-js/internals/has.js"(exports, module) {
    var toObject = require_to_object();
    var hasOwnProperty = {}.hasOwnProperty;
    module.exports = Object.hasOwn || function hasOwn(it, key) {
      return hasOwnProperty.call(toObject(it), key);
    };
  }
});

// node_modules/core-js/internals/document-create-element.js
var require_document_create_element = __commonJS({
  "node_modules/core-js/internals/document-create-element.js"(exports, module) {
    var global2 = require_global();
    var isObject = require_is_object();
    var document2 = global2.document;
    var EXISTS = isObject(document2) && isObject(document2.createElement);
    module.exports = function(it) {
      return EXISTS ? document2.createElement(it) : {};
    };
  }
});

// node_modules/core-js/internals/ie8-dom-define.js
var require_ie8_dom_define = __commonJS({
  "node_modules/core-js/internals/ie8-dom-define.js"(exports, module) {
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    var createElement = require_document_create_element();
    module.exports = !DESCRIPTORS && !fails(function() {
      return Object.defineProperty(createElement("div"), "a", {
        get: function() {
          return 7;
        }
      }).a != 7;
    });
  }
});

// node_modules/core-js/internals/object-get-own-property-descriptor.js
var require_object_get_own_property_descriptor = __commonJS({
  "node_modules/core-js/internals/object-get-own-property-descriptor.js"(exports) {
    var DESCRIPTORS = require_descriptors();
    var propertyIsEnumerableModule = require_object_property_is_enumerable();
    var createPropertyDescriptor = require_create_property_descriptor();
    var toIndexedObject = require_to_indexed_object();
    var toPrimitive = require_to_primitive();
    var has = require_has();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
      O = toIndexedObject(O);
      P = toPrimitive(P, true);
      if (IE8_DOM_DEFINE)
        try {
          return $getOwnPropertyDescriptor(O, P);
        } catch (error) {
        }
      if (has(O, P))
        return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
    };
  }
});

// node_modules/core-js/internals/an-object.js
var require_an_object = __commonJS({
  "node_modules/core-js/internals/an-object.js"(exports, module) {
    var isObject = require_is_object();
    module.exports = function(it) {
      if (!isObject(it)) {
        throw TypeError(String(it) + " is not an object");
      }
      return it;
    };
  }
});

// node_modules/core-js/internals/object-define-property.js
var require_object_define_property = __commonJS({
  "node_modules/core-js/internals/object-define-property.js"(exports) {
    var DESCRIPTORS = require_descriptors();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var anObject = require_an_object();
    var toPrimitive = require_to_primitive();
    var $defineProperty = Object.defineProperty;
    exports.f = DESCRIPTORS ? $defineProperty : function defineProperty(O, P, Attributes) {
      anObject(O);
      P = toPrimitive(P, true);
      anObject(Attributes);
      if (IE8_DOM_DEFINE)
        try {
          return $defineProperty(O, P, Attributes);
        } catch (error) {
        }
      if ("get" in Attributes || "set" in Attributes)
        throw TypeError("Accessors not supported");
      if ("value" in Attributes)
        O[P] = Attributes.value;
      return O;
    };
  }
});

// node_modules/core-js/internals/create-non-enumerable-property.js
var require_create_non_enumerable_property = __commonJS({
  "node_modules/core-js/internals/create-non-enumerable-property.js"(exports, module) {
    var DESCRIPTORS = require_descriptors();
    var definePropertyModule = require_object_define_property();
    var createPropertyDescriptor = require_create_property_descriptor();
    module.exports = DESCRIPTORS ? function(object, key, value) {
      return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
    } : function(object, key, value) {
      object[key] = value;
      return object;
    };
  }
});

// node_modules/core-js/internals/set-global.js
var require_set_global = __commonJS({
  "node_modules/core-js/internals/set-global.js"(exports, module) {
    var global2 = require_global();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    module.exports = function(key, value) {
      try {
        createNonEnumerableProperty(global2, key, value);
      } catch (error) {
        global2[key] = value;
      }
      return value;
    };
  }
});

// node_modules/core-js/internals/shared-store.js
var require_shared_store = __commonJS({
  "node_modules/core-js/internals/shared-store.js"(exports, module) {
    var global2 = require_global();
    var setGlobal = require_set_global();
    var SHARED = "__core-js_shared__";
    var store = global2[SHARED] || setGlobal(SHARED, {});
    module.exports = store;
  }
});

// node_modules/core-js/internals/inspect-source.js
var require_inspect_source = __commonJS({
  "node_modules/core-js/internals/inspect-source.js"(exports, module) {
    var store = require_shared_store();
    var functionToString = Function.toString;
    if (typeof store.inspectSource != "function") {
      store.inspectSource = function(it) {
        return functionToString.call(it);
      };
    }
    module.exports = store.inspectSource;
  }
});

// node_modules/core-js/internals/native-weak-map.js
var require_native_weak_map = __commonJS({
  "node_modules/core-js/internals/native-weak-map.js"(exports, module) {
    var global2 = require_global();
    var inspectSource = require_inspect_source();
    var WeakMap2 = global2.WeakMap;
    module.exports = typeof WeakMap2 === "function" && /native code/.test(inspectSource(WeakMap2));
  }
});

// node_modules/core-js/internals/is-pure.js
var require_is_pure = __commonJS({
  "node_modules/core-js/internals/is-pure.js"(exports, module) {
    module.exports = false;
  }
});

// node_modules/core-js/internals/shared.js
var require_shared = __commonJS({
  "node_modules/core-js/internals/shared.js"(exports, module) {
    var IS_PURE = require_is_pure();
    var store = require_shared_store();
    (module.exports = function(key, value) {
      return store[key] || (store[key] = value !== void 0 ? value : {});
    })("versions", []).push({
      version: "3.15.2",
      mode: IS_PURE ? "pure" : "global",
      copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)"
    });
  }
});

// node_modules/core-js/internals/uid.js
var require_uid = __commonJS({
  "node_modules/core-js/internals/uid.js"(exports, module) {
    var id = 0;
    var postfix = Math.random();
    module.exports = function(key) {
      return "Symbol(" + String(key === void 0 ? "" : key) + ")_" + (++id + postfix).toString(36);
    };
  }
});

// node_modules/core-js/internals/shared-key.js
var require_shared_key = __commonJS({
  "node_modules/core-js/internals/shared-key.js"(exports, module) {
    var shared = require_shared();
    var uid = require_uid();
    var keys = shared("keys");
    module.exports = function(key) {
      return keys[key] || (keys[key] = uid(key));
    };
  }
});

// node_modules/core-js/internals/hidden-keys.js
var require_hidden_keys = __commonJS({
  "node_modules/core-js/internals/hidden-keys.js"(exports, module) {
    module.exports = {};
  }
});

// node_modules/core-js/internals/internal-state.js
var require_internal_state = __commonJS({
  "node_modules/core-js/internals/internal-state.js"(exports, module) {
    var NATIVE_WEAK_MAP = require_native_weak_map();
    var global2 = require_global();
    var isObject = require_is_object();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var objectHas = require_has();
    var shared = require_shared_store();
    var sharedKey = require_shared_key();
    var hiddenKeys = require_hidden_keys();
    var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
    var WeakMap2 = global2.WeakMap;
    var set;
    var get;
    var has;
    var enforce = function(it) {
      return has(it) ? get(it) : set(it, {});
    };
    var getterFor = function(TYPE) {
      return function(it) {
        var state;
        if (!isObject(it) || (state = get(it)).type !== TYPE) {
          throw TypeError("Incompatible receiver, " + TYPE + " required");
        }
        return state;
      };
    };
    if (NATIVE_WEAK_MAP || shared.state) {
      store = shared.state || (shared.state = new WeakMap2());
      wmget = store.get;
      wmhas = store.has;
      wmset = store.set;
      set = function(it, metadata) {
        if (wmhas.call(store, it))
          throw new TypeError(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        wmset.call(store, it, metadata);
        return metadata;
      };
      get = function(it) {
        return wmget.call(store, it) || {};
      };
      has = function(it) {
        return wmhas.call(store, it);
      };
    } else {
      STATE = sharedKey("state");
      hiddenKeys[STATE] = true;
      set = function(it, metadata) {
        if (objectHas(it, STATE))
          throw new TypeError(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        createNonEnumerableProperty(it, STATE, metadata);
        return metadata;
      };
      get = function(it) {
        return objectHas(it, STATE) ? it[STATE] : {};
      };
      has = function(it) {
        return objectHas(it, STATE);
      };
    }
    var store;
    var wmget;
    var wmhas;
    var wmset;
    var STATE;
    module.exports = {
      set,
      get,
      has,
      enforce,
      getterFor
    };
  }
});

// node_modules/core-js/internals/redefine.js
var require_redefine = __commonJS({
  "node_modules/core-js/internals/redefine.js"(exports, module) {
    var global2 = require_global();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var has = require_has();
    var setGlobal = require_set_global();
    var inspectSource = require_inspect_source();
    var InternalStateModule = require_internal_state();
    var getInternalState = InternalStateModule.get;
    var enforceInternalState = InternalStateModule.enforce;
    var TEMPLATE = String(String).split("String");
    (module.exports = function(O, key, value, options) {
      var unsafe = options ? !!options.unsafe : false;
      var simple = options ? !!options.enumerable : false;
      var noTargetGet = options ? !!options.noTargetGet : false;
      var state;
      if (typeof value == "function") {
        if (typeof key == "string" && !has(value, "name")) {
          createNonEnumerableProperty(value, "name", key);
        }
        state = enforceInternalState(value);
        if (!state.source) {
          state.source = TEMPLATE.join(typeof key == "string" ? key : "");
        }
      }
      if (O === global2) {
        if (simple)
          O[key] = value;
        else
          setGlobal(key, value);
        return;
      } else if (!unsafe) {
        delete O[key];
      } else if (!noTargetGet && O[key]) {
        simple = true;
      }
      if (simple)
        O[key] = value;
      else
        createNonEnumerableProperty(O, key, value);
    })(Function.prototype, "toString", function toString() {
      return typeof this == "function" && getInternalState(this).source || inspectSource(this);
    });
  }
});

// node_modules/core-js/internals/path.js
var require_path = __commonJS({
  "node_modules/core-js/internals/path.js"(exports, module) {
    var global2 = require_global();
    module.exports = global2;
  }
});

// node_modules/core-js/internals/get-built-in.js
var require_get_built_in = __commonJS({
  "node_modules/core-js/internals/get-built-in.js"(exports, module) {
    var path = require_path();
    var global2 = require_global();
    var aFunction = function(variable) {
      return typeof variable == "function" ? variable : void 0;
    };
    module.exports = function(namespace, method) {
      return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global2[namespace]) : path[namespace] && path[namespace][method] || global2[namespace] && global2[namespace][method];
    };
  }
});

// node_modules/core-js/internals/to-integer.js
var require_to_integer = __commonJS({
  "node_modules/core-js/internals/to-integer.js"(exports, module) {
    var ceil = Math.ceil;
    var floor = Math.floor;
    module.exports = function(argument) {
      return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
    };
  }
});

// node_modules/core-js/internals/to-length.js
var require_to_length = __commonJS({
  "node_modules/core-js/internals/to-length.js"(exports, module) {
    var toInteger = require_to_integer();
    var min = Math.min;
    module.exports = function(argument) {
      return argument > 0 ? min(toInteger(argument), 9007199254740991) : 0;
    };
  }
});

// node_modules/core-js/internals/to-absolute-index.js
var require_to_absolute_index = __commonJS({
  "node_modules/core-js/internals/to-absolute-index.js"(exports, module) {
    var toInteger = require_to_integer();
    var max = Math.max;
    var min = Math.min;
    module.exports = function(index, length) {
      var integer = toInteger(index);
      return integer < 0 ? max(integer + length, 0) : min(integer, length);
    };
  }
});

// node_modules/core-js/internals/array-includes.js
var require_array_includes = __commonJS({
  "node_modules/core-js/internals/array-includes.js"(exports, module) {
    var toIndexedObject = require_to_indexed_object();
    var toLength = require_to_length();
    var toAbsoluteIndex = require_to_absolute_index();
    var createMethod = function(IS_INCLUDES) {
      return function($this, el, fromIndex) {
        var O = toIndexedObject($this);
        var length = toLength(O.length);
        var index = toAbsoluteIndex(fromIndex, length);
        var value;
        if (IS_INCLUDES && el != el)
          while (length > index) {
            value = O[index++];
            if (value != value)
              return true;
          }
        else
          for (; length > index; index++) {
            if ((IS_INCLUDES || index in O) && O[index] === el)
              return IS_INCLUDES || index || 0;
          }
        return !IS_INCLUDES && -1;
      };
    };
    module.exports = {
      includes: createMethod(true),
      indexOf: createMethod(false)
    };
  }
});

// node_modules/core-js/internals/object-keys-internal.js
var require_object_keys_internal = __commonJS({
  "node_modules/core-js/internals/object-keys-internal.js"(exports, module) {
    var has = require_has();
    var toIndexedObject = require_to_indexed_object();
    var indexOf = require_array_includes().indexOf;
    var hiddenKeys = require_hidden_keys();
    module.exports = function(object, names) {
      var O = toIndexedObject(object);
      var i = 0;
      var result = [];
      var key;
      for (key in O)
        !has(hiddenKeys, key) && has(O, key) && result.push(key);
      while (names.length > i)
        if (has(O, key = names[i++])) {
          ~indexOf(result, key) || result.push(key);
        }
      return result;
    };
  }
});

// node_modules/core-js/internals/enum-bug-keys.js
var require_enum_bug_keys = __commonJS({
  "node_modules/core-js/internals/enum-bug-keys.js"(exports, module) {
    module.exports = [
      "constructor",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "toLocaleString",
      "toString",
      "valueOf"
    ];
  }
});

// node_modules/core-js/internals/object-get-own-property-names.js
var require_object_get_own_property_names = __commonJS({
  "node_modules/core-js/internals/object-get-own-property-names.js"(exports) {
    var internalObjectKeys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    var hiddenKeys = enumBugKeys.concat("length", "prototype");
    exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
      return internalObjectKeys(O, hiddenKeys);
    };
  }
});

// node_modules/core-js/internals/object-get-own-property-symbols.js
var require_object_get_own_property_symbols = __commonJS({
  "node_modules/core-js/internals/object-get-own-property-symbols.js"(exports) {
    exports.f = Object.getOwnPropertySymbols;
  }
});

// node_modules/core-js/internals/own-keys.js
var require_own_keys = __commonJS({
  "node_modules/core-js/internals/own-keys.js"(exports, module) {
    var getBuiltIn = require_get_built_in();
    var getOwnPropertyNamesModule = require_object_get_own_property_names();
    var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
    var anObject = require_an_object();
    module.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it) {
      var keys = getOwnPropertyNamesModule.f(anObject(it));
      var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
      return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
    };
  }
});

// node_modules/core-js/internals/copy-constructor-properties.js
var require_copy_constructor_properties = __commonJS({
  "node_modules/core-js/internals/copy-constructor-properties.js"(exports, module) {
    var has = require_has();
    var ownKeys = require_own_keys();
    var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
    var definePropertyModule = require_object_define_property();
    module.exports = function(target, source) {
      var keys = ownKeys(source);
      var defineProperty = definePropertyModule.f;
      var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (!has(target, key))
          defineProperty(target, key, getOwnPropertyDescriptor(source, key));
      }
    };
  }
});

// node_modules/core-js/internals/is-forced.js
var require_is_forced = __commonJS({
  "node_modules/core-js/internals/is-forced.js"(exports, module) {
    var fails = require_fails();
    var replacement = /#|\.prototype\./;
    var isForced = function(feature, detection) {
      var value = data[normalize(feature)];
      return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == "function" ? fails(detection) : !!detection;
    };
    var normalize = isForced.normalize = function(string) {
      return String(string).replace(replacement, ".").toLowerCase();
    };
    var data = isForced.data = {};
    var NATIVE = isForced.NATIVE = "N";
    var POLYFILL = isForced.POLYFILL = "P";
    module.exports = isForced;
  }
});

// node_modules/core-js/internals/export.js
var require_export = __commonJS({
  "node_modules/core-js/internals/export.js"(exports, module) {
    var global2 = require_global();
    var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var redefine = require_redefine();
    var setGlobal = require_set_global();
    var copyConstructorProperties = require_copy_constructor_properties();
    var isForced = require_is_forced();
    module.exports = function(options, source) {
      var TARGET = options.target;
      var GLOBAL = options.global;
      var STATIC = options.stat;
      var FORCED, target, key, targetProperty, sourceProperty, descriptor;
      if (GLOBAL) {
        target = global2;
      } else if (STATIC) {
        target = global2[TARGET] || setGlobal(TARGET, {});
      } else {
        target = (global2[TARGET] || {}).prototype;
      }
      if (target)
        for (key in source) {
          sourceProperty = source[key];
          if (options.noTargetGet) {
            descriptor = getOwnPropertyDescriptor(target, key);
            targetProperty = descriptor && descriptor.value;
          } else
            targetProperty = target[key];
          FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
          if (!FORCED && targetProperty !== void 0) {
            if (typeof sourceProperty === typeof targetProperty)
              continue;
            copyConstructorProperties(sourceProperty, targetProperty);
          }
          if (options.sham || targetProperty && targetProperty.sham) {
            createNonEnumerableProperty(sourceProperty, "sham", true);
          }
          redefine(target, key, sourceProperty, options);
        }
    };
  }
});

// node_modules/core-js/internals/correct-prototype-getter.js
var require_correct_prototype_getter = __commonJS({
  "node_modules/core-js/internals/correct-prototype-getter.js"(exports, module) {
    var fails = require_fails();
    module.exports = !fails(function() {
      function F() {
      }
      F.prototype.constructor = null;
      return Object.getPrototypeOf(new F()) !== F.prototype;
    });
  }
});

// node_modules/core-js/internals/object-get-prototype-of.js
var require_object_get_prototype_of = __commonJS({
  "node_modules/core-js/internals/object-get-prototype-of.js"(exports, module) {
    var has = require_has();
    var toObject = require_to_object();
    var sharedKey = require_shared_key();
    var CORRECT_PROTOTYPE_GETTER = require_correct_prototype_getter();
    var IE_PROTO = sharedKey("IE_PROTO");
    var ObjectPrototype = Object.prototype;
    module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function(O) {
      O = toObject(O);
      if (has(O, IE_PROTO))
        return O[IE_PROTO];
      if (typeof O.constructor == "function" && O instanceof O.constructor) {
        return O.constructor.prototype;
      }
      return O instanceof Object ? ObjectPrototype : null;
    };
  }
});

// node_modules/core-js/internals/a-possible-prototype.js
var require_a_possible_prototype = __commonJS({
  "node_modules/core-js/internals/a-possible-prototype.js"(exports, module) {
    var isObject = require_is_object();
    module.exports = function(it) {
      if (!isObject(it) && it !== null) {
        throw TypeError("Can't set " + String(it) + " as a prototype");
      }
      return it;
    };
  }
});

// node_modules/core-js/internals/object-set-prototype-of.js
var require_object_set_prototype_of = __commonJS({
  "node_modules/core-js/internals/object-set-prototype-of.js"(exports, module) {
    var anObject = require_an_object();
    var aPossiblePrototype = require_a_possible_prototype();
    module.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
      var CORRECT_SETTER = false;
      var test = {};
      var setter;
      try {
        setter = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set;
        setter.call(test, []);
        CORRECT_SETTER = test instanceof Array;
      } catch (error) {
      }
      return function setPrototypeOf(O, proto) {
        anObject(O);
        aPossiblePrototype(proto);
        if (CORRECT_SETTER)
          setter.call(O, proto);
        else
          O.__proto__ = proto;
        return O;
      };
    }() : void 0);
  }
});

// node_modules/core-js/internals/object-keys.js
var require_object_keys = __commonJS({
  "node_modules/core-js/internals/object-keys.js"(exports, module) {
    var internalObjectKeys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    module.exports = Object.keys || function keys(O) {
      return internalObjectKeys(O, enumBugKeys);
    };
  }
});

// node_modules/core-js/internals/object-define-properties.js
var require_object_define_properties = __commonJS({
  "node_modules/core-js/internals/object-define-properties.js"(exports, module) {
    var DESCRIPTORS = require_descriptors();
    var definePropertyModule = require_object_define_property();
    var anObject = require_an_object();
    var objectKeys = require_object_keys();
    module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
      anObject(O);
      var keys = objectKeys(Properties);
      var length = keys.length;
      var index = 0;
      var key;
      while (length > index)
        definePropertyModule.f(O, key = keys[index++], Properties[key]);
      return O;
    };
  }
});

// node_modules/core-js/internals/html.js
var require_html = __commonJS({
  "node_modules/core-js/internals/html.js"(exports, module) {
    var getBuiltIn = require_get_built_in();
    module.exports = getBuiltIn("document", "documentElement");
  }
});

// node_modules/core-js/internals/object-create.js
var require_object_create = __commonJS({
  "node_modules/core-js/internals/object-create.js"(exports, module) {
    var anObject = require_an_object();
    var defineProperties = require_object_define_properties();
    var enumBugKeys = require_enum_bug_keys();
    var hiddenKeys = require_hidden_keys();
    var html = require_html();
    var documentCreateElement = require_document_create_element();
    var sharedKey = require_shared_key();
    var GT = ">";
    var LT = "<";
    var PROTOTYPE = "prototype";
    var SCRIPT = "script";
    var IE_PROTO = sharedKey("IE_PROTO");
    var EmptyConstructor = function() {
    };
    var scriptTag = function(content) {
      return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
    };
    var NullProtoObjectViaActiveX = function(activeXDocument2) {
      activeXDocument2.write(scriptTag(""));
      activeXDocument2.close();
      var temp = activeXDocument2.parentWindow.Object;
      activeXDocument2 = null;
      return temp;
    };
    var NullProtoObjectViaIFrame = function() {
      var iframe = documentCreateElement("iframe");
      var JS = "java" + SCRIPT + ":";
      var iframeDocument;
      iframe.style.display = "none";
      html.appendChild(iframe);
      iframe.src = String(JS);
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(scriptTag("document.F=Object"));
      iframeDocument.close();
      return iframeDocument.F;
    };
    var activeXDocument;
    var NullProtoObject = function() {
      try {
        activeXDocument = document.domain && new ActiveXObject("htmlfile");
      } catch (error) {
      }
      NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
      var length = enumBugKeys.length;
      while (length--)
        delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
      return NullProtoObject();
    };
    hiddenKeys[IE_PROTO] = true;
    module.exports = Object.create || function create(O, Properties) {
      var result;
      if (O !== null) {
        EmptyConstructor[PROTOTYPE] = anObject(O);
        result = new EmptyConstructor();
        EmptyConstructor[PROTOTYPE] = null;
        result[IE_PROTO] = O;
      } else
        result = NullProtoObject();
      return Properties === void 0 ? result : defineProperties(result, Properties);
    };
  }
});

// node_modules/core-js/internals/engine-user-agent.js
var require_engine_user_agent = __commonJS({
  "node_modules/core-js/internals/engine-user-agent.js"(exports, module) {
    var getBuiltIn = require_get_built_in();
    module.exports = getBuiltIn("navigator", "userAgent") || "";
  }
});

// node_modules/core-js/internals/engine-v8-version.js
var require_engine_v8_version = __commonJS({
  "node_modules/core-js/internals/engine-v8-version.js"(exports, module) {
    var global2 = require_global();
    var userAgent = require_engine_user_agent();
    var process = global2.process;
    var versions = process && process.versions;
    var v8 = versions && versions.v8;
    var match;
    var version;
    if (v8) {
      match = v8.split(".");
      version = match[0] < 4 ? 1 : match[0] + match[1];
    } else if (userAgent) {
      match = userAgent.match(/Edge\/(\d+)/);
      if (!match || match[1] >= 74) {
        match = userAgent.match(/Chrome\/(\d+)/);
        if (match)
          version = match[1];
      }
    }
    module.exports = version && +version;
  }
});

// node_modules/core-js/internals/native-symbol.js
var require_native_symbol = __commonJS({
  "node_modules/core-js/internals/native-symbol.js"(exports, module) {
    var V8_VERSION = require_engine_v8_version();
    var fails = require_fails();
    module.exports = !!Object.getOwnPropertySymbols && !fails(function() {
      var symbol = Symbol();
      return !String(symbol) || !(Object(symbol) instanceof Symbol) || !Symbol.sham && V8_VERSION && V8_VERSION < 41;
    });
  }
});

// node_modules/core-js/internals/use-symbol-as-uid.js
var require_use_symbol_as_uid = __commonJS({
  "node_modules/core-js/internals/use-symbol-as-uid.js"(exports, module) {
    var NATIVE_SYMBOL = require_native_symbol();
    module.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
  }
});

// node_modules/core-js/internals/well-known-symbol.js
var require_well_known_symbol = __commonJS({
  "node_modules/core-js/internals/well-known-symbol.js"(exports, module) {
    var global2 = require_global();
    var shared = require_shared();
    var has = require_has();
    var uid = require_uid();
    var NATIVE_SYMBOL = require_native_symbol();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var WellKnownSymbolsStore = shared("wks");
    var Symbol2 = global2.Symbol;
    var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
    module.exports = function(name) {
      if (!has(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == "string")) {
        if (NATIVE_SYMBOL && has(Symbol2, name)) {
          WellKnownSymbolsStore[name] = Symbol2[name];
        } else {
          WellKnownSymbolsStore[name] = createWellKnownSymbol("Symbol." + name);
        }
      }
      return WellKnownSymbolsStore[name];
    };
  }
});

// node_modules/core-js/internals/iterators.js
var require_iterators = __commonJS({
  "node_modules/core-js/internals/iterators.js"(exports, module) {
    module.exports = {};
  }
});

// node_modules/core-js/internals/is-array-iterator-method.js
var require_is_array_iterator_method = __commonJS({
  "node_modules/core-js/internals/is-array-iterator-method.js"(exports, module) {
    var wellKnownSymbol = require_well_known_symbol();
    var Iterators = require_iterators();
    var ITERATOR = wellKnownSymbol("iterator");
    var ArrayPrototype = Array.prototype;
    module.exports = function(it) {
      return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
    };
  }
});

// node_modules/core-js/internals/a-function.js
var require_a_function = __commonJS({
  "node_modules/core-js/internals/a-function.js"(exports, module) {
    module.exports = function(it) {
      if (typeof it != "function") {
        throw TypeError(String(it) + " is not a function");
      }
      return it;
    };
  }
});

// node_modules/core-js/internals/function-bind-context.js
var require_function_bind_context = __commonJS({
  "node_modules/core-js/internals/function-bind-context.js"(exports, module) {
    var aFunction = require_a_function();
    module.exports = function(fn, that, length) {
      aFunction(fn);
      if (that === void 0)
        return fn;
      switch (length) {
        case 0:
          return function() {
            return fn.call(that);
          };
        case 1:
          return function(a) {
            return fn.call(that, a);
          };
        case 2:
          return function(a, b) {
            return fn.call(that, a, b);
          };
        case 3:
          return function(a, b, c) {
            return fn.call(that, a, b, c);
          };
      }
      return function() {
        return fn.apply(that, arguments);
      };
    };
  }
});

// node_modules/core-js/internals/to-string-tag-support.js
var require_to_string_tag_support = __commonJS({
  "node_modules/core-js/internals/to-string-tag-support.js"(exports, module) {
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var test = {};
    test[TO_STRING_TAG] = "z";
    module.exports = String(test) === "[object z]";
  }
});

// node_modules/core-js/internals/classof.js
var require_classof = __commonJS({
  "node_modules/core-js/internals/classof.js"(exports, module) {
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var classofRaw = require_classof_raw();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var CORRECT_ARGUMENTS = classofRaw(function() {
      return arguments;
    }()) == "Arguments";
    var tryGet = function(it, key) {
      try {
        return it[key];
      } catch (error) {
      }
    };
    module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
      var O, tag, result;
      return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : result;
    };
  }
});

// node_modules/core-js/internals/get-iterator-method.js
var require_get_iterator_method = __commonJS({
  "node_modules/core-js/internals/get-iterator-method.js"(exports, module) {
    var classof = require_classof();
    var Iterators = require_iterators();
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    module.exports = function(it) {
      if (it != void 0)
        return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)];
    };
  }
});

// node_modules/core-js/internals/iterator-close.js
var require_iterator_close = __commonJS({
  "node_modules/core-js/internals/iterator-close.js"(exports, module) {
    var anObject = require_an_object();
    module.exports = function(iterator) {
      var returnMethod = iterator["return"];
      if (returnMethod !== void 0) {
        return anObject(returnMethod.call(iterator)).value;
      }
    };
  }
});

// node_modules/core-js/internals/iterate.js
var require_iterate = __commonJS({
  "node_modules/core-js/internals/iterate.js"(exports, module) {
    var anObject = require_an_object();
    var isArrayIteratorMethod = require_is_array_iterator_method();
    var toLength = require_to_length();
    var bind = require_function_bind_context();
    var getIteratorMethod = require_get_iterator_method();
    var iteratorClose = require_iterator_close();
    var Result = function(stopped, result) {
      this.stopped = stopped;
      this.result = result;
    };
    module.exports = function(iterable, unboundFunction, options) {
      var that = options && options.that;
      var AS_ENTRIES = !!(options && options.AS_ENTRIES);
      var IS_ITERATOR = !!(options && options.IS_ITERATOR);
      var INTERRUPTED = !!(options && options.INTERRUPTED);
      var fn = bind(unboundFunction, that, 1 + AS_ENTRIES + INTERRUPTED);
      var iterator, iterFn, index, length, result, next, step;
      var stop = function(condition) {
        if (iterator)
          iteratorClose(iterator);
        return new Result(true, condition);
      };
      var callFn = function(value) {
        if (AS_ENTRIES) {
          anObject(value);
          return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
        }
        return INTERRUPTED ? fn(value, stop) : fn(value);
      };
      if (IS_ITERATOR) {
        iterator = iterable;
      } else {
        iterFn = getIteratorMethod(iterable);
        if (typeof iterFn != "function")
          throw TypeError("Target is not iterable");
        if (isArrayIteratorMethod(iterFn)) {
          for (index = 0, length = toLength(iterable.length); length > index; index++) {
            result = callFn(iterable[index]);
            if (result && result instanceof Result)
              return result;
          }
          return new Result(false);
        }
        iterator = iterFn.call(iterable);
      }
      next = iterator.next;
      while (!(step = next.call(iterator)).done) {
        try {
          result = callFn(step.value);
        } catch (error) {
          iteratorClose(iterator);
          throw error;
        }
        if (typeof result == "object" && result && result instanceof Result)
          return result;
      }
      return new Result(false);
    };
  }
});

// node_modules/core-js/modules/es.aggregate-error.js
var require_es_aggregate_error = __commonJS({
  "node_modules/core-js/modules/es.aggregate-error.js"() {
    "use strict";
    var $ = require_export();
    var getPrototypeOf = require_object_get_prototype_of();
    var setPrototypeOf = require_object_set_prototype_of();
    var create = require_object_create();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var createPropertyDescriptor = require_create_property_descriptor();
    var iterate = require_iterate();
    var $AggregateError = function AggregateError(errors, message) {
      var that = this;
      if (!(that instanceof $AggregateError))
        return new $AggregateError(errors, message);
      if (setPrototypeOf) {
        that = setPrototypeOf(new Error(void 0), getPrototypeOf(that));
      }
      if (message !== void 0)
        createNonEnumerableProperty(that, "message", String(message));
      var errorsArray = [];
      iterate(errors, errorsArray.push, { that: errorsArray });
      createNonEnumerableProperty(that, "errors", errorsArray);
      return that;
    };
    $AggregateError.prototype = create(Error.prototype, {
      constructor: createPropertyDescriptor(5, $AggregateError),
      message: createPropertyDescriptor(5, ""),
      name: createPropertyDescriptor(5, "AggregateError")
    });
    $({ global: true }, {
      AggregateError: $AggregateError
    });
  }
});

// node_modules/core-js/internals/object-to-string.js
var require_object_to_string = __commonJS({
  "node_modules/core-js/internals/object-to-string.js"(exports, module) {
    "use strict";
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var classof = require_classof();
    module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
      return "[object " + classof(this) + "]";
    };
  }
});

// node_modules/core-js/modules/es.object.to-string.js
var require_es_object_to_string = __commonJS({
  "node_modules/core-js/modules/es.object.to-string.js"() {
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var redefine = require_redefine();
    var toString = require_object_to_string();
    if (!TO_STRING_TAG_SUPPORT) {
      redefine(Object.prototype, "toString", toString, { unsafe: true });
    }
  }
});

// node_modules/core-js/internals/native-promise-constructor.js
var require_native_promise_constructor = __commonJS({
  "node_modules/core-js/internals/native-promise-constructor.js"(exports, module) {
    var global2 = require_global();
    module.exports = global2.Promise;
  }
});

// node_modules/core-js/internals/redefine-all.js
var require_redefine_all = __commonJS({
  "node_modules/core-js/internals/redefine-all.js"(exports, module) {
    var redefine = require_redefine();
    module.exports = function(target, src, options) {
      for (var key in src)
        redefine(target, key, src[key], options);
      return target;
    };
  }
});

// node_modules/core-js/internals/set-to-string-tag.js
var require_set_to_string_tag = __commonJS({
  "node_modules/core-js/internals/set-to-string-tag.js"(exports, module) {
    var defineProperty = require_object_define_property().f;
    var has = require_has();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    module.exports = function(it, TAG, STATIC) {
      if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
        defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
      }
    };
  }
});

// node_modules/core-js/internals/set-species.js
var require_set_species = __commonJS({
  "node_modules/core-js/internals/set-species.js"(exports, module) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var definePropertyModule = require_object_define_property();
    var wellKnownSymbol = require_well_known_symbol();
    var DESCRIPTORS = require_descriptors();
    var SPECIES = wellKnownSymbol("species");
    module.exports = function(CONSTRUCTOR_NAME) {
      var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
      var defineProperty = definePropertyModule.f;
      if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
        defineProperty(Constructor, SPECIES, {
          configurable: true,
          get: function() {
            return this;
          }
        });
      }
    };
  }
});

// node_modules/core-js/internals/an-instance.js
var require_an_instance = __commonJS({
  "node_modules/core-js/internals/an-instance.js"(exports, module) {
    module.exports = function(it, Constructor, name) {
      if (!(it instanceof Constructor)) {
        throw TypeError("Incorrect " + (name ? name + " " : "") + "invocation");
      }
      return it;
    };
  }
});

// node_modules/core-js/internals/check-correctness-of-iteration.js
var require_check_correctness_of_iteration = __commonJS({
  "node_modules/core-js/internals/check-correctness-of-iteration.js"(exports, module) {
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    var SAFE_CLOSING = false;
    try {
      called = 0;
      iteratorWithReturn = {
        next: function() {
          return { done: !!called++ };
        },
        "return": function() {
          SAFE_CLOSING = true;
        }
      };
      iteratorWithReturn[ITERATOR] = function() {
        return this;
      };
      Array.from(iteratorWithReturn, function() {
        throw 2;
      });
    } catch (error) {
    }
    var called;
    var iteratorWithReturn;
    module.exports = function(exec, SKIP_CLOSING) {
      if (!SKIP_CLOSING && !SAFE_CLOSING)
        return false;
      var ITERATION_SUPPORT = false;
      try {
        var object = {};
        object[ITERATOR] = function() {
          return {
            next: function() {
              return { done: ITERATION_SUPPORT = true };
            }
          };
        };
        exec(object);
      } catch (error) {
      }
      return ITERATION_SUPPORT;
    };
  }
});

// node_modules/core-js/internals/species-constructor.js
var require_species_constructor = __commonJS({
  "node_modules/core-js/internals/species-constructor.js"(exports, module) {
    var anObject = require_an_object();
    var aFunction = require_a_function();
    var wellKnownSymbol = require_well_known_symbol();
    var SPECIES = wellKnownSymbol("species");
    module.exports = function(O, defaultConstructor) {
      var C = anObject(O).constructor;
      var S;
      return C === void 0 || (S = anObject(C)[SPECIES]) == void 0 ? defaultConstructor : aFunction(S);
    };
  }
});

// node_modules/core-js/internals/engine-is-ios.js
var require_engine_is_ios = __commonJS({
  "node_modules/core-js/internals/engine-is-ios.js"(exports, module) {
    var userAgent = require_engine_user_agent();
    module.exports = /(?:iphone|ipod|ipad).*applewebkit/i.test(userAgent);
  }
});

// node_modules/core-js/internals/engine-is-node.js
var require_engine_is_node = __commonJS({
  "node_modules/core-js/internals/engine-is-node.js"(exports, module) {
    var classof = require_classof_raw();
    var global2 = require_global();
    module.exports = classof(global2.process) == "process";
  }
});

// node_modules/core-js/internals/task.js
var require_task = __commonJS({
  "node_modules/core-js/internals/task.js"(exports, module) {
    var global2 = require_global();
    var fails = require_fails();
    var bind = require_function_bind_context();
    var html = require_html();
    var createElement = require_document_create_element();
    var IS_IOS = require_engine_is_ios();
    var IS_NODE = require_engine_is_node();
    var location = global2.location;
    var set = global2.setImmediate;
    var clear = global2.clearImmediate;
    var process = global2.process;
    var MessageChannel = global2.MessageChannel;
    var Dispatch = global2.Dispatch;
    var counter = 0;
    var queue = {};
    var ONREADYSTATECHANGE = "onreadystatechange";
    var defer;
    var channel;
    var port;
    var run = function(id) {
      if (queue.hasOwnProperty(id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
      }
    };
    var runner = function(id) {
      return function() {
        run(id);
      };
    };
    var listener = function(event) {
      run(event.data);
    };
    var post = function(id) {
      global2.postMessage(id + "", location.protocol + "//" + location.host);
    };
    if (!set || !clear) {
      set = function setImmediate(fn) {
        var args = [];
        var i = 1;
        while (arguments.length > i)
          args.push(arguments[i++]);
        queue[++counter] = function() {
          (typeof fn == "function" ? fn : Function(fn)).apply(void 0, args);
        };
        defer(counter);
        return counter;
      };
      clear = function clearImmediate(id) {
        delete queue[id];
      };
      if (IS_NODE) {
        defer = function(id) {
          process.nextTick(runner(id));
        };
      } else if (Dispatch && Dispatch.now) {
        defer = function(id) {
          Dispatch.now(runner(id));
        };
      } else if (MessageChannel && !IS_IOS) {
        channel = new MessageChannel();
        port = channel.port2;
        channel.port1.onmessage = listener;
        defer = bind(port.postMessage, port, 1);
      } else if (global2.addEventListener && typeof postMessage == "function" && !global2.importScripts && location && location.protocol !== "file:" && !fails(post)) {
        defer = post;
        global2.addEventListener("message", listener, false);
      } else if (ONREADYSTATECHANGE in createElement("script")) {
        defer = function(id) {
          html.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
            html.removeChild(this);
            run(id);
          };
        };
      } else {
        defer = function(id) {
          setTimeout(runner(id), 0);
        };
      }
    }
    module.exports = {
      set,
      clear
    };
  }
});

// node_modules/core-js/internals/engine-is-webos-webkit.js
var require_engine_is_webos_webkit = __commonJS({
  "node_modules/core-js/internals/engine-is-webos-webkit.js"(exports, module) {
    var userAgent = require_engine_user_agent();
    module.exports = /web0s(?!.*chrome)/i.test(userAgent);
  }
});

// node_modules/core-js/internals/microtask.js
var require_microtask = __commonJS({
  "node_modules/core-js/internals/microtask.js"(exports, module) {
    var global2 = require_global();
    var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    var macrotask = require_task().set;
    var IS_IOS = require_engine_is_ios();
    var IS_WEBOS_WEBKIT = require_engine_is_webos_webkit();
    var IS_NODE = require_engine_is_node();
    var MutationObserver = global2.MutationObserver || global2.WebKitMutationObserver;
    var document2 = global2.document;
    var process = global2.process;
    var Promise2 = global2.Promise;
    var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global2, "queueMicrotask");
    var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
    var flush;
    var head;
    var last;
    var notify;
    var toggle;
    var node;
    var promise;
    var then;
    if (!queueMicrotask) {
      flush = function() {
        var parent, fn;
        if (IS_NODE && (parent = process.domain))
          parent.exit();
        while (head) {
          fn = head.fn;
          head = head.next;
          try {
            fn();
          } catch (error) {
            if (head)
              notify();
            else
              last = void 0;
            throw error;
          }
        }
        last = void 0;
        if (parent)
          parent.enter();
      };
      if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document2) {
        toggle = true;
        node = document2.createTextNode("");
        new MutationObserver(flush).observe(node, { characterData: true });
        notify = function() {
          node.data = toggle = !toggle;
        };
      } else if (Promise2 && Promise2.resolve) {
        promise = Promise2.resolve(void 0);
        promise.constructor = Promise2;
        then = promise.then;
        notify = function() {
          then.call(promise, flush);
        };
      } else if (IS_NODE) {
        notify = function() {
          process.nextTick(flush);
        };
      } else {
        notify = function() {
          macrotask.call(global2, flush);
        };
      }
    }
    module.exports = queueMicrotask || function(fn) {
      var task = { fn, next: void 0 };
      if (last)
        last.next = task;
      if (!head) {
        head = task;
        notify();
      }
      last = task;
    };
  }
});

// node_modules/core-js/internals/new-promise-capability.js
var require_new_promise_capability = __commonJS({
  "node_modules/core-js/internals/new-promise-capability.js"(exports, module) {
    "use strict";
    var aFunction = require_a_function();
    var PromiseCapability = function(C) {
      var resolve, reject;
      this.promise = new C(function($$resolve, $$reject) {
        if (resolve !== void 0 || reject !== void 0)
          throw TypeError("Bad Promise constructor");
        resolve = $$resolve;
        reject = $$reject;
      });
      this.resolve = aFunction(resolve);
      this.reject = aFunction(reject);
    };
    module.exports.f = function(C) {
      return new PromiseCapability(C);
    };
  }
});

// node_modules/core-js/internals/promise-resolve.js
var require_promise_resolve = __commonJS({
  "node_modules/core-js/internals/promise-resolve.js"(exports, module) {
    var anObject = require_an_object();
    var isObject = require_is_object();
    var newPromiseCapability = require_new_promise_capability();
    module.exports = function(C, x) {
      anObject(C);
      if (isObject(x) && x.constructor === C)
        return x;
      var promiseCapability = newPromiseCapability.f(C);
      var resolve = promiseCapability.resolve;
      resolve(x);
      return promiseCapability.promise;
    };
  }
});

// node_modules/core-js/internals/host-report-errors.js
var require_host_report_errors = __commonJS({
  "node_modules/core-js/internals/host-report-errors.js"(exports, module) {
    var global2 = require_global();
    module.exports = function(a, b) {
      var console2 = global2.console;
      if (console2 && console2.error) {
        arguments.length === 1 ? console2.error(a) : console2.error(a, b);
      }
    };
  }
});

// node_modules/core-js/internals/perform.js
var require_perform = __commonJS({
  "node_modules/core-js/internals/perform.js"(exports, module) {
    module.exports = function(exec) {
      try {
        return { error: false, value: exec() };
      } catch (error) {
        return { error: true, value: error };
      }
    };
  }
});

// node_modules/core-js/internals/engine-is-browser.js
var require_engine_is_browser = __commonJS({
  "node_modules/core-js/internals/engine-is-browser.js"(exports, module) {
    module.exports = typeof window == "object";
  }
});

// node_modules/core-js/modules/es.promise.js
var require_es_promise = __commonJS({
  "node_modules/core-js/modules/es.promise.js"() {
    "use strict";
    var $ = require_export();
    var IS_PURE = require_is_pure();
    var global2 = require_global();
    var getBuiltIn = require_get_built_in();
    var NativePromise = require_native_promise_constructor();
    var redefine = require_redefine();
    var redefineAll = require_redefine_all();
    var setPrototypeOf = require_object_set_prototype_of();
    var setToStringTag = require_set_to_string_tag();
    var setSpecies = require_set_species();
    var isObject = require_is_object();
    var aFunction = require_a_function();
    var anInstance = require_an_instance();
    var inspectSource = require_inspect_source();
    var iterate = require_iterate();
    var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
    var speciesConstructor = require_species_constructor();
    var task = require_task().set;
    var microtask = require_microtask();
    var promiseResolve = require_promise_resolve();
    var hostReportErrors = require_host_report_errors();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var perform = require_perform();
    var InternalStateModule = require_internal_state();
    var isForced = require_is_forced();
    var wellKnownSymbol = require_well_known_symbol();
    var IS_BROWSER = require_engine_is_browser();
    var IS_NODE = require_engine_is_node();
    var V8_VERSION = require_engine_v8_version();
    var SPECIES = wellKnownSymbol("species");
    var PROMISE = "Promise";
    var getInternalState = InternalStateModule.get;
    var setInternalState = InternalStateModule.set;
    var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
    var NativePromisePrototype = NativePromise && NativePromise.prototype;
    var PromiseConstructor = NativePromise;
    var PromiseConstructorPrototype = NativePromisePrototype;
    var TypeError2 = global2.TypeError;
    var document2 = global2.document;
    var process = global2.process;
    var newPromiseCapability = newPromiseCapabilityModule.f;
    var newGenericPromiseCapability = newPromiseCapability;
    var DISPATCH_EVENT = !!(document2 && document2.createEvent && global2.dispatchEvent);
    var NATIVE_REJECTION_EVENT = typeof PromiseRejectionEvent == "function";
    var UNHANDLED_REJECTION = "unhandledrejection";
    var REJECTION_HANDLED = "rejectionhandled";
    var PENDING = 0;
    var FULFILLED = 1;
    var REJECTED = 2;
    var HANDLED = 1;
    var UNHANDLED = 2;
    var SUBCLASSING = false;
    var Internal;
    var OwnPromiseCapability;
    var PromiseWrapper;
    var nativeThen;
    var FORCED = isForced(PROMISE, function() {
      var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(PromiseConstructor);
      var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(PromiseConstructor);
      if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66)
        return true;
      if (IS_PURE && !PromiseConstructorPrototype["finally"])
        return true;
      if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE))
        return false;
      var promise = new PromiseConstructor(function(resolve) {
        resolve(1);
      });
      var FakePromise = function(exec) {
        exec(function() {
        }, function() {
        });
      };
      var constructor = promise.constructor = {};
      constructor[SPECIES] = FakePromise;
      SUBCLASSING = promise.then(function() {
      }) instanceof FakePromise;
      if (!SUBCLASSING)
        return true;
      return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_REJECTION_EVENT;
    });
    var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function(iterable) {
      PromiseConstructor.all(iterable)["catch"](function() {
      });
    });
    var isThenable = function(it) {
      var then;
      return isObject(it) && typeof (then = it.then) == "function" ? then : false;
    };
    var notify = function(state, isReject) {
      if (state.notified)
        return;
      state.notified = true;
      var chain = state.reactions;
      microtask(function() {
        var value = state.value;
        var ok = state.state == FULFILLED;
        var index = 0;
        while (chain.length > index) {
          var reaction = chain[index++];
          var handler = ok ? reaction.ok : reaction.fail;
          var resolve = reaction.resolve;
          var reject = reaction.reject;
          var domain = reaction.domain;
          var result, then, exited;
          try {
            if (handler) {
              if (!ok) {
                if (state.rejection === UNHANDLED)
                  onHandleUnhandled(state);
                state.rejection = HANDLED;
              }
              if (handler === true)
                result = value;
              else {
                if (domain)
                  domain.enter();
                result = handler(value);
                if (domain) {
                  domain.exit();
                  exited = true;
                }
              }
              if (result === reaction.promise) {
                reject(TypeError2("Promise-chain cycle"));
              } else if (then = isThenable(result)) {
                then.call(result, resolve, reject);
              } else
                resolve(result);
            } else
              reject(value);
          } catch (error) {
            if (domain && !exited)
              domain.exit();
            reject(error);
          }
        }
        state.reactions = [];
        state.notified = false;
        if (isReject && !state.rejection)
          onUnhandled(state);
      });
    };
    var dispatchEvent = function(name, promise, reason) {
      var event, handler;
      if (DISPATCH_EVENT) {
        event = document2.createEvent("Event");
        event.promise = promise;
        event.reason = reason;
        event.initEvent(name, false, true);
        global2.dispatchEvent(event);
      } else
        event = { promise, reason };
      if (!NATIVE_REJECTION_EVENT && (handler = global2["on" + name]))
        handler(event);
      else if (name === UNHANDLED_REJECTION)
        hostReportErrors("Unhandled promise rejection", reason);
    };
    var onUnhandled = function(state) {
      task.call(global2, function() {
        var promise = state.facade;
        var value = state.value;
        var IS_UNHANDLED = isUnhandled(state);
        var result;
        if (IS_UNHANDLED) {
          result = perform(function() {
            if (IS_NODE) {
              process.emit("unhandledRejection", value, promise);
            } else
              dispatchEvent(UNHANDLED_REJECTION, promise, value);
          });
          state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
          if (result.error)
            throw result.value;
        }
      });
    };
    var isUnhandled = function(state) {
      return state.rejection !== HANDLED && !state.parent;
    };
    var onHandleUnhandled = function(state) {
      task.call(global2, function() {
        var promise = state.facade;
        if (IS_NODE) {
          process.emit("rejectionHandled", promise);
        } else
          dispatchEvent(REJECTION_HANDLED, promise, state.value);
      });
    };
    var bind = function(fn, state, unwrap) {
      return function(value) {
        fn(state, value, unwrap);
      };
    };
    var internalReject = function(state, value, unwrap) {
      if (state.done)
        return;
      state.done = true;
      if (unwrap)
        state = unwrap;
      state.value = value;
      state.state = REJECTED;
      notify(state, true);
    };
    var internalResolve = function(state, value, unwrap) {
      if (state.done)
        return;
      state.done = true;
      if (unwrap)
        state = unwrap;
      try {
        if (state.facade === value)
          throw TypeError2("Promise can't be resolved itself");
        var then = isThenable(value);
        if (then) {
          microtask(function() {
            var wrapper = { done: false };
            try {
              then.call(
                value,
                bind(internalResolve, wrapper, state),
                bind(internalReject, wrapper, state)
              );
            } catch (error) {
              internalReject(wrapper, error, state);
            }
          });
        } else {
          state.value = value;
          state.state = FULFILLED;
          notify(state, false);
        }
      } catch (error) {
        internalReject({ done: false }, error, state);
      }
    };
    if (FORCED) {
      PromiseConstructor = function Promise2(executor) {
        anInstance(this, PromiseConstructor, PROMISE);
        aFunction(executor);
        Internal.call(this);
        var state = getInternalState(this);
        try {
          executor(bind(internalResolve, state), bind(internalReject, state));
        } catch (error) {
          internalReject(state, error);
        }
      };
      PromiseConstructorPrototype = PromiseConstructor.prototype;
      Internal = function Promise2(executor) {
        setInternalState(this, {
          type: PROMISE,
          done: false,
          notified: false,
          parent: false,
          reactions: [],
          rejection: false,
          state: PENDING,
          value: void 0
        });
      };
      Internal.prototype = redefineAll(PromiseConstructorPrototype, {
        then: function then(onFulfilled, onRejected) {
          var state = getInternalPromiseState(this);
          var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
          reaction.ok = typeof onFulfilled == "function" ? onFulfilled : true;
          reaction.fail = typeof onRejected == "function" && onRejected;
          reaction.domain = IS_NODE ? process.domain : void 0;
          state.parent = true;
          state.reactions.push(reaction);
          if (state.state != PENDING)
            notify(state, false);
          return reaction.promise;
        },
        "catch": function(onRejected) {
          return this.then(void 0, onRejected);
        }
      });
      OwnPromiseCapability = function() {
        var promise = new Internal();
        var state = getInternalState(promise);
        this.promise = promise;
        this.resolve = bind(internalResolve, state);
        this.reject = bind(internalReject, state);
      };
      newPromiseCapabilityModule.f = newPromiseCapability = function(C) {
        return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
      };
      if (!IS_PURE && typeof NativePromise == "function" && NativePromisePrototype !== Object.prototype) {
        nativeThen = NativePromisePrototype.then;
        if (!SUBCLASSING) {
          redefine(NativePromisePrototype, "then", function then(onFulfilled, onRejected) {
            var that = this;
            return new PromiseConstructor(function(resolve, reject) {
              nativeThen.call(that, resolve, reject);
            }).then(onFulfilled, onRejected);
          }, { unsafe: true });
          redefine(NativePromisePrototype, "catch", PromiseConstructorPrototype["catch"], { unsafe: true });
        }
        try {
          delete NativePromisePrototype.constructor;
        } catch (error) {
        }
        if (setPrototypeOf) {
          setPrototypeOf(NativePromisePrototype, PromiseConstructorPrototype);
        }
      }
    }
    $({ global: true, wrap: true, forced: FORCED }, {
      Promise: PromiseConstructor
    });
    setToStringTag(PromiseConstructor, PROMISE, false, true);
    setSpecies(PROMISE);
    PromiseWrapper = getBuiltIn(PROMISE);
    $({ target: PROMISE, stat: true, forced: FORCED }, {
      reject: function reject(r2) {
        var capability = newPromiseCapability(this);
        capability.reject.call(void 0, r2);
        return capability.promise;
      }
    });
    $({ target: PROMISE, stat: true, forced: IS_PURE || FORCED }, {
      resolve: function resolve(x) {
        return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);
      }
    });
    $({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
      all: function all(iterable) {
        var C = this;
        var capability = newPromiseCapability(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform(function() {
          var $promiseResolve = aFunction(C.resolve);
          var values = [];
          var counter = 0;
          var remaining = 1;
          iterate(iterable, function(promise) {
            var index = counter++;
            var alreadyCalled = false;
            values.push(void 0);
            remaining++;
            $promiseResolve.call(C, promise).then(function(value) {
              if (alreadyCalled)
                return;
              alreadyCalled = true;
              values[index] = value;
              --remaining || resolve(values);
            }, reject);
          });
          --remaining || resolve(values);
        });
        if (result.error)
          reject(result.value);
        return capability.promise;
      },
      race: function race(iterable) {
        var C = this;
        var capability = newPromiseCapability(C);
        var reject = capability.reject;
        var result = perform(function() {
          var $promiseResolve = aFunction(C.resolve);
          iterate(iterable, function(promise) {
            $promiseResolve.call(C, promise).then(capability.resolve, reject);
          });
        });
        if (result.error)
          reject(result.value);
        return capability.promise;
      }
    });
  }
});

// node_modules/core-js/modules/es.promise.all-settled.js
var require_es_promise_all_settled = __commonJS({
  "node_modules/core-js/modules/es.promise.all-settled.js"() {
    "use strict";
    var $ = require_export();
    var aFunction = require_a_function();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var perform = require_perform();
    var iterate = require_iterate();
    $({ target: "Promise", stat: true }, {
      allSettled: function allSettled(iterable) {
        var C = this;
        var capability = newPromiseCapabilityModule.f(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform(function() {
          var promiseResolve = aFunction(C.resolve);
          var values = [];
          var counter = 0;
          var remaining = 1;
          iterate(iterable, function(promise) {
            var index = counter++;
            var alreadyCalled = false;
            values.push(void 0);
            remaining++;
            promiseResolve.call(C, promise).then(function(value) {
              if (alreadyCalled)
                return;
              alreadyCalled = true;
              values[index] = { status: "fulfilled", value };
              --remaining || resolve(values);
            }, function(error) {
              if (alreadyCalled)
                return;
              alreadyCalled = true;
              values[index] = { status: "rejected", reason: error };
              --remaining || resolve(values);
            });
          });
          --remaining || resolve(values);
        });
        if (result.error)
          reject(result.value);
        return capability.promise;
      }
    });
  }
});

// node_modules/core-js/modules/es.promise.any.js
var require_es_promise_any = __commonJS({
  "node_modules/core-js/modules/es.promise.any.js"() {
    "use strict";
    var $ = require_export();
    var aFunction = require_a_function();
    var getBuiltIn = require_get_built_in();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var perform = require_perform();
    var iterate = require_iterate();
    var PROMISE_ANY_ERROR = "No one promise resolved";
    $({ target: "Promise", stat: true }, {
      any: function any(iterable) {
        var C = this;
        var capability = newPromiseCapabilityModule.f(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform(function() {
          var promiseResolve = aFunction(C.resolve);
          var errors = [];
          var counter = 0;
          var remaining = 1;
          var alreadyResolved = false;
          iterate(iterable, function(promise) {
            var index = counter++;
            var alreadyRejected = false;
            errors.push(void 0);
            remaining++;
            promiseResolve.call(C, promise).then(function(value) {
              if (alreadyRejected || alreadyResolved)
                return;
              alreadyResolved = true;
              resolve(value);
            }, function(error) {
              if (alreadyRejected || alreadyResolved)
                return;
              alreadyRejected = true;
              errors[index] = error;
              --remaining || reject(new (getBuiltIn("AggregateError"))(errors, PROMISE_ANY_ERROR));
            });
          });
          --remaining || reject(new (getBuiltIn("AggregateError"))(errors, PROMISE_ANY_ERROR));
        });
        if (result.error)
          reject(result.value);
        return capability.promise;
      }
    });
  }
});

// node_modules/core-js/modules/es.promise.finally.js
var require_es_promise_finally = __commonJS({
  "node_modules/core-js/modules/es.promise.finally.js"() {
    "use strict";
    var $ = require_export();
    var IS_PURE = require_is_pure();
    var NativePromise = require_native_promise_constructor();
    var fails = require_fails();
    var getBuiltIn = require_get_built_in();
    var speciesConstructor = require_species_constructor();
    var promiseResolve = require_promise_resolve();
    var redefine = require_redefine();
    var NON_GENERIC = !!NativePromise && fails(function() {
      NativePromise.prototype["finally"].call({ then: function() {
      } }, function() {
      });
    });
    $({ target: "Promise", proto: true, real: true, forced: NON_GENERIC }, {
      "finally": function(onFinally) {
        var C = speciesConstructor(this, getBuiltIn("Promise"));
        var isFunction = typeof onFinally == "function";
        return this.then(
          isFunction ? function(x) {
            return promiseResolve(C, onFinally()).then(function() {
              return x;
            });
          } : onFinally,
          isFunction ? function(e2) {
            return promiseResolve(C, onFinally()).then(function() {
              throw e2;
            });
          } : onFinally
        );
      }
    });
    if (!IS_PURE && typeof NativePromise == "function") {
      method = getBuiltIn("Promise").prototype["finally"];
      if (NativePromise.prototype["finally"] !== method) {
        redefine(NativePromise.prototype, "finally", method, { unsafe: true });
      }
    }
    var method;
  }
});

// node_modules/core-js/internals/string-multibyte.js
var require_string_multibyte = __commonJS({
  "node_modules/core-js/internals/string-multibyte.js"(exports, module) {
    var toInteger = require_to_integer();
    var requireObjectCoercible = require_require_object_coercible();
    var createMethod = function(CONVERT_TO_STRING) {
      return function($this, pos) {
        var S = String(requireObjectCoercible($this));
        var position = toInteger(pos);
        var size = S.length;
        var first, second;
        if (position < 0 || position >= size)
          return CONVERT_TO_STRING ? "" : void 0;
        first = S.charCodeAt(position);
        return first < 55296 || first > 56319 || position + 1 === size || (second = S.charCodeAt(position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
      };
    };
    module.exports = {
      codeAt: createMethod(false),
      charAt: createMethod(true)
    };
  }
});

// node_modules/core-js/internals/iterators-core.js
var require_iterators_core = __commonJS({
  "node_modules/core-js/internals/iterators-core.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var getPrototypeOf = require_object_get_prototype_of();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var has = require_has();
    var wellKnownSymbol = require_well_known_symbol();
    var IS_PURE = require_is_pure();
    var ITERATOR = wellKnownSymbol("iterator");
    var BUGGY_SAFARI_ITERATORS = false;
    var returnThis = function() {
      return this;
    };
    var IteratorPrototype;
    var PrototypeOfArrayIteratorPrototype;
    var arrayIterator;
    if ([].keys) {
      arrayIterator = [].keys();
      if (!("next" in arrayIterator))
        BUGGY_SAFARI_ITERATORS = true;
      else {
        PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
        if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
          IteratorPrototype = PrototypeOfArrayIteratorPrototype;
      }
    }
    var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == void 0 || fails(function() {
      var test = {};
      return IteratorPrototype[ITERATOR].call(test) !== test;
    });
    if (NEW_ITERATOR_PROTOTYPE)
      IteratorPrototype = {};
    if ((!IS_PURE || NEW_ITERATOR_PROTOTYPE) && !has(IteratorPrototype, ITERATOR)) {
      createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
    }
    module.exports = {
      IteratorPrototype,
      BUGGY_SAFARI_ITERATORS
    };
  }
});

// node_modules/core-js/internals/create-iterator-constructor.js
var require_create_iterator_constructor = __commonJS({
  "node_modules/core-js/internals/create-iterator-constructor.js"(exports, module) {
    "use strict";
    var IteratorPrototype = require_iterators_core().IteratorPrototype;
    var create = require_object_create();
    var createPropertyDescriptor = require_create_property_descriptor();
    var setToStringTag = require_set_to_string_tag();
    var Iterators = require_iterators();
    var returnThis = function() {
      return this;
    };
    module.exports = function(IteratorConstructor, NAME, next) {
      var TO_STRING_TAG = NAME + " Iterator";
      IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
      setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
      Iterators[TO_STRING_TAG] = returnThis;
      return IteratorConstructor;
    };
  }
});

// node_modules/core-js/internals/define-iterator.js
var require_define_iterator = __commonJS({
  "node_modules/core-js/internals/define-iterator.js"(exports, module) {
    "use strict";
    var $ = require_export();
    var createIteratorConstructor = require_create_iterator_constructor();
    var getPrototypeOf = require_object_get_prototype_of();
    var setPrototypeOf = require_object_set_prototype_of();
    var setToStringTag = require_set_to_string_tag();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var redefine = require_redefine();
    var wellKnownSymbol = require_well_known_symbol();
    var IS_PURE = require_is_pure();
    var Iterators = require_iterators();
    var IteratorsCore = require_iterators_core();
    var IteratorPrototype = IteratorsCore.IteratorPrototype;
    var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
    var ITERATOR = wellKnownSymbol("iterator");
    var KEYS = "keys";
    var VALUES = "values";
    var ENTRIES = "entries";
    var returnThis = function() {
      return this;
    };
    module.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
      createIteratorConstructor(IteratorConstructor, NAME, next);
      var getIterationMethod = function(KIND) {
        if (KIND === DEFAULT && defaultIterator)
          return defaultIterator;
        if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
          return IterablePrototype[KIND];
        switch (KIND) {
          case KEYS:
            return function keys() {
              return new IteratorConstructor(this, KIND);
            };
          case VALUES:
            return function values() {
              return new IteratorConstructor(this, KIND);
            };
          case ENTRIES:
            return function entries() {
              return new IteratorConstructor(this, KIND);
            };
        }
        return function() {
          return new IteratorConstructor(this);
        };
      };
      var TO_STRING_TAG = NAME + " Iterator";
      var INCORRECT_VALUES_NAME = false;
      var IterablePrototype = Iterable.prototype;
      var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
      var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
      var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
      var CurrentIteratorPrototype, methods, KEY;
      if (anyNativeIterator) {
        CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
        if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
          if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
            if (setPrototypeOf) {
              setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
            } else if (typeof CurrentIteratorPrototype[ITERATOR] != "function") {
              createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
            }
          }
          setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
          if (IS_PURE)
            Iterators[TO_STRING_TAG] = returnThis;
        }
      }
      if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
        INCORRECT_VALUES_NAME = true;
        defaultIterator = function values() {
          return nativeIterator.call(this);
        };
      }
      if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
        createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
      }
      Iterators[NAME] = defaultIterator;
      if (DEFAULT) {
        methods = {
          values: getIterationMethod(VALUES),
          keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
          entries: getIterationMethod(ENTRIES)
        };
        if (FORCED)
          for (KEY in methods) {
            if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
              redefine(IterablePrototype, KEY, methods[KEY]);
            }
          }
        else
          $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
      }
      return methods;
    };
  }
});

// node_modules/core-js/modules/es.string.iterator.js
var require_es_string_iterator = __commonJS({
  "node_modules/core-js/modules/es.string.iterator.js"() {
    "use strict";
    var charAt = require_string_multibyte().charAt;
    var InternalStateModule = require_internal_state();
    var defineIterator = require_define_iterator();
    var STRING_ITERATOR = "String Iterator";
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
    defineIterator(String, "String", function(iterated) {
      setInternalState(this, {
        type: STRING_ITERATOR,
        string: String(iterated),
        index: 0
      });
    }, function next() {
      var state = getInternalState(this);
      var string = state.string;
      var index = state.index;
      var point;
      if (index >= string.length)
        return { value: void 0, done: true };
      point = charAt(string, index);
      state.index += point.length;
      return { value: point, done: false };
    });
  }
});

// node_modules/core-js/internals/dom-iterables.js
var require_dom_iterables = __commonJS({
  "node_modules/core-js/internals/dom-iterables.js"(exports, module) {
    module.exports = {
      CSSRuleList: 0,
      CSSStyleDeclaration: 0,
      CSSValueList: 0,
      ClientRectList: 0,
      DOMRectList: 0,
      DOMStringList: 0,
      DOMTokenList: 1,
      DataTransferItemList: 0,
      FileList: 0,
      HTMLAllCollection: 0,
      HTMLCollection: 0,
      HTMLFormElement: 0,
      HTMLSelectElement: 0,
      MediaList: 0,
      MimeTypeArray: 0,
      NamedNodeMap: 0,
      NodeList: 1,
      PaintRequestList: 0,
      Plugin: 0,
      PluginArray: 0,
      SVGLengthList: 0,
      SVGNumberList: 0,
      SVGPathSegList: 0,
      SVGPointList: 0,
      SVGStringList: 0,
      SVGTransformList: 0,
      SourceBufferList: 0,
      StyleSheetList: 0,
      TextTrackCueList: 0,
      TextTrackList: 0,
      TouchList: 0
    };
  }
});

// node_modules/core-js/internals/add-to-unscopables.js
var require_add_to_unscopables = __commonJS({
  "node_modules/core-js/internals/add-to-unscopables.js"(exports, module) {
    var wellKnownSymbol = require_well_known_symbol();
    var create = require_object_create();
    var definePropertyModule = require_object_define_property();
    var UNSCOPABLES = wellKnownSymbol("unscopables");
    var ArrayPrototype = Array.prototype;
    if (ArrayPrototype[UNSCOPABLES] == void 0) {
      definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
        configurable: true,
        value: create(null)
      });
    }
    module.exports = function(key) {
      ArrayPrototype[UNSCOPABLES][key] = true;
    };
  }
});

// node_modules/core-js/modules/es.array.iterator.js
var require_es_array_iterator = __commonJS({
  "node_modules/core-js/modules/es.array.iterator.js"(exports, module) {
    "use strict";
    var toIndexedObject = require_to_indexed_object();
    var addToUnscopables = require_add_to_unscopables();
    var Iterators = require_iterators();
    var InternalStateModule = require_internal_state();
    var defineIterator = require_define_iterator();
    var ARRAY_ITERATOR = "Array Iterator";
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
    module.exports = defineIterator(Array, "Array", function(iterated, kind) {
      setInternalState(this, {
        type: ARRAY_ITERATOR,
        target: toIndexedObject(iterated),
        index: 0,
        kind
      });
    }, function() {
      var state = getInternalState(this);
      var target = state.target;
      var kind = state.kind;
      var index = state.index++;
      if (!target || index >= target.length) {
        state.target = void 0;
        return { value: void 0, done: true };
      }
      if (kind == "keys")
        return { value: index, done: false };
      if (kind == "values")
        return { value: target[index], done: false };
      return { value: [index, target[index]], done: false };
    }, "values");
    Iterators.Arguments = Iterators.Array;
    addToUnscopables("keys");
    addToUnscopables("values");
    addToUnscopables("entries");
  }
});

// node_modules/core-js/modules/web.dom-collections.iterator.js
var require_web_dom_collections_iterator = __commonJS({
  "node_modules/core-js/modules/web.dom-collections.iterator.js"() {
    var global2 = require_global();
    var DOMIterables = require_dom_iterables();
    var ArrayIteratorMethods = require_es_array_iterator();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var ArrayValues = ArrayIteratorMethods.values;
    for (COLLECTION_NAME in DOMIterables) {
      Collection = global2[COLLECTION_NAME];
      CollectionPrototype = Collection && Collection.prototype;
      if (CollectionPrototype) {
        if (CollectionPrototype[ITERATOR] !== ArrayValues)
          try {
            createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
          } catch (error) {
            CollectionPrototype[ITERATOR] = ArrayValues;
          }
        if (!CollectionPrototype[TO_STRING_TAG]) {
          createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
        }
        if (DOMIterables[COLLECTION_NAME])
          for (METHOD_NAME in ArrayIteratorMethods) {
            if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])
              try {
                createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
              } catch (error) {
                CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
              }
          }
      }
    }
    var Collection;
    var CollectionPrototype;
    var METHOD_NAME;
    var COLLECTION_NAME;
  }
});

// node_modules/core-js/es/promise/index.js
var require_promise = __commonJS({
  "node_modules/core-js/es/promise/index.js"(exports, module) {
    require_es_aggregate_error();
    require_es_object_to_string();
    require_es_promise();
    require_es_promise_all_settled();
    require_es_promise_any();
    require_es_promise_finally();
    require_es_string_iterator();
    require_web_dom_collections_iterator();
    var path = require_path();
    module.exports = path.Promise;
  }
});

// node_modules/core-js/modules/esnext.aggregate-error.js
var require_esnext_aggregate_error = __commonJS({
  "node_modules/core-js/modules/esnext.aggregate-error.js"() {
    require_es_aggregate_error();
  }
});

// node_modules/core-js/modules/esnext.promise.all-settled.js
var require_esnext_promise_all_settled = __commonJS({
  "node_modules/core-js/modules/esnext.promise.all-settled.js"() {
    require_es_promise_all_settled();
  }
});

// node_modules/core-js/modules/esnext.promise.try.js
var require_esnext_promise_try = __commonJS({
  "node_modules/core-js/modules/esnext.promise.try.js"() {
    "use strict";
    var $ = require_export();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var perform = require_perform();
    $({ target: "Promise", stat: true }, {
      "try": function(callbackfn) {
        var promiseCapability = newPromiseCapabilityModule.f(this);
        var result = perform(callbackfn);
        (result.error ? promiseCapability.reject : promiseCapability.resolve)(result.value);
        return promiseCapability.promise;
      }
    });
  }
});

// node_modules/core-js/modules/esnext.promise.any.js
var require_esnext_promise_any = __commonJS({
  "node_modules/core-js/modules/esnext.promise.any.js"() {
    require_es_promise_any();
  }
});

// node_modules/core-js/features/promise/index.js
var require_promise2 = __commonJS({
  "node_modules/core-js/features/promise/index.js"(exports, module) {
    var parent = require_promise();
    require_esnext_aggregate_error();
    require_esnext_promise_all_settled();
    require_esnext_promise_try();
    require_esnext_promise_any();
    module.exports = parent;
  }
});

// node_modules/url-search-params-polyfill/index.js
var require_url_search_params_polyfill = __commonJS({
  "node_modules/url-search-params-polyfill/index.js"(exports) {
    (function(self2) {
      "use strict";
      var nativeURLSearchParams = function() {
        try {
          if (self2.URLSearchParams && new self2.URLSearchParams("foo=bar").get("foo") === "bar") {
            return self2.URLSearchParams;
          }
        } catch (e2) {
        }
        return null;
      }(), isSupportObjectConstructor = nativeURLSearchParams && new nativeURLSearchParams({ a: 1 }).toString() === "a=1", decodesPlusesCorrectly = nativeURLSearchParams && new nativeURLSearchParams("s=%2B").get("s") === "+", __URLSearchParams__ = "__URLSearchParams__", encodesAmpersandsCorrectly = nativeURLSearchParams ? function() {
        var ampersandTest = new nativeURLSearchParams();
        ampersandTest.append("s", " &");
        return ampersandTest.toString() === "s=+%26";
      }() : true, prototype = URLSearchParamsPolyfill.prototype, iterable = !!(self2.Symbol && self2.Symbol.iterator);
      if (nativeURLSearchParams && isSupportObjectConstructor && decodesPlusesCorrectly && encodesAmpersandsCorrectly) {
        return;
      }
      function URLSearchParamsPolyfill(search) {
        search = search || "";
        if (search instanceof URLSearchParams || search instanceof URLSearchParamsPolyfill) {
          search = search.toString();
        }
        this[__URLSearchParams__] = parseToDict(search);
      }
      prototype.append = function(name, value) {
        appendTo(this[__URLSearchParams__], name, value);
      };
      prototype["delete"] = function(name) {
        delete this[__URLSearchParams__][name];
      };
      prototype.get = function(name) {
        var dict = this[__URLSearchParams__];
        return this.has(name) ? dict[name][0] : null;
      };
      prototype.getAll = function(name) {
        var dict = this[__URLSearchParams__];
        return this.has(name) ? dict[name].slice(0) : [];
      };
      prototype.has = function(name) {
        return hasOwnProperty(this[__URLSearchParams__], name);
      };
      prototype.set = function set(name, value) {
        this[__URLSearchParams__][name] = ["" + value];
      };
      prototype.toString = function() {
        var dict = this[__URLSearchParams__], query = [], i, key, name, value;
        for (key in dict) {
          name = encode(key);
          for (i = 0, value = dict[key]; i < value.length; i++) {
            query.push(name + "=" + encode(value[i]));
          }
        }
        return query.join("&");
      };
      var forSureUsePolyfill = !decodesPlusesCorrectly;
      var useProxy = !forSureUsePolyfill && nativeURLSearchParams && !isSupportObjectConstructor && self2.Proxy;
      var propValue;
      if (useProxy) {
        propValue = new Proxy(nativeURLSearchParams, {
          construct: function(target, args) {
            return new target(new URLSearchParamsPolyfill(args[0]).toString());
          }
        });
        propValue.toString = Function.prototype.toString.bind(URLSearchParamsPolyfill);
      } else {
        propValue = URLSearchParamsPolyfill;
      }
      Object.defineProperty(self2, "URLSearchParams", {
        value: propValue
      });
      var USPProto = self2.URLSearchParams.prototype;
      USPProto.polyfill = true;
      USPProto.forEach = USPProto.forEach || function(callback, thisArg) {
        var dict = parseToDict(this.toString());
        Object.getOwnPropertyNames(dict).forEach(function(name) {
          dict[name].forEach(function(value) {
            callback.call(thisArg, value, name, this);
          }, this);
        }, this);
      };
      USPProto.sort = USPProto.sort || function() {
        var dict = parseToDict(this.toString()), keys = [], k, i, j;
        for (k in dict) {
          keys.push(k);
        }
        keys.sort();
        for (i = 0; i < keys.length; i++) {
          this["delete"](keys[i]);
        }
        for (i = 0; i < keys.length; i++) {
          var key = keys[i], values = dict[key];
          for (j = 0; j < values.length; j++) {
            this.append(key, values[j]);
          }
        }
      };
      USPProto.keys = USPProto.keys || function() {
        var items = [];
        this.forEach(function(item, name) {
          items.push(name);
        });
        return makeIterator(items);
      };
      USPProto.values = USPProto.values || function() {
        var items = [];
        this.forEach(function(item) {
          items.push(item);
        });
        return makeIterator(items);
      };
      USPProto.entries = USPProto.entries || function() {
        var items = [];
        this.forEach(function(item, name) {
          items.push([name, item]);
        });
        return makeIterator(items);
      };
      if (iterable) {
        USPProto[self2.Symbol.iterator] = USPProto[self2.Symbol.iterator] || USPProto.entries;
      }
      function encode(str) {
        var replace = {
          "!": "%21",
          "'": "%27",
          "(": "%28",
          ")": "%29",
          "~": "%7E",
          "%20": "+",
          "%00": "\0"
        };
        return encodeURIComponent(str).replace(/[!'\(\)~]|%20|%00/g, function(match) {
          return replace[match];
        });
      }
      function decode(str) {
        return str.replace(/[ +]/g, "%20").replace(/(%[a-f0-9]{2})+/ig, function(match) {
          return decodeURIComponent(match);
        });
      }
      function makeIterator(arr) {
        var iterator = {
          next: function() {
            var value = arr.shift();
            return { done: value === void 0, value };
          }
        };
        if (iterable) {
          iterator[self2.Symbol.iterator] = function() {
            return iterator;
          };
        }
        return iterator;
      }
      function parseToDict(search) {
        var dict = {};
        if (typeof search === "object") {
          if (isArray(search)) {
            for (var i = 0; i < search.length; i++) {
              var item = search[i];
              if (isArray(item) && item.length === 2) {
                appendTo(dict, item[0], item[1]);
              } else {
                throw new TypeError("Failed to construct 'URLSearchParams': Sequence initializer must only contain pair elements");
              }
            }
          } else {
            for (var key in search) {
              if (search.hasOwnProperty(key)) {
                appendTo(dict, key, search[key]);
              }
            }
          }
        } else {
          if (search.indexOf("?") === 0) {
            search = search.slice(1);
          }
          var pairs = search.split("&");
          for (var j = 0; j < pairs.length; j++) {
            var value = pairs[j], index = value.indexOf("=");
            if (-1 < index) {
              appendTo(dict, decode(value.slice(0, index)), decode(value.slice(index + 1)));
            } else {
              if (value) {
                appendTo(dict, decode(value), "");
              }
            }
          }
        }
        return dict;
      }
      function appendTo(dict, name, value) {
        var val = typeof value === "string" ? value : value !== null && value !== void 0 && typeof value.toString === "function" ? value.toString() : JSON.stringify(value);
        if (hasOwnProperty(dict, name)) {
          dict[name].push(val);
        } else {
          dict[name] = [val];
        }
      }
      function isArray(val) {
        return !!val && "[object Array]" === Object.prototype.toString.call(val);
      }
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
    })(typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : exports);
  }
});

// node_modules/rxjs/util/root.js
var require_root = __commonJS({
  "node_modules/rxjs/util/root.js"(exports) {
    "use strict";
    var __window = typeof window !== "undefined" && window;
    var __self = typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && self;
    var __global = typeof global !== "undefined" && global;
    var _root = __window || __global || __self;
    exports.root = _root;
    (function() {
      if (!_root) {
        throw new Error("RxJS could not find any global context (window, self, global)");
      }
    })();
  }
});

// node_modules/rxjs/util/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/rxjs/util/isFunction.js"(exports) {
    "use strict";
    function isFunction(x) {
      return typeof x === "function";
    }
    exports.isFunction = isFunction;
  }
});

// node_modules/rxjs/util/isArray.js
var require_isArray = __commonJS({
  "node_modules/rxjs/util/isArray.js"(exports) {
    "use strict";
    exports.isArray = Array.isArray || function(x) {
      return x && typeof x.length === "number";
    };
  }
});

// node_modules/rxjs/util/isObject.js
var require_isObject = __commonJS({
  "node_modules/rxjs/util/isObject.js"(exports) {
    "use strict";
    function isObject(x) {
      return x != null && typeof x === "object";
    }
    exports.isObject = isObject;
  }
});

// node_modules/rxjs/util/errorObject.js
var require_errorObject = __commonJS({
  "node_modules/rxjs/util/errorObject.js"(exports) {
    "use strict";
    exports.errorObject = { e: {} };
  }
});

// node_modules/rxjs/util/tryCatch.js
var require_tryCatch = __commonJS({
  "node_modules/rxjs/util/tryCatch.js"(exports) {
    "use strict";
    var errorObject_1 = require_errorObject();
    var tryCatchTarget;
    function tryCatcher() {
      try {
        return tryCatchTarget.apply(this, arguments);
      } catch (e2) {
        errorObject_1.errorObject.e = e2;
        return errorObject_1.errorObject;
      }
    }
    function tryCatch(fn) {
      tryCatchTarget = fn;
      return tryCatcher;
    }
    exports.tryCatch = tryCatch;
  }
});

// node_modules/rxjs/util/UnsubscriptionError.js
var require_UnsubscriptionError = __commonJS({
  "node_modules/rxjs/util/UnsubscriptionError.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var UnsubscriptionError = function(_super) {
      __extends(UnsubscriptionError2, _super);
      function UnsubscriptionError2(errors) {
        _super.call(this);
        this.errors = errors;
        var err = Error.call(this, errors ? errors.length + " errors occurred during unsubscription:\n  " + errors.map(function(err2, i) {
          return i + 1 + ") " + err2.toString();
        }).join("\n  ") : "");
        this.name = err.name = "UnsubscriptionError";
        this.stack = err.stack;
        this.message = err.message;
      }
      return UnsubscriptionError2;
    }(Error);
    exports.UnsubscriptionError = UnsubscriptionError;
  }
});

// node_modules/rxjs/Subscription.js
var require_Subscription = __commonJS({
  "node_modules/rxjs/Subscription.js"(exports) {
    "use strict";
    var isArray_1 = require_isArray();
    var isObject_1 = require_isObject();
    var isFunction_1 = require_isFunction();
    var tryCatch_1 = require_tryCatch();
    var errorObject_1 = require_errorObject();
    var UnsubscriptionError_1 = require_UnsubscriptionError();
    var Subscription = function() {
      function Subscription2(unsubscribe) {
        this.closed = false;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        if (unsubscribe) {
          this._unsubscribe = unsubscribe;
        }
      }
      Subscription2.prototype.unsubscribe = function() {
        var hasErrors = false;
        var errors;
        if (this.closed) {
          return;
        }
        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        var index = -1;
        var len = _parents ? _parents.length : 0;
        while (_parent) {
          _parent.remove(this);
          _parent = ++index < len && _parents[index] || null;
        }
        if (isFunction_1.isFunction(_unsubscribe)) {
          var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
          if (trial === errorObject_1.errorObject) {
            hasErrors = true;
            errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ? flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
          }
        }
        if (isArray_1.isArray(_subscriptions)) {
          index = -1;
          len = _subscriptions.length;
          while (++index < len) {
            var sub = _subscriptions[index];
            if (isObject_1.isObject(sub)) {
              var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
              if (trial === errorObject_1.errorObject) {
                hasErrors = true;
                errors = errors || [];
                var err = errorObject_1.errorObject.e;
                if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                  errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                } else {
                  errors.push(err);
                }
              }
            }
          }
        }
        if (hasErrors) {
          throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
      };
      Subscription2.prototype.add = function(teardown) {
        if (!teardown || teardown === Subscription2.EMPTY) {
          return Subscription2.EMPTY;
        }
        if (teardown === this) {
          return this;
        }
        var subscription = teardown;
        switch (typeof teardown) {
          case "function":
            subscription = new Subscription2(teardown);
          case "object":
            if (subscription.closed || typeof subscription.unsubscribe !== "function") {
              return subscription;
            } else if (this.closed) {
              subscription.unsubscribe();
              return subscription;
            } else if (typeof subscription._addParent !== "function") {
              var tmp = subscription;
              subscription = new Subscription2();
              subscription._subscriptions = [tmp];
            }
            break;
          default:
            throw new Error("unrecognized teardown " + teardown + " added to Subscription.");
        }
        var subscriptions = this._subscriptions || (this._subscriptions = []);
        subscriptions.push(subscription);
        subscription._addParent(this);
        return subscription;
      };
      Subscription2.prototype.remove = function(subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
          var subscriptionIndex = subscriptions.indexOf(subscription);
          if (subscriptionIndex !== -1) {
            subscriptions.splice(subscriptionIndex, 1);
          }
        }
      };
      Subscription2.prototype._addParent = function(parent) {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        if (!_parent || _parent === parent) {
          this._parent = parent;
        } else if (!_parents) {
          this._parents = [parent];
        } else if (_parents.indexOf(parent) === -1) {
          _parents.push(parent);
        }
      };
      Subscription2.EMPTY = function(empty) {
        empty.closed = true;
        return empty;
      }(new Subscription2());
      return Subscription2;
    }();
    exports.Subscription = Subscription;
    function flattenUnsubscriptionErrors(errors) {
      return errors.reduce(function(errs, err) {
        return errs.concat(err instanceof UnsubscriptionError_1.UnsubscriptionError ? err.errors : err);
      }, []);
    }
  }
});

// node_modules/rxjs/Observer.js
var require_Observer = __commonJS({
  "node_modules/rxjs/Observer.js"(exports) {
    "use strict";
    exports.empty = {
      closed: true,
      next: function(value) {
      },
      error: function(err) {
        throw err;
      },
      complete: function() {
      }
    };
  }
});

// node_modules/rxjs/symbol/rxSubscriber.js
var require_rxSubscriber = __commonJS({
  "node_modules/rxjs/symbol/rxSubscriber.js"(exports) {
    "use strict";
    var root_1 = require_root();
    var Symbol2 = root_1.root.Symbol;
    exports.rxSubscriber = typeof Symbol2 === "function" && typeof Symbol2.for === "function" ? Symbol2.for("rxSubscriber") : "@@rxSubscriber";
    exports.$$rxSubscriber = exports.rxSubscriber;
  }
});

// node_modules/rxjs/Subscriber.js
var require_Subscriber = __commonJS({
  "node_modules/rxjs/Subscriber.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var isFunction_1 = require_isFunction();
    var Subscription_1 = require_Subscription();
    var Observer_1 = require_Observer();
    var rxSubscriber_1 = require_rxSubscriber();
    var Subscriber = function(_super) {
      __extends(Subscriber2, _super);
      function Subscriber2(destinationOrNext, error, complete) {
        _super.call(this);
        this.syncErrorValue = null;
        this.syncErrorThrown = false;
        this.syncErrorThrowable = false;
        this.isStopped = false;
        switch (arguments.length) {
          case 0:
            this.destination = Observer_1.empty;
            break;
          case 1:
            if (!destinationOrNext) {
              this.destination = Observer_1.empty;
              break;
            }
            if (typeof destinationOrNext === "object") {
              if (isTrustedSubscriber(destinationOrNext)) {
                var trustedSubscriber = destinationOrNext[rxSubscriber_1.rxSubscriber]();
                this.syncErrorThrowable = trustedSubscriber.syncErrorThrowable;
                this.destination = trustedSubscriber;
                trustedSubscriber.add(this);
              } else {
                this.syncErrorThrowable = true;
                this.destination = new SafeSubscriber(this, destinationOrNext);
              }
              break;
            }
          default:
            this.syncErrorThrowable = true;
            this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
            break;
        }
      }
      Subscriber2.prototype[rxSubscriber_1.rxSubscriber] = function() {
        return this;
      };
      Subscriber2.create = function(next, error, complete) {
        var subscriber = new Subscriber2(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
      };
      Subscriber2.prototype.next = function(value) {
        if (!this.isStopped) {
          this._next(value);
        }
      };
      Subscriber2.prototype.error = function(err) {
        if (!this.isStopped) {
          this.isStopped = true;
          this._error(err);
        }
      };
      Subscriber2.prototype.complete = function() {
        if (!this.isStopped) {
          this.isStopped = true;
          this._complete();
        }
      };
      Subscriber2.prototype.unsubscribe = function() {
        if (this.closed) {
          return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
      };
      Subscriber2.prototype._next = function(value) {
        this.destination.next(value);
      };
      Subscriber2.prototype._error = function(err) {
        this.destination.error(err);
        this.unsubscribe();
      };
      Subscriber2.prototype._complete = function() {
        this.destination.complete();
        this.unsubscribe();
      };
      Subscriber2.prototype._unsubscribeAndRecycle = function() {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        this._parent = null;
        this._parents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parent = _parent;
        this._parents = _parents;
        return this;
      };
      return Subscriber2;
    }(Subscription_1.Subscription);
    exports.Subscriber = Subscriber;
    var SafeSubscriber = function(_super) {
      __extends(SafeSubscriber2, _super);
      function SafeSubscriber2(_parentSubscriber, observerOrNext, error, complete) {
        _super.call(this);
        this._parentSubscriber = _parentSubscriber;
        var next;
        var context = this;
        if (isFunction_1.isFunction(observerOrNext)) {
          next = observerOrNext;
        } else if (observerOrNext) {
          next = observerOrNext.next;
          error = observerOrNext.error;
          complete = observerOrNext.complete;
          if (observerOrNext !== Observer_1.empty) {
            context = Object.create(observerOrNext);
            if (isFunction_1.isFunction(context.unsubscribe)) {
              this.add(context.unsubscribe.bind(context));
            }
            context.unsubscribe = this.unsubscribe.bind(this);
          }
        }
        this._context = context;
        this._next = next;
        this._error = error;
        this._complete = complete;
      }
      SafeSubscriber2.prototype.next = function(value) {
        if (!this.isStopped && this._next) {
          var _parentSubscriber = this._parentSubscriber;
          if (!_parentSubscriber.syncErrorThrowable) {
            this.__tryOrUnsub(this._next, value);
          } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
            this.unsubscribe();
          }
        }
      };
      SafeSubscriber2.prototype.error = function(err) {
        if (!this.isStopped) {
          var _parentSubscriber = this._parentSubscriber;
          if (this._error) {
            if (!_parentSubscriber.syncErrorThrowable) {
              this.__tryOrUnsub(this._error, err);
              this.unsubscribe();
            } else {
              this.__tryOrSetError(_parentSubscriber, this._error, err);
              this.unsubscribe();
            }
          } else if (!_parentSubscriber.syncErrorThrowable) {
            this.unsubscribe();
            throw err;
          } else {
            _parentSubscriber.syncErrorValue = err;
            _parentSubscriber.syncErrorThrown = true;
            this.unsubscribe();
          }
        }
      };
      SafeSubscriber2.prototype.complete = function() {
        var _this = this;
        if (!this.isStopped) {
          var _parentSubscriber = this._parentSubscriber;
          if (this._complete) {
            var wrappedComplete = function() {
              return _this._complete.call(_this._context);
            };
            if (!_parentSubscriber.syncErrorThrowable) {
              this.__tryOrUnsub(wrappedComplete);
              this.unsubscribe();
            } else {
              this.__tryOrSetError(_parentSubscriber, wrappedComplete);
              this.unsubscribe();
            }
          } else {
            this.unsubscribe();
          }
        }
      };
      SafeSubscriber2.prototype.__tryOrUnsub = function(fn, value) {
        try {
          fn.call(this._context, value);
        } catch (err) {
          this.unsubscribe();
          throw err;
        }
      };
      SafeSubscriber2.prototype.__tryOrSetError = function(parent, fn, value) {
        try {
          fn.call(this._context, value);
        } catch (err) {
          parent.syncErrorValue = err;
          parent.syncErrorThrown = true;
          return true;
        }
        return false;
      };
      SafeSubscriber2.prototype._unsubscribe = function() {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
      };
      return SafeSubscriber2;
    }(Subscriber);
    function isTrustedSubscriber(obj) {
      return obj instanceof Subscriber || "syncErrorThrowable" in obj && obj[rxSubscriber_1.rxSubscriber];
    }
  }
});

// node_modules/rxjs/util/toSubscriber.js
var require_toSubscriber = __commonJS({
  "node_modules/rxjs/util/toSubscriber.js"(exports) {
    "use strict";
    var Subscriber_1 = require_Subscriber();
    var rxSubscriber_1 = require_rxSubscriber();
    var Observer_1 = require_Observer();
    function toSubscriber(nextOrObserver, error, complete) {
      if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
          return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {
          return nextOrObserver[rxSubscriber_1.rxSubscriber]();
        }
      }
      if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber(Observer_1.empty);
      }
      return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
    }
    exports.toSubscriber = toSubscriber;
  }
});

// node_modules/rxjs/symbol/observable.js
var require_observable = __commonJS({
  "node_modules/rxjs/symbol/observable.js"(exports) {
    "use strict";
    var root_1 = require_root();
    function getSymbolObservable(context) {
      var $$observable;
      var Symbol2 = context.Symbol;
      if (typeof Symbol2 === "function") {
        if (Symbol2.observable) {
          $$observable = Symbol2.observable;
        } else {
          $$observable = Symbol2("observable");
          Symbol2.observable = $$observable;
        }
      } else {
        $$observable = "@@observable";
      }
      return $$observable;
    }
    exports.getSymbolObservable = getSymbolObservable;
    exports.observable = getSymbolObservable(root_1.root);
    exports.$$observable = exports.observable;
  }
});

// node_modules/rxjs/util/noop.js
var require_noop = __commonJS({
  "node_modules/rxjs/util/noop.js"(exports) {
    "use strict";
    function noop() {
    }
    exports.noop = noop;
  }
});

// node_modules/rxjs/util/pipe.js
var require_pipe = __commonJS({
  "node_modules/rxjs/util/pipe.js"(exports) {
    "use strict";
    var noop_1 = require_noop();
    function pipe() {
      var fns = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i - 0] = arguments[_i];
      }
      return pipeFromArray(fns);
    }
    exports.pipe = pipe;
    function pipeFromArray(fns) {
      if (!fns) {
        return noop_1.noop;
      }
      if (fns.length === 1) {
        return fns[0];
      }
      return function piped(input) {
        return fns.reduce(function(prev, fn) {
          return fn(prev);
        }, input);
      };
    }
    exports.pipeFromArray = pipeFromArray;
  }
});

// node_modules/rxjs/Observable.js
var require_Observable = __commonJS({
  "node_modules/rxjs/Observable.js"(exports) {
    "use strict";
    var root_1 = require_root();
    var toSubscriber_1 = require_toSubscriber();
    var observable_1 = require_observable();
    var pipe_1 = require_pipe();
    var Observable = function() {
      function Observable2(subscribe) {
        this._isScalar = false;
        if (subscribe) {
          this._subscribe = subscribe;
        }
      }
      Observable2.prototype.lift = function(operator) {
        var observable = new Observable2();
        observable.source = this;
        observable.operator = operator;
        return observable;
      };
      Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
          operator.call(sink, this.source);
        } else {
          sink.add(this.source || !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
        }
        if (sink.syncErrorThrowable) {
          sink.syncErrorThrowable = false;
          if (sink.syncErrorThrown) {
            throw sink.syncErrorValue;
          }
        }
        return sink;
      };
      Observable2.prototype._trySubscribe = function(sink) {
        try {
          return this._subscribe(sink);
        } catch (err) {
          sink.syncErrorThrown = true;
          sink.syncErrorValue = err;
          sink.error(err);
        }
      };
      Observable2.prototype.forEach = function(next, PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
          if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
            PromiseCtor = root_1.root.Rx.config.Promise;
          } else if (root_1.root.Promise) {
            PromiseCtor = root_1.root.Promise;
          }
        }
        if (!PromiseCtor) {
          throw new Error("no Promise impl found");
        }
        return new PromiseCtor(function(resolve, reject) {
          var subscription;
          subscription = _this.subscribe(function(value) {
            if (subscription) {
              try {
                next(value);
              } catch (err) {
                reject(err);
                subscription.unsubscribe();
              }
            } else {
              next(value);
            }
          }, reject, resolve);
        });
      };
      Observable2.prototype._subscribe = function(subscriber) {
        return this.source.subscribe(subscriber);
      };
      Observable2.prototype[observable_1.observable] = function() {
        return this;
      };
      Observable2.prototype.pipe = function() {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          operations[_i - 0] = arguments[_i];
        }
        if (operations.length === 0) {
          return this;
        }
        return pipe_1.pipeFromArray(operations)(this);
      };
      Observable2.prototype.toPromise = function(PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
          if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
            PromiseCtor = root_1.root.Rx.config.Promise;
          } else if (root_1.root.Promise) {
            PromiseCtor = root_1.root.Promise;
          }
        }
        if (!PromiseCtor) {
          throw new Error("no Promise impl found");
        }
        return new PromiseCtor(function(resolve, reject) {
          var value;
          _this.subscribe(function(x) {
            return value = x;
          }, function(err) {
            return reject(err);
          }, function() {
            return resolve(value);
          });
        });
      };
      Observable2.create = function(subscribe) {
        return new Observable2(subscribe);
      };
      return Observable2;
    }();
    exports.Observable = Observable;
  }
});

// node_modules/rxjs/util/ObjectUnsubscribedError.js
var require_ObjectUnsubscribedError = __commonJS({
  "node_modules/rxjs/util/ObjectUnsubscribedError.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var ObjectUnsubscribedError = function(_super) {
      __extends(ObjectUnsubscribedError2, _super);
      function ObjectUnsubscribedError2() {
        var err = _super.call(this, "object unsubscribed");
        this.name = err.name = "ObjectUnsubscribedError";
        this.stack = err.stack;
        this.message = err.message;
      }
      return ObjectUnsubscribedError2;
    }(Error);
    exports.ObjectUnsubscribedError = ObjectUnsubscribedError;
  }
});

// node_modules/rxjs/SubjectSubscription.js
var require_SubjectSubscription = __commonJS({
  "node_modules/rxjs/SubjectSubscription.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var Subscription_1 = require_Subscription();
    var SubjectSubscription = function(_super) {
      __extends(SubjectSubscription2, _super);
      function SubjectSubscription2(subject, subscriber) {
        _super.call(this);
        this.subject = subject;
        this.subscriber = subscriber;
        this.closed = false;
      }
      SubjectSubscription2.prototype.unsubscribe = function() {
        if (this.closed) {
          return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
          return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
          observers.splice(subscriberIndex, 1);
        }
      };
      return SubjectSubscription2;
    }(Subscription_1.Subscription);
    exports.SubjectSubscription = SubjectSubscription;
  }
});

// node_modules/rxjs/Subject.js
var require_Subject = __commonJS({
  "node_modules/rxjs/Subject.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var Observable_1 = require_Observable();
    var Subscriber_1 = require_Subscriber();
    var Subscription_1 = require_Subscription();
    var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
    var SubjectSubscription_1 = require_SubjectSubscription();
    var rxSubscriber_1 = require_rxSubscriber();
    var SubjectSubscriber = function(_super) {
      __extends(SubjectSubscriber2, _super);
      function SubjectSubscriber2(destination) {
        _super.call(this, destination);
        this.destination = destination;
      }
      return SubjectSubscriber2;
    }(Subscriber_1.Subscriber);
    exports.SubjectSubscriber = SubjectSubscriber;
    var Subject = function(_super) {
      __extends(Subject2, _super);
      function Subject2() {
        _super.call(this);
        this.observers = [];
        this.closed = false;
        this.isStopped = false;
        this.hasError = false;
        this.thrownError = null;
      }
      Subject2.prototype[rxSubscriber_1.rxSubscriber] = function() {
        return new SubjectSubscriber(this);
      };
      Subject2.prototype.lift = function(operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
      };
      Subject2.prototype.next = function(value) {
        if (this.closed) {
          throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
          var observers = this.observers;
          var len = observers.length;
          var copy = observers.slice();
          for (var i = 0; i < len; i++) {
            copy[i].next(value);
          }
        }
      };
      Subject2.prototype.error = function(err) {
        if (this.closed) {
          throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
          copy[i].error(err);
        }
        this.observers.length = 0;
      };
      Subject2.prototype.complete = function() {
        if (this.closed) {
          throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
          copy[i].complete();
        }
        this.observers.length = 0;
      };
      Subject2.prototype.unsubscribe = function() {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
      };
      Subject2.prototype._trySubscribe = function(subscriber) {
        if (this.closed) {
          throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        } else {
          return _super.prototype._trySubscribe.call(this, subscriber);
        }
      };
      Subject2.prototype._subscribe = function(subscriber) {
        if (this.closed) {
          throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        } else if (this.hasError) {
          subscriber.error(this.thrownError);
          return Subscription_1.Subscription.EMPTY;
        } else if (this.isStopped) {
          subscriber.complete();
          return Subscription_1.Subscription.EMPTY;
        } else {
          this.observers.push(subscriber);
          return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
      };
      Subject2.prototype.asObservable = function() {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
      };
      Subject2.create = function(destination, source) {
        return new AnonymousSubject(destination, source);
      };
      return Subject2;
    }(Observable_1.Observable);
    exports.Subject = Subject;
    var AnonymousSubject = function(_super) {
      __extends(AnonymousSubject2, _super);
      function AnonymousSubject2(destination, source) {
        _super.call(this);
        this.destination = destination;
        this.source = source;
      }
      AnonymousSubject2.prototype.next = function(value) {
        var destination = this.destination;
        if (destination && destination.next) {
          destination.next(value);
        }
      };
      AnonymousSubject2.prototype.error = function(err) {
        var destination = this.destination;
        if (destination && destination.error) {
          this.destination.error(err);
        }
      };
      AnonymousSubject2.prototype.complete = function() {
        var destination = this.destination;
        if (destination && destination.complete) {
          this.destination.complete();
        }
      };
      AnonymousSubject2.prototype._subscribe = function(subscriber) {
        var source = this.source;
        if (source) {
          return this.source.subscribe(subscriber);
        } else {
          return Subscription_1.Subscription.EMPTY;
        }
      };
      return AnonymousSubject2;
    }(Subject);
    exports.AnonymousSubject = AnonymousSubject;
  }
});

// node_modules/rxjs/BehaviorSubject.js
var require_BehaviorSubject = __commonJS({
  "node_modules/rxjs/BehaviorSubject.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var Subject_1 = require_Subject();
    var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
    var BehaviorSubject = function(_super) {
      __extends(BehaviorSubject2, _super);
      function BehaviorSubject2(_value) {
        _super.call(this);
        this._value = _value;
      }
      Object.defineProperty(BehaviorSubject2.prototype, "value", {
        get: function() {
          return this.getValue();
        },
        enumerable: true,
        configurable: true
      });
      BehaviorSubject2.prototype._subscribe = function(subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
          subscriber.next(this._value);
        }
        return subscription;
      };
      BehaviorSubject2.prototype.getValue = function() {
        if (this.hasError) {
          throw this.thrownError;
        } else if (this.closed) {
          throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        } else {
          return this._value;
        }
      };
      BehaviorSubject2.prototype.next = function(value) {
        _super.prototype.next.call(this, this._value = value);
      };
      return BehaviorSubject2;
    }(Subject_1.Subject);
    exports.BehaviorSubject = BehaviorSubject;
  }
});

// node_modules/rxjs/scheduler/Action.js
var require_Action = __commonJS({
  "node_modules/rxjs/scheduler/Action.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var Subscription_1 = require_Subscription();
    var Action = function(_super) {
      __extends(Action2, _super);
      function Action2(scheduler, work) {
        _super.call(this);
      }
      Action2.prototype.schedule = function(state, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        return this;
      };
      return Action2;
    }(Subscription_1.Subscription);
    exports.Action = Action;
  }
});

// node_modules/rxjs/scheduler/AsyncAction.js
var require_AsyncAction = __commonJS({
  "node_modules/rxjs/scheduler/AsyncAction.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var root_1 = require_root();
    var Action_1 = require_Action();
    var AsyncAction = function(_super) {
      __extends(AsyncAction2, _super);
      function AsyncAction2(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.pending = false;
        this.work = work;
      }
      AsyncAction2.prototype.schedule = function(state, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (this.closed) {
          return this;
        }
        this.state = state;
        this.pending = true;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.delay = delay;
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
      };
      AsyncAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);
      };
      AsyncAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (delay !== null && this.delay === delay && this.pending === false) {
          return id;
        }
        return root_1.root.clearInterval(id) && void 0 || void 0;
      };
      AsyncAction2.prototype.execute = function(state, delay) {
        if (this.closed) {
          return new Error("executing a cancelled action");
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
          return error;
        } else if (this.pending === false && this.id != null) {
          this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
      };
      AsyncAction2.prototype._execute = function(state, delay) {
        var errored = false;
        var errorValue = void 0;
        try {
          this.work(state);
        } catch (e2) {
          errored = true;
          errorValue = !!e2 && e2 || new Error(e2);
        }
        if (errored) {
          this.unsubscribe();
          return errorValue;
        }
      };
      AsyncAction2.prototype._unsubscribe = function() {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
          actions.splice(index, 1);
        }
        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
      };
      return AsyncAction2;
    }(Action_1.Action);
    exports.AsyncAction = AsyncAction;
  }
});

// node_modules/rxjs/Scheduler.js
var require_Scheduler = __commonJS({
  "node_modules/rxjs/Scheduler.js"(exports) {
    "use strict";
    var Scheduler = function() {
      function Scheduler2(SchedulerAction, now) {
        if (now === void 0) {
          now = Scheduler2.now;
        }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
      }
      Scheduler2.prototype.schedule = function(work, delay, state) {
        if (delay === void 0) {
          delay = 0;
        }
        return new this.SchedulerAction(this, work).schedule(state, delay);
      };
      Scheduler2.now = Date.now ? Date.now : function() {
        return +new Date();
      };
      return Scheduler2;
    }();
    exports.Scheduler = Scheduler;
  }
});

// node_modules/rxjs/scheduler/AsyncScheduler.js
var require_AsyncScheduler = __commonJS({
  "node_modules/rxjs/scheduler/AsyncScheduler.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var Scheduler_1 = require_Scheduler();
    var AsyncScheduler = function(_super) {
      __extends(AsyncScheduler2, _super);
      function AsyncScheduler2() {
        _super.apply(this, arguments);
        this.actions = [];
        this.active = false;
        this.scheduled = void 0;
      }
      AsyncScheduler2.prototype.flush = function(action) {
        var actions = this.actions;
        if (this.active) {
          actions.push(action);
          return;
        }
        var error;
        this.active = true;
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while (action = actions.shift());
        this.active = false;
        if (error) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AsyncScheduler2;
    }(Scheduler_1.Scheduler);
    exports.AsyncScheduler = AsyncScheduler;
  }
});

// node_modules/rxjs/scheduler/async.js
var require_async = __commonJS({
  "node_modules/rxjs/scheduler/async.js"(exports) {
    "use strict";
    var AsyncAction_1 = require_AsyncAction();
    var AsyncScheduler_1 = require_AsyncScheduler();
    exports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
  }
});

// node_modules/jwt-decode/build/jwt-decode.esm.js
var jwt_decode_esm_exports = {};
__export(jwt_decode_esm_exports, {
  InvalidTokenError: () => n,
  default: () => jwt_decode_esm_default
});
function e(e2) {
  this.message = e2;
}
function t(e2) {
  var t2 = e2.replace(/-/g, "+").replace(/_/g, "/");
  switch (t2.length % 4) {
    case 0:
      break;
    case 2:
      t2 += "==";
      break;
    case 3:
      t2 += "=";
      break;
    default:
      throw "Illegal base64url string!";
  }
  try {
    return function(e3) {
      return decodeURIComponent(r(e3).replace(/(.)/g, function(e4, r2) {
        var t3 = r2.charCodeAt(0).toString(16).toUpperCase();
        return t3.length < 2 && (t3 = "0" + t3), "%" + t3;
      }));
    }(t2);
  } catch (e3) {
    return r(t2);
  }
}
function n(e2) {
  this.message = e2;
}
function o(e2, r2) {
  if ("string" != typeof e2)
    throw new n("Invalid token specified");
  var o2 = true === (r2 = r2 || {}).header ? 0 : 1;
  try {
    return JSON.parse(t(e2.split(".")[o2]));
  } catch (e3) {
    throw new n("Invalid token specified: " + e3.message);
  }
}
var r, jwt_decode_esm_default;
var init_jwt_decode_esm = __esm({
  "node_modules/jwt-decode/build/jwt-decode.esm.js"() {
    e.prototype = new Error(), e.prototype.name = "InvalidCharacterError";
    r = "undefined" != typeof window && window.atob && window.atob.bind(window) || function(r2) {
      var t2 = String(r2).replace(/=+$/, "");
      if (t2.length % 4 == 1)
        throw new e("'atob' failed: The string to be decoded is not correctly encoded.");
      for (var n2, o2, a = 0, i = 0, c = ""; o2 = t2.charAt(i++); ~o2 && (n2 = a % 4 ? 64 * n2 + o2 : o2, a++ % 4) ? c += String.fromCharCode(255 & n2 >> (-2 * a & 6)) : 0)
        o2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(o2);
      return c;
    };
    n.prototype = new Error(), n.prototype.name = "InvalidTokenError";
    jwt_decode_esm_default = o;
  }
});

// node_modules/rxjs/OuterSubscriber.js
var require_OuterSubscriber = __commonJS({
  "node_modules/rxjs/OuterSubscriber.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var Subscriber_1 = require_Subscriber();
    var OuterSubscriber = function(_super) {
      __extends(OuterSubscriber2, _super);
      function OuterSubscriber2() {
        _super.apply(this, arguments);
      }
      OuterSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
      };
      OuterSubscriber2.prototype.notifyError = function(error, innerSub) {
        this.destination.error(error);
      };
      OuterSubscriber2.prototype.notifyComplete = function(innerSub) {
        this.destination.complete();
      };
      return OuterSubscriber2;
    }(Subscriber_1.Subscriber);
    exports.OuterSubscriber = OuterSubscriber;
  }
});

// node_modules/rxjs/util/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/rxjs/util/isArrayLike.js"(exports) {
    "use strict";
    exports.isArrayLike = function(x) {
      return x && typeof x.length === "number";
    };
  }
});

// node_modules/rxjs/util/isPromise.js
var require_isPromise = __commonJS({
  "node_modules/rxjs/util/isPromise.js"(exports) {
    "use strict";
    function isPromise(value) {
      return value && typeof value.subscribe !== "function" && typeof value.then === "function";
    }
    exports.isPromise = isPromise;
  }
});

// node_modules/rxjs/symbol/iterator.js
var require_iterator = __commonJS({
  "node_modules/rxjs/symbol/iterator.js"(exports) {
    "use strict";
    var root_1 = require_root();
    function symbolIteratorPonyfill(root) {
      var Symbol2 = root.Symbol;
      if (typeof Symbol2 === "function") {
        if (!Symbol2.iterator) {
          Symbol2.iterator = Symbol2("iterator polyfill");
        }
        return Symbol2.iterator;
      } else {
        var Set_1 = root.Set;
        if (Set_1 && typeof new Set_1()["@@iterator"] === "function") {
          return "@@iterator";
        }
        var Map_1 = root.Map;
        if (Map_1) {
          var keys = Object.getOwnPropertyNames(Map_1.prototype);
          for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (key !== "entries" && key !== "size" && Map_1.prototype[key] === Map_1.prototype["entries"]) {
              return key;
            }
          }
        }
        return "@@iterator";
      }
    }
    exports.symbolIteratorPonyfill = symbolIteratorPonyfill;
    exports.iterator = symbolIteratorPonyfill(root_1.root);
    exports.$$iterator = exports.iterator;
  }
});

// node_modules/rxjs/InnerSubscriber.js
var require_InnerSubscriber = __commonJS({
  "node_modules/rxjs/InnerSubscriber.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var Subscriber_1 = require_Subscriber();
    var InnerSubscriber = function(_super) {
      __extends(InnerSubscriber2, _super);
      function InnerSubscriber2(parent, outerValue, outerIndex) {
        _super.call(this);
        this.parent = parent;
        this.outerValue = outerValue;
        this.outerIndex = outerIndex;
        this.index = 0;
      }
      InnerSubscriber2.prototype._next = function(value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
      };
      InnerSubscriber2.prototype._error = function(error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
      };
      InnerSubscriber2.prototype._complete = function() {
        this.parent.notifyComplete(this);
        this.unsubscribe();
      };
      return InnerSubscriber2;
    }(Subscriber_1.Subscriber);
    exports.InnerSubscriber = InnerSubscriber;
  }
});

// node_modules/rxjs/util/subscribeToResult.js
var require_subscribeToResult = __commonJS({
  "node_modules/rxjs/util/subscribeToResult.js"(exports) {
    "use strict";
    var root_1 = require_root();
    var isArrayLike_1 = require_isArrayLike();
    var isPromise_1 = require_isPromise();
    var isObject_1 = require_isObject();
    var Observable_1 = require_Observable();
    var iterator_1 = require_iterator();
    var InnerSubscriber_1 = require_InnerSubscriber();
    var observable_1 = require_observable();
    function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
      var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
      if (destination.closed) {
        return null;
      }
      if (result instanceof Observable_1.Observable) {
        if (result._isScalar) {
          destination.next(result.value);
          destination.complete();
          return null;
        } else {
          destination.syncErrorThrowable = true;
          return result.subscribe(destination);
        }
      } else if (isArrayLike_1.isArrayLike(result)) {
        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {
          destination.next(result[i]);
        }
        if (!destination.closed) {
          destination.complete();
        }
      } else if (isPromise_1.isPromise(result)) {
        result.then(function(value2) {
          if (!destination.closed) {
            destination.next(value2);
            destination.complete();
          }
        }, function(err) {
          return destination.error(err);
        }).then(null, function(err) {
          root_1.root.setTimeout(function() {
            throw err;
          });
        });
        return destination;
      } else if (result && typeof result[iterator_1.iterator] === "function") {
        var iterator = result[iterator_1.iterator]();
        do {
          var item = iterator.next();
          if (item.done) {
            destination.complete();
            break;
          }
          destination.next(item.value);
          if (destination.closed) {
            break;
          }
        } while (true);
      } else if (result && typeof result[observable_1.observable] === "function") {
        var obs = result[observable_1.observable]();
        if (typeof obs.subscribe !== "function") {
          destination.error(new TypeError("Provided object does not correctly implement Symbol.observable"));
        } else {
          return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));
        }
      } else {
        var value = isObject_1.isObject(result) ? "an invalid object" : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.";
        destination.error(new TypeError(msg));
      }
      return null;
    }
    exports.subscribeToResult = subscribeToResult;
  }
});

// node_modules/rxjs/operators/catchError.js
var require_catchError = __commonJS({
  "node_modules/rxjs/operators/catchError.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var OuterSubscriber_1 = require_OuterSubscriber();
    var subscribeToResult_1 = require_subscribeToResult();
    function catchError(selector) {
      return function catchErrorOperatorFunction(source) {
        var operator = new CatchOperator(selector);
        var caught = source.lift(operator);
        return operator.caught = caught;
      };
    }
    exports.catchError = catchError;
    var CatchOperator = function() {
      function CatchOperator2(selector) {
        this.selector = selector;
      }
      CatchOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
      };
      return CatchOperator2;
    }();
    var CatchSubscriber = function(_super) {
      __extends(CatchSubscriber2, _super);
      function CatchSubscriber2(destination, selector, caught) {
        _super.call(this, destination);
        this.selector = selector;
        this.caught = caught;
      }
      CatchSubscriber2.prototype.error = function(err) {
        if (!this.isStopped) {
          var result = void 0;
          try {
            result = this.selector(err, this.caught);
          } catch (err2) {
            _super.prototype.error.call(this, err2);
            return;
          }
          this._unsubscribeAndRecycle();
          this.add(subscribeToResult_1.subscribeToResult(this, result));
        }
      };
      return CatchSubscriber2;
    }(OuterSubscriber_1.OuterSubscriber);
  }
});

// node_modules/rxjs/operator/catch.js
var require_catch = __commonJS({
  "node_modules/rxjs/operator/catch.js"(exports) {
    "use strict";
    var catchError_1 = require_catchError();
    function _catch(selector) {
      return catchError_1.catchError(selector)(this);
    }
    exports._catch = _catch;
  }
});

// node_modules/rxjs/add/operator/catch.js
var require_catch2 = __commonJS({
  "node_modules/rxjs/add/operator/catch.js"() {
    "use strict";
    var Observable_1 = require_Observable();
    var catch_1 = require_catch();
    Observable_1.Observable.prototype.catch = catch_1._catch;
    Observable_1.Observable.prototype._catch = catch_1._catch;
  }
});

// node_modules/rxjs/observable/ScalarObservable.js
var require_ScalarObservable = __commonJS({
  "node_modules/rxjs/observable/ScalarObservable.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var Observable_1 = require_Observable();
    var ScalarObservable = function(_super) {
      __extends(ScalarObservable2, _super);
      function ScalarObservable2(value, scheduler) {
        _super.call(this);
        this.value = value;
        this.scheduler = scheduler;
        this._isScalar = true;
        if (scheduler) {
          this._isScalar = false;
        }
      }
      ScalarObservable2.create = function(value, scheduler) {
        return new ScalarObservable2(value, scheduler);
      };
      ScalarObservable2.dispatch = function(state) {
        var done = state.done, value = state.value, subscriber = state.subscriber;
        if (done) {
          subscriber.complete();
          return;
        }
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
        state.done = true;
        this.schedule(state);
      };
      ScalarObservable2.prototype._subscribe = function(subscriber) {
        var value = this.value;
        var scheduler = this.scheduler;
        if (scheduler) {
          return scheduler.schedule(ScalarObservable2.dispatch, 0, {
            done: false,
            value,
            subscriber
          });
        } else {
          subscriber.next(value);
          if (!subscriber.closed) {
            subscriber.complete();
          }
        }
      };
      return ScalarObservable2;
    }(Observable_1.Observable);
    exports.ScalarObservable = ScalarObservable;
  }
});

// node_modules/rxjs/observable/EmptyObservable.js
var require_EmptyObservable = __commonJS({
  "node_modules/rxjs/observable/EmptyObservable.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var Observable_1 = require_Observable();
    var EmptyObservable = function(_super) {
      __extends(EmptyObservable2, _super);
      function EmptyObservable2(scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
      }
      EmptyObservable2.create = function(scheduler) {
        return new EmptyObservable2(scheduler);
      };
      EmptyObservable2.dispatch = function(arg) {
        var subscriber = arg.subscriber;
        subscriber.complete();
      };
      EmptyObservable2.prototype._subscribe = function(subscriber) {
        var scheduler = this.scheduler;
        if (scheduler) {
          return scheduler.schedule(EmptyObservable2.dispatch, 0, { subscriber });
        } else {
          subscriber.complete();
        }
      };
      return EmptyObservable2;
    }(Observable_1.Observable);
    exports.EmptyObservable = EmptyObservable;
  }
});

// node_modules/rxjs/util/isScheduler.js
var require_isScheduler = __commonJS({
  "node_modules/rxjs/util/isScheduler.js"(exports) {
    "use strict";
    function isScheduler(value) {
      return value && typeof value.schedule === "function";
    }
    exports.isScheduler = isScheduler;
  }
});

// node_modules/rxjs/observable/ArrayObservable.js
var require_ArrayObservable = __commonJS({
  "node_modules/rxjs/observable/ArrayObservable.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var Observable_1 = require_Observable();
    var ScalarObservable_1 = require_ScalarObservable();
    var EmptyObservable_1 = require_EmptyObservable();
    var isScheduler_1 = require_isScheduler();
    var ArrayObservable = function(_super) {
      __extends(ArrayObservable2, _super);
      function ArrayObservable2(array, scheduler) {
        _super.call(this);
        this.array = array;
        this.scheduler = scheduler;
        if (!scheduler && array.length === 1) {
          this._isScalar = true;
          this.value = array[0];
        }
      }
      ArrayObservable2.create = function(array, scheduler) {
        return new ArrayObservable2(array, scheduler);
      };
      ArrayObservable2.of = function() {
        var array = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          array[_i - 0] = arguments[_i];
        }
        var scheduler = array[array.length - 1];
        if (isScheduler_1.isScheduler(scheduler)) {
          array.pop();
        } else {
          scheduler = null;
        }
        var len = array.length;
        if (len > 1) {
          return new ArrayObservable2(array, scheduler);
        } else if (len === 1) {
          return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
        } else {
          return new EmptyObservable_1.EmptyObservable(scheduler);
        }
      };
      ArrayObservable2.dispatch = function(state) {
        var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;
        if (index >= count) {
          subscriber.complete();
          return;
        }
        subscriber.next(array[index]);
        if (subscriber.closed) {
          return;
        }
        state.index = index + 1;
        this.schedule(state);
      };
      ArrayObservable2.prototype._subscribe = function(subscriber) {
        var index = 0;
        var array = this.array;
        var count = array.length;
        var scheduler = this.scheduler;
        if (scheduler) {
          return scheduler.schedule(ArrayObservable2.dispatch, 0, {
            array,
            index,
            count,
            subscriber
          });
        } else {
          for (var i = 0; i < count && !subscriber.closed; i++) {
            subscriber.next(array[i]);
          }
          subscriber.complete();
        }
      };
      return ArrayObservable2;
    }(Observable_1.Observable);
    exports.ArrayObservable = ArrayObservable;
  }
});

// node_modules/rxjs/operators/combineLatest.js
var require_combineLatest = __commonJS({
  "node_modules/rxjs/operators/combineLatest.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var ArrayObservable_1 = require_ArrayObservable();
    var isArray_1 = require_isArray();
    var OuterSubscriber_1 = require_OuterSubscriber();
    var subscribeToResult_1 = require_subscribeToResult();
    var none = {};
    function combineLatest() {
      var observables = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
      }
      var project = null;
      if (typeof observables[observables.length - 1] === "function") {
        project = observables.pop();
      }
      if (observables.length === 1 && isArray_1.isArray(observables[0])) {
        observables = observables[0].slice();
      }
      return function(source) {
        return source.lift.call(new ArrayObservable_1.ArrayObservable([source].concat(observables)), new CombineLatestOperator(project));
      };
    }
    exports.combineLatest = combineLatest;
    var CombineLatestOperator = function() {
      function CombineLatestOperator2(project) {
        this.project = project;
      }
      CombineLatestOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.project));
      };
      return CombineLatestOperator2;
    }();
    exports.CombineLatestOperator = CombineLatestOperator;
    var CombineLatestSubscriber = function(_super) {
      __extends(CombineLatestSubscriber2, _super);
      function CombineLatestSubscriber2(destination, project) {
        _super.call(this, destination);
        this.project = project;
        this.active = 0;
        this.values = [];
        this.observables = [];
      }
      CombineLatestSubscriber2.prototype._next = function(observable) {
        this.values.push(none);
        this.observables.push(observable);
      };
      CombineLatestSubscriber2.prototype._complete = function() {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
          this.destination.complete();
        } else {
          this.active = len;
          this.toRespond = len;
          for (var i = 0; i < len; i++) {
            var observable = observables[i];
            this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
          }
        }
      };
      CombineLatestSubscriber2.prototype.notifyComplete = function(unused) {
        if ((this.active -= 1) === 0) {
          this.destination.complete();
        }
      };
      CombineLatestSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond ? 0 : oldVal === none ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
          if (this.project) {
            this._tryProject(values);
          } else {
            this.destination.next(values.slice());
          }
        }
      };
      CombineLatestSubscriber2.prototype._tryProject = function(values) {
        var result;
        try {
          result = this.project.apply(this, values);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.destination.next(result);
      };
      return CombineLatestSubscriber2;
    }(OuterSubscriber_1.OuterSubscriber);
    exports.CombineLatestSubscriber = CombineLatestSubscriber;
  }
});

// node_modules/rxjs/operator/combineLatest.js
var require_combineLatest2 = __commonJS({
  "node_modules/rxjs/operator/combineLatest.js"(exports) {
    "use strict";
    var combineLatest_1 = require_combineLatest();
    function combineLatest() {
      var observables = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
      }
      return combineLatest_1.combineLatest.apply(void 0, observables)(this);
    }
    exports.combineLatest = combineLatest;
  }
});

// node_modules/rxjs/add/operator/combineLatest.js
var require_combineLatest3 = __commonJS({
  "node_modules/rxjs/add/operator/combineLatest.js"() {
    "use strict";
    var Observable_1 = require_Observable();
    var combineLatest_1 = require_combineLatest2();
    Observable_1.Observable.prototype.combineLatest = combineLatest_1.combineLatest;
  }
});

// node_modules/rxjs/operators/count.js
var require_count = __commonJS({
  "node_modules/rxjs/operators/count.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var Subscriber_1 = require_Subscriber();
    function count(predicate) {
      return function(source) {
        return source.lift(new CountOperator(predicate, source));
      };
    }
    exports.count = count;
    var CountOperator = function() {
      function CountOperator2(predicate, source) {
        this.predicate = predicate;
        this.source = source;
      }
      CountOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
      };
      return CountOperator2;
    }();
    var CountSubscriber = function(_super) {
      __extends(CountSubscriber2, _super);
      function CountSubscriber2(destination, predicate, source) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.source = source;
        this.count = 0;
        this.index = 0;
      }
      CountSubscriber2.prototype._next = function(value) {
        if (this.predicate) {
          this._tryPredicate(value);
        } else {
          this.count++;
        }
      };
      CountSubscriber2.prototype._tryPredicate = function(value) {
        var result;
        try {
          result = this.predicate(value, this.index++, this.source);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        if (result) {
          this.count++;
        }
      };
      CountSubscriber2.prototype._complete = function() {
        this.destination.next(this.count);
        this.destination.complete();
      };
      return CountSubscriber2;
    }(Subscriber_1.Subscriber);
  }
});

// node_modules/rxjs/operator/count.js
var require_count2 = __commonJS({
  "node_modules/rxjs/operator/count.js"(exports) {
    "use strict";
    var count_1 = require_count();
    function count(predicate) {
      return count_1.count(predicate)(this);
    }
    exports.count = count;
  }
});

// node_modules/rxjs/add/operator/count.js
var require_count3 = __commonJS({
  "node_modules/rxjs/add/operator/count.js"() {
    "use strict";
    var Observable_1 = require_Observable();
    var count_1 = require_count2();
    Observable_1.Observable.prototype.count = count_1.count;
  }
});

// node_modules/rxjs/util/isDate.js
var require_isDate = __commonJS({
  "node_modules/rxjs/util/isDate.js"(exports) {
    "use strict";
    function isDate(value) {
      return value instanceof Date && !isNaN(+value);
    }
    exports.isDate = isDate;
  }
});

// node_modules/rxjs/Notification.js
var require_Notification = __commonJS({
  "node_modules/rxjs/Notification.js"(exports) {
    "use strict";
    var Observable_1 = require_Observable();
    var Notification = function() {
      function Notification2(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === "N";
      }
      Notification2.prototype.observe = function(observer) {
        switch (this.kind) {
          case "N":
            return observer.next && observer.next(this.value);
          case "E":
            return observer.error && observer.error(this.error);
          case "C":
            return observer.complete && observer.complete();
        }
      };
      Notification2.prototype.do = function(next, error, complete) {
        var kind = this.kind;
        switch (kind) {
          case "N":
            return next && next(this.value);
          case "E":
            return error && error(this.error);
          case "C":
            return complete && complete();
        }
      };
      Notification2.prototype.accept = function(nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === "function") {
          return this.observe(nextOrObserver);
        } else {
          return this.do(nextOrObserver, error, complete);
        }
      };
      Notification2.prototype.toObservable = function() {
        var kind = this.kind;
        switch (kind) {
          case "N":
            return Observable_1.Observable.of(this.value);
          case "E":
            return Observable_1.Observable.throw(this.error);
          case "C":
            return Observable_1.Observable.empty();
        }
        throw new Error("unexpected notification kind value");
      };
      Notification2.createNext = function(value) {
        if (typeof value !== "undefined") {
          return new Notification2("N", value);
        }
        return Notification2.undefinedValueNotification;
      };
      Notification2.createError = function(err) {
        return new Notification2("E", void 0, err);
      };
      Notification2.createComplete = function() {
        return Notification2.completeNotification;
      };
      Notification2.completeNotification = new Notification2("C");
      Notification2.undefinedValueNotification = new Notification2("N", void 0);
      return Notification2;
    }();
    exports.Notification = Notification;
  }
});

// node_modules/rxjs/operators/delay.js
var require_delay = __commonJS({
  "node_modules/rxjs/operators/delay.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var async_1 = require_async();
    var isDate_1 = require_isDate();
    var Subscriber_1 = require_Subscriber();
    var Notification_1 = require_Notification();
    function delay(delay2, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.async;
      }
      var absoluteDelay = isDate_1.isDate(delay2);
      var delayFor = absoluteDelay ? +delay2 - scheduler.now() : Math.abs(delay2);
      return function(source) {
        return source.lift(new DelayOperator(delayFor, scheduler));
      };
    }
    exports.delay = delay;
    var DelayOperator = function() {
      function DelayOperator2(delay2, scheduler) {
        this.delay = delay2;
        this.scheduler = scheduler;
      }
      DelayOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
      };
      return DelayOperator2;
    }();
    var DelaySubscriber = function(_super) {
      __extends(DelaySubscriber2, _super);
      function DelaySubscriber2(destination, delay2, scheduler) {
        _super.call(this, destination);
        this.delay = delay2;
        this.scheduler = scheduler;
        this.queue = [];
        this.active = false;
        this.errored = false;
      }
      DelaySubscriber2.dispatch = function(state) {
        var source = state.source;
        var queue = source.queue;
        var scheduler = state.scheduler;
        var destination = state.destination;
        while (queue.length > 0 && queue[0].time - scheduler.now() <= 0) {
          queue.shift().notification.observe(destination);
        }
        if (queue.length > 0) {
          var delay_1 = Math.max(0, queue[0].time - scheduler.now());
          this.schedule(state, delay_1);
        } else {
          this.unsubscribe();
          source.active = false;
        }
      };
      DelaySubscriber2.prototype._schedule = function(scheduler) {
        this.active = true;
        this.add(scheduler.schedule(DelaySubscriber2.dispatch, this.delay, {
          source: this,
          destination: this.destination,
          scheduler
        }));
      };
      DelaySubscriber2.prototype.scheduleNotification = function(notification) {
        if (this.errored === true) {
          return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
          this._schedule(scheduler);
        }
      };
      DelaySubscriber2.prototype._next = function(value) {
        this.scheduleNotification(Notification_1.Notification.createNext(value));
      };
      DelaySubscriber2.prototype._error = function(err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
      };
      DelaySubscriber2.prototype._complete = function() {
        this.scheduleNotification(Notification_1.Notification.createComplete());
      };
      return DelaySubscriber2;
    }(Subscriber_1.Subscriber);
    var DelayMessage = function() {
      function DelayMessage2(time, notification) {
        this.time = time;
        this.notification = notification;
      }
      return DelayMessage2;
    }();
  }
});

// node_modules/rxjs/operator/delay.js
var require_delay2 = __commonJS({
  "node_modules/rxjs/operator/delay.js"(exports) {
    "use strict";
    var async_1 = require_async();
    var delay_1 = require_delay();
    function delay(delay2, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.async;
      }
      return delay_1.delay(delay2, scheduler)(this);
    }
    exports.delay = delay;
  }
});

// node_modules/rxjs/add/operator/delay.js
var require_delay3 = __commonJS({
  "node_modules/rxjs/add/operator/delay.js"() {
    "use strict";
    var Observable_1 = require_Observable();
    var delay_1 = require_delay2();
    Observable_1.Observable.prototype.delay = delay_1.delay;
  }
});

// node_modules/rxjs/operators/tap.js
var require_tap = __commonJS({
  "node_modules/rxjs/operators/tap.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var Subscriber_1 = require_Subscriber();
    function tap(nextOrObserver, error, complete) {
      return function tapOperatorFunction(source) {
        return source.lift(new DoOperator(nextOrObserver, error, complete));
      };
    }
    exports.tap = tap;
    var DoOperator = function() {
      function DoOperator2(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
      }
      DoOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
      };
      return DoOperator2;
    }();
    var DoSubscriber = function(_super) {
      __extends(DoSubscriber2, _super);
      function DoSubscriber2(destination, nextOrObserver, error, complete) {
        _super.call(this, destination);
        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);
        safeSubscriber.syncErrorThrowable = true;
        this.add(safeSubscriber);
        this.safeSubscriber = safeSubscriber;
      }
      DoSubscriber2.prototype._next = function(value) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.next(value);
        if (safeSubscriber.syncErrorThrown) {
          this.destination.error(safeSubscriber.syncErrorValue);
        } else {
          this.destination.next(value);
        }
      };
      DoSubscriber2.prototype._error = function(err) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.error(err);
        if (safeSubscriber.syncErrorThrown) {
          this.destination.error(safeSubscriber.syncErrorValue);
        } else {
          this.destination.error(err);
        }
      };
      DoSubscriber2.prototype._complete = function() {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.complete();
        if (safeSubscriber.syncErrorThrown) {
          this.destination.error(safeSubscriber.syncErrorValue);
        } else {
          this.destination.complete();
        }
      };
      return DoSubscriber2;
    }(Subscriber_1.Subscriber);
  }
});

// node_modules/rxjs/operator/do.js
var require_do = __commonJS({
  "node_modules/rxjs/operator/do.js"(exports) {
    "use strict";
    var tap_1 = require_tap();
    function _do(nextOrObserver, error, complete) {
      return tap_1.tap(nextOrObserver, error, complete)(this);
    }
    exports._do = _do;
  }
});

// node_modules/rxjs/add/operator/do.js
var require_do2 = __commonJS({
  "node_modules/rxjs/add/operator/do.js"() {
    "use strict";
    var Observable_1 = require_Observable();
    var do_1 = require_do();
    Observable_1.Observable.prototype.do = do_1._do;
    Observable_1.Observable.prototype._do = do_1._do;
  }
});

// node_modules/rxjs/operators/filter.js
var require_filter = __commonJS({
  "node_modules/rxjs/operators/filter.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var Subscriber_1 = require_Subscriber();
    function filter(predicate, thisArg) {
      return function filterOperatorFunction(source) {
        return source.lift(new FilterOperator(predicate, thisArg));
      };
    }
    exports.filter = filter;
    var FilterOperator = function() {
      function FilterOperator2(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
      }
      FilterOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
      };
      return FilterOperator2;
    }();
    var FilterSubscriber = function(_super) {
      __extends(FilterSubscriber2, _super);
      function FilterSubscriber2(destination, predicate, thisArg) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.count = 0;
      }
      FilterSubscriber2.prototype._next = function(value) {
        var result;
        try {
          result = this.predicate.call(this.thisArg, value, this.count++);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        if (result) {
          this.destination.next(value);
        }
      };
      return FilterSubscriber2;
    }(Subscriber_1.Subscriber);
  }
});

// node_modules/rxjs/operator/filter.js
var require_filter2 = __commonJS({
  "node_modules/rxjs/operator/filter.js"(exports) {
    "use strict";
    var filter_1 = require_filter();
    function filter(predicate, thisArg) {
      return filter_1.filter(predicate, thisArg)(this);
    }
    exports.filter = filter;
  }
});

// node_modules/rxjs/add/operator/filter.js
var require_filter3 = __commonJS({
  "node_modules/rxjs/add/operator/filter.js"() {
    "use strict";
    var Observable_1 = require_Observable();
    var filter_1 = require_filter2();
    Observable_1.Observable.prototype.filter = filter_1.filter;
  }
});

// node_modules/rxjs/operators/map.js
var require_map = __commonJS({
  "node_modules/rxjs/operators/map.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var Subscriber_1 = require_Subscriber();
    function map(project, thisArg) {
      return function mapOperation(source) {
        if (typeof project !== "function") {
          throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
        }
        return source.lift(new MapOperator(project, thisArg));
      };
    }
    exports.map = map;
    var MapOperator = function() {
      function MapOperator2(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
      }
      MapOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
      };
      return MapOperator2;
    }();
    exports.MapOperator = MapOperator;
    var MapSubscriber = function(_super) {
      __extends(MapSubscriber2, _super);
      function MapSubscriber2(destination, project, thisArg) {
        _super.call(this, destination);
        this.project = project;
        this.count = 0;
        this.thisArg = thisArg || this;
      }
      MapSubscriber2.prototype._next = function(value) {
        var result;
        try {
          result = this.project.call(this.thisArg, value, this.count++);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.destination.next(result);
      };
      return MapSubscriber2;
    }(Subscriber_1.Subscriber);
  }
});

// node_modules/rxjs/operator/map.js
var require_map2 = __commonJS({
  "node_modules/rxjs/operator/map.js"(exports) {
    "use strict";
    var map_1 = require_map();
    function map(project, thisArg) {
      return map_1.map(project, thisArg)(this);
    }
    exports.map = map;
  }
});

// node_modules/rxjs/add/operator/map.js
var require_map3 = __commonJS({
  "node_modules/rxjs/add/operator/map.js"() {
    "use strict";
    var Observable_1 = require_Observable();
    var map_1 = require_map2();
    Observable_1.Observable.prototype.map = map_1.map;
  }
});

// node_modules/rxjs/operators/mergeMap.js
var require_mergeMap = __commonJS({
  "node_modules/rxjs/operators/mergeMap.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var subscribeToResult_1 = require_subscribeToResult();
    var OuterSubscriber_1 = require_OuterSubscriber();
    function mergeMap(project, resultSelector, concurrent) {
      if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
      }
      return function mergeMapOperatorFunction(source) {
        if (typeof resultSelector === "number") {
          concurrent = resultSelector;
          resultSelector = null;
        }
        return source.lift(new MergeMapOperator(project, resultSelector, concurrent));
      };
    }
    exports.mergeMap = mergeMap;
    var MergeMapOperator = function() {
      function MergeMapOperator2(project, resultSelector, concurrent) {
        if (concurrent === void 0) {
          concurrent = Number.POSITIVE_INFINITY;
        }
        this.project = project;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
      }
      MergeMapOperator2.prototype.call = function(observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));
      };
      return MergeMapOperator2;
    }();
    exports.MergeMapOperator = MergeMapOperator;
    var MergeMapSubscriber = function(_super) {
      __extends(MergeMapSubscriber2, _super);
      function MergeMapSubscriber2(destination, project, resultSelector, concurrent) {
        if (concurrent === void 0) {
          concurrent = Number.POSITIVE_INFINITY;
        }
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
        this.index = 0;
      }
      MergeMapSubscriber2.prototype._next = function(value) {
        if (this.active < this.concurrent) {
          this._tryNext(value);
        } else {
          this.buffer.push(value);
        }
      };
      MergeMapSubscriber2.prototype._tryNext = function(value) {
        var result;
        var index = this.index++;
        try {
          result = this.project(value, index);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.active++;
        this._innerSub(result, value, index);
      };
      MergeMapSubscriber2.prototype._innerSub = function(ish, value, index) {
        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
      };
      MergeMapSubscriber2.prototype._complete = function() {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
          this.destination.complete();
        }
      };
      MergeMapSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
          this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);
        } else {
          this.destination.next(innerValue);
        }
      };
      MergeMapSubscriber2.prototype._notifyResultSelector = function(outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
          result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.destination.next(result);
      };
      MergeMapSubscriber2.prototype.notifyComplete = function(innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
          this._next(buffer.shift());
        } else if (this.active === 0 && this.hasCompleted) {
          this.destination.complete();
        }
      };
      return MergeMapSubscriber2;
    }(OuterSubscriber_1.OuterSubscriber);
    exports.MergeMapSubscriber = MergeMapSubscriber;
  }
});

// node_modules/rxjs/operator/mergeMap.js
var require_mergeMap2 = __commonJS({
  "node_modules/rxjs/operator/mergeMap.js"(exports) {
    "use strict";
    var mergeMap_1 = require_mergeMap();
    function mergeMap(project, resultSelector, concurrent) {
      if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
      }
      return mergeMap_1.mergeMap(project, resultSelector, concurrent)(this);
    }
    exports.mergeMap = mergeMap;
  }
});

// node_modules/rxjs/add/operator/mergeMap.js
var require_mergeMap3 = __commonJS({
  "node_modules/rxjs/add/operator/mergeMap.js"() {
    "use strict";
    var Observable_1 = require_Observable();
    var mergeMap_1 = require_mergeMap2();
    Observable_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;
    Observable_1.Observable.prototype.flatMap = mergeMap_1.mergeMap;
  }
});

// node_modules/rxjs/operators/concatMap.js
var require_concatMap = __commonJS({
  "node_modules/rxjs/operators/concatMap.js"(exports) {
    "use strict";
    var mergeMap_1 = require_mergeMap();
    function concatMap(project, resultSelector) {
      return mergeMap_1.mergeMap(project, resultSelector, 1);
    }
    exports.concatMap = concatMap;
  }
});

// node_modules/rxjs/operator/concatMap.js
var require_concatMap2 = __commonJS({
  "node_modules/rxjs/operator/concatMap.js"(exports) {
    "use strict";
    var concatMap_1 = require_concatMap();
    function concatMap(project, resultSelector) {
      return concatMap_1.concatMap(project, resultSelector)(this);
    }
    exports.concatMap = concatMap;
  }
});

// node_modules/rxjs/add/operator/concatMap.js
var require_concatMap3 = __commonJS({
  "node_modules/rxjs/add/operator/concatMap.js"() {
    "use strict";
    var Observable_1 = require_Observable();
    var concatMap_1 = require_concatMap2();
    Observable_1.Observable.prototype.concatMap = concatMap_1.concatMap;
  }
});

// node_modules/rxjs/operators/retryWhen.js
var require_retryWhen = __commonJS({
  "node_modules/rxjs/operators/retryWhen.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var Subject_1 = require_Subject();
    var tryCatch_1 = require_tryCatch();
    var errorObject_1 = require_errorObject();
    var OuterSubscriber_1 = require_OuterSubscriber();
    var subscribeToResult_1 = require_subscribeToResult();
    function retryWhen(notifier) {
      return function(source) {
        return source.lift(new RetryWhenOperator(notifier, source));
      };
    }
    exports.retryWhen = retryWhen;
    var RetryWhenOperator = function() {
      function RetryWhenOperator2(notifier, source) {
        this.notifier = notifier;
        this.source = source;
      }
      RetryWhenOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
      };
      return RetryWhenOperator2;
    }();
    var RetryWhenSubscriber = function(_super) {
      __extends(RetryWhenSubscriber2, _super);
      function RetryWhenSubscriber2(destination, notifier, source) {
        _super.call(this, destination);
        this.notifier = notifier;
        this.source = source;
      }
      RetryWhenSubscriber2.prototype.error = function(err) {
        if (!this.isStopped) {
          var errors = this.errors;
          var retries = this.retries;
          var retriesSubscription = this.retriesSubscription;
          if (!retries) {
            errors = new Subject_1.Subject();
            retries = tryCatch_1.tryCatch(this.notifier)(errors);
            if (retries === errorObject_1.errorObject) {
              return _super.prototype.error.call(this, errorObject_1.errorObject.e);
            }
            retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);
          } else {
            this.errors = null;
            this.retriesSubscription = null;
          }
          this._unsubscribeAndRecycle();
          this.errors = errors;
          this.retries = retries;
          this.retriesSubscription = retriesSubscription;
          errors.next(err);
        }
      };
      RetryWhenSubscriber2.prototype._unsubscribe = function() {
        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;
        if (errors) {
          errors.unsubscribe();
          this.errors = null;
        }
        if (retriesSubscription) {
          retriesSubscription.unsubscribe();
          this.retriesSubscription = null;
        }
        this.retries = null;
      };
      RetryWhenSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this, errors = _a.errors, retries = _a.retries, retriesSubscription = _a.retriesSubscription;
        this.errors = null;
        this.retries = null;
        this.retriesSubscription = null;
        this._unsubscribeAndRecycle();
        this.errors = errors;
        this.retries = retries;
        this.retriesSubscription = retriesSubscription;
        this.source.subscribe(this);
      };
      return RetryWhenSubscriber2;
    }(OuterSubscriber_1.OuterSubscriber);
  }
});

// node_modules/rxjs/operator/retryWhen.js
var require_retryWhen2 = __commonJS({
  "node_modules/rxjs/operator/retryWhen.js"(exports) {
    "use strict";
    var retryWhen_1 = require_retryWhen();
    function retryWhen(notifier) {
      return retryWhen_1.retryWhen(notifier)(this);
    }
    exports.retryWhen = retryWhen;
  }
});

// node_modules/rxjs/add/operator/retryWhen.js
var require_retryWhen3 = __commonJS({
  "node_modules/rxjs/add/operator/retryWhen.js"() {
    "use strict";
    var Observable_1 = require_Observable();
    var retryWhen_1 = require_retryWhen2();
    Observable_1.Observable.prototype.retryWhen = retryWhen_1.retryWhen;
  }
});

// node_modules/rxjs/operators/refCount.js
var require_refCount = __commonJS({
  "node_modules/rxjs/operators/refCount.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var Subscriber_1 = require_Subscriber();
    function refCount() {
      return function refCountOperatorFunction(source) {
        return source.lift(new RefCountOperator(source));
      };
    }
    exports.refCount = refCount;
    var RefCountOperator = function() {
      function RefCountOperator2(connectable) {
        this.connectable = connectable;
      }
      RefCountOperator2.prototype.call = function(subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
          refCounter.connection = connectable.connect();
        }
        return subscription;
      };
      return RefCountOperator2;
    }();
    var RefCountSubscriber = function(_super) {
      __extends(RefCountSubscriber2, _super);
      function RefCountSubscriber2(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
      }
      RefCountSubscriber2.prototype._unsubscribe = function() {
        var connectable = this.connectable;
        if (!connectable) {
          this.connection = null;
          return;
        }
        this.connectable = null;
        var refCount2 = connectable._refCount;
        if (refCount2 <= 0) {
          this.connection = null;
          return;
        }
        connectable._refCount = refCount2 - 1;
        if (refCount2 > 1) {
          this.connection = null;
          return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
          sharedConnection.unsubscribe();
        }
      };
      return RefCountSubscriber2;
    }(Subscriber_1.Subscriber);
  }
});

// node_modules/rxjs/observable/ConnectableObservable.js
var require_ConnectableObservable = __commonJS({
  "node_modules/rxjs/observable/ConnectableObservable.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var Subject_1 = require_Subject();
    var Observable_1 = require_Observable();
    var Subscriber_1 = require_Subscriber();
    var Subscription_1 = require_Subscription();
    var refCount_1 = require_refCount();
    var ConnectableObservable = function(_super) {
      __extends(ConnectableObservable2, _super);
      function ConnectableObservable2(source, subjectFactory) {
        _super.call(this);
        this.source = source;
        this.subjectFactory = subjectFactory;
        this._refCount = 0;
        this._isComplete = false;
      }
      ConnectableObservable2.prototype._subscribe = function(subscriber) {
        return this.getSubject().subscribe(subscriber);
      };
      ConnectableObservable2.prototype.getSubject = function() {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
          this._subject = this.subjectFactory();
        }
        return this._subject;
      };
      ConnectableObservable2.prototype.connect = function() {
        var connection = this._connection;
        if (!connection) {
          this._isComplete = false;
          connection = this._connection = new Subscription_1.Subscription();
          connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));
          if (connection.closed) {
            this._connection = null;
            connection = Subscription_1.Subscription.EMPTY;
          } else {
            this._connection = connection;
          }
        }
        return connection;
      };
      ConnectableObservable2.prototype.refCount = function() {
        return refCount_1.refCount()(this);
      };
      return ConnectableObservable2;
    }(Observable_1.Observable);
    exports.ConnectableObservable = ConnectableObservable;
    var connectableProto = ConnectableObservable.prototype;
    exports.connectableObservableDescriptor = {
      operator: { value: null },
      _refCount: { value: 0, writable: true },
      _subject: { value: null, writable: true },
      _connection: { value: null, writable: true },
      _subscribe: { value: connectableProto._subscribe },
      _isComplete: { value: connectableProto._isComplete, writable: true },
      getSubject: { value: connectableProto.getSubject },
      connect: { value: connectableProto.connect },
      refCount: { value: connectableProto.refCount }
    };
    var ConnectableSubscriber = function(_super) {
      __extends(ConnectableSubscriber2, _super);
      function ConnectableSubscriber2(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
      }
      ConnectableSubscriber2.prototype._error = function(err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
      };
      ConnectableSubscriber2.prototype._complete = function() {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
      };
      ConnectableSubscriber2.prototype._unsubscribe = function() {
        var connectable = this.connectable;
        if (connectable) {
          this.connectable = null;
          var connection = connectable._connection;
          connectable._refCount = 0;
          connectable._subject = null;
          connectable._connection = null;
          if (connection) {
            connection.unsubscribe();
          }
        }
      };
      return ConnectableSubscriber2;
    }(Subject_1.SubjectSubscriber);
    var RefCountOperator = function() {
      function RefCountOperator2(connectable) {
        this.connectable = connectable;
      }
      RefCountOperator2.prototype.call = function(subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
          refCounter.connection = connectable.connect();
        }
        return subscription;
      };
      return RefCountOperator2;
    }();
    var RefCountSubscriber = function(_super) {
      __extends(RefCountSubscriber2, _super);
      function RefCountSubscriber2(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
      }
      RefCountSubscriber2.prototype._unsubscribe = function() {
        var connectable = this.connectable;
        if (!connectable) {
          this.connection = null;
          return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
          this.connection = null;
          return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
          this.connection = null;
          return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
          sharedConnection.unsubscribe();
        }
      };
      return RefCountSubscriber2;
    }(Subscriber_1.Subscriber);
  }
});

// node_modules/rxjs/operators/multicast.js
var require_multicast = __commonJS({
  "node_modules/rxjs/operators/multicast.js"(exports) {
    "use strict";
    var ConnectableObservable_1 = require_ConnectableObservable();
    function multicast(subjectOrSubjectFactory, selector) {
      return function multicastOperatorFunction(source) {
        var subjectFactory;
        if (typeof subjectOrSubjectFactory === "function") {
          subjectFactory = subjectOrSubjectFactory;
        } else {
          subjectFactory = function subjectFactory2() {
            return subjectOrSubjectFactory;
          };
        }
        if (typeof selector === "function") {
          return source.lift(new MulticastOperator(subjectFactory, selector));
        }
        var connectable = Object.create(source, ConnectableObservable_1.connectableObservableDescriptor);
        connectable.source = source;
        connectable.subjectFactory = subjectFactory;
        return connectable;
      };
    }
    exports.multicast = multicast;
    var MulticastOperator = function() {
      function MulticastOperator2(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
      }
      MulticastOperator2.prototype.call = function(subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
      };
      return MulticastOperator2;
    }();
    exports.MulticastOperator = MulticastOperator;
  }
});

// node_modules/rxjs/operators/share.js
var require_share = __commonJS({
  "node_modules/rxjs/operators/share.js"(exports) {
    "use strict";
    var multicast_1 = require_multicast();
    var refCount_1 = require_refCount();
    var Subject_1 = require_Subject();
    function shareSubjectFactory() {
      return new Subject_1.Subject();
    }
    function share() {
      return function(source) {
        return refCount_1.refCount()(multicast_1.multicast(shareSubjectFactory)(source));
      };
    }
    exports.share = share;
  }
});

// node_modules/rxjs/operator/share.js
var require_share2 = __commonJS({
  "node_modules/rxjs/operator/share.js"(exports) {
    "use strict";
    var share_1 = require_share();
    function share() {
      return share_1.share()(this);
    }
    exports.share = share;
  }
});

// node_modules/rxjs/add/operator/share.js
var require_share3 = __commonJS({
  "node_modules/rxjs/add/operator/share.js"() {
    "use strict";
    var Observable_1 = require_Observable();
    var share_1 = require_share2();
    Observable_1.Observable.prototype.share = share_1.share;
  }
});

// node_modules/rxjs/util/ArgumentOutOfRangeError.js
var require_ArgumentOutOfRangeError = __commonJS({
  "node_modules/rxjs/util/ArgumentOutOfRangeError.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var ArgumentOutOfRangeError = function(_super) {
      __extends(ArgumentOutOfRangeError2, _super);
      function ArgumentOutOfRangeError2() {
        var err = _super.call(this, "argument out of range");
        this.name = err.name = "ArgumentOutOfRangeError";
        this.stack = err.stack;
        this.message = err.message;
      }
      return ArgumentOutOfRangeError2;
    }(Error);
    exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;
  }
});

// node_modules/rxjs/operators/take.js
var require_take = __commonJS({
  "node_modules/rxjs/operators/take.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var Subscriber_1 = require_Subscriber();
    var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
    var EmptyObservable_1 = require_EmptyObservable();
    function take(count) {
      return function(source) {
        if (count === 0) {
          return new EmptyObservable_1.EmptyObservable();
        } else {
          return source.lift(new TakeOperator(count));
        }
      };
    }
    exports.take = take;
    var TakeOperator = function() {
      function TakeOperator2(total) {
        this.total = total;
        if (this.total < 0) {
          throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
        }
      }
      TakeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
      };
      return TakeOperator2;
    }();
    var TakeSubscriber = function(_super) {
      __extends(TakeSubscriber2, _super);
      function TakeSubscriber2(destination, total) {
        _super.call(this, destination);
        this.total = total;
        this.count = 0;
      }
      TakeSubscriber2.prototype._next = function(value) {
        var total = this.total;
        var count = ++this.count;
        if (count <= total) {
          this.destination.next(value);
          if (count === total) {
            this.destination.complete();
            this.unsubscribe();
          }
        }
      };
      return TakeSubscriber2;
    }(Subscriber_1.Subscriber);
  }
});

// node_modules/rxjs/operator/take.js
var require_take2 = __commonJS({
  "node_modules/rxjs/operator/take.js"(exports) {
    "use strict";
    var take_1 = require_take();
    function take(count) {
      return take_1.take(count)(this);
    }
    exports.take = take;
  }
});

// node_modules/rxjs/add/operator/take.js
var require_take3 = __commonJS({
  "node_modules/rxjs/add/operator/take.js"() {
    "use strict";
    var Observable_1 = require_Observable();
    var take_1 = require_take2();
    Observable_1.Observable.prototype.take = take_1.take;
  }
});

// node_modules/rxjs/observable/dom/AjaxObservable.js
var require_AjaxObservable = __commonJS({
  "node_modules/rxjs/observable/dom/AjaxObservable.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var root_1 = require_root();
    var tryCatch_1 = require_tryCatch();
    var errorObject_1 = require_errorObject();
    var Observable_1 = require_Observable();
    var Subscriber_1 = require_Subscriber();
    var map_1 = require_map();
    function getCORSRequest() {
      if (root_1.root.XMLHttpRequest) {
        return new root_1.root.XMLHttpRequest();
      } else if (!!root_1.root.XDomainRequest) {
        return new root_1.root.XDomainRequest();
      } else {
        throw new Error("CORS is not supported by your browser");
      }
    }
    function getXMLHttpRequest() {
      if (root_1.root.XMLHttpRequest) {
        return new root_1.root.XMLHttpRequest();
      } else {
        var progId = void 0;
        try {
          var progIds = ["Msxml2.XMLHTTP", "Microsoft.XMLHTTP", "Msxml2.XMLHTTP.4.0"];
          for (var i = 0; i < 3; i++) {
            try {
              progId = progIds[i];
              if (new root_1.root.ActiveXObject(progId)) {
                break;
              }
            } catch (e2) {
            }
          }
          return new root_1.root.ActiveXObject(progId);
        } catch (e2) {
          throw new Error("XMLHttpRequest is not supported by your browser");
        }
      }
    }
    function ajaxGet(url, headers) {
      if (headers === void 0) {
        headers = null;
      }
      return new AjaxObservable({ method: "GET", url, headers });
    }
    exports.ajaxGet = ajaxGet;
    function ajaxPost(url, body, headers) {
      return new AjaxObservable({ method: "POST", url, body, headers });
    }
    exports.ajaxPost = ajaxPost;
    function ajaxDelete(url, headers) {
      return new AjaxObservable({ method: "DELETE", url, headers });
    }
    exports.ajaxDelete = ajaxDelete;
    function ajaxPut(url, body, headers) {
      return new AjaxObservable({ method: "PUT", url, body, headers });
    }
    exports.ajaxPut = ajaxPut;
    function ajaxPatch(url, body, headers) {
      return new AjaxObservable({ method: "PATCH", url, body, headers });
    }
    exports.ajaxPatch = ajaxPatch;
    var mapResponse = map_1.map(function(x, index) {
      return x.response;
    });
    function ajaxGetJSON(url, headers) {
      return mapResponse(new AjaxObservable({
        method: "GET",
        url,
        responseType: "json",
        headers
      }));
    }
    exports.ajaxGetJSON = ajaxGetJSON;
    var AjaxObservable = function(_super) {
      __extends(AjaxObservable2, _super);
      function AjaxObservable2(urlOrRequest) {
        _super.call(this);
        var request = {
          async: true,
          createXHR: function() {
            return this.crossDomain ? getCORSRequest.call(this) : getXMLHttpRequest();
          },
          crossDomain: false,
          withCredentials: false,
          headers: {},
          method: "GET",
          responseType: "json",
          timeout: 0
        };
        if (typeof urlOrRequest === "string") {
          request.url = urlOrRequest;
        } else {
          for (var prop in urlOrRequest) {
            if (urlOrRequest.hasOwnProperty(prop)) {
              request[prop] = urlOrRequest[prop];
            }
          }
        }
        this.request = request;
      }
      AjaxObservable2.prototype._subscribe = function(subscriber) {
        return new AjaxSubscriber(subscriber, this.request);
      };
      AjaxObservable2.create = function() {
        var create = function(urlOrRequest) {
          return new AjaxObservable2(urlOrRequest);
        };
        create.get = ajaxGet;
        create.post = ajaxPost;
        create.delete = ajaxDelete;
        create.put = ajaxPut;
        create.patch = ajaxPatch;
        create.getJSON = ajaxGetJSON;
        return create;
      }();
      return AjaxObservable2;
    }(Observable_1.Observable);
    exports.AjaxObservable = AjaxObservable;
    var AjaxSubscriber = function(_super) {
      __extends(AjaxSubscriber2, _super);
      function AjaxSubscriber2(destination, request) {
        _super.call(this, destination);
        this.request = request;
        this.done = false;
        var headers = request.headers = request.headers || {};
        if (!request.crossDomain && !headers["X-Requested-With"]) {
          headers["X-Requested-With"] = "XMLHttpRequest";
        }
        if (!("Content-Type" in headers) && !(root_1.root.FormData && request.body instanceof root_1.root.FormData) && typeof request.body !== "undefined") {
          headers["Content-Type"] = "application/x-www-form-urlencoded; charset=UTF-8";
        }
        request.body = this.serializeBody(request.body, request.headers["Content-Type"]);
        this.send();
      }
      AjaxSubscriber2.prototype.next = function(e2) {
        this.done = true;
        var _a = this, xhr = _a.xhr, request = _a.request, destination = _a.destination;
        var response = new AjaxResponse(e2, xhr, request);
        destination.next(response);
      };
      AjaxSubscriber2.prototype.send = function() {
        var _a = this, request = _a.request, _b = _a.request, user = _b.user, method = _b.method, url = _b.url, async = _b.async, password = _b.password, headers = _b.headers, body = _b.body;
        var createXHR = request.createXHR;
        var xhr = tryCatch_1.tryCatch(createXHR).call(request);
        if (xhr === errorObject_1.errorObject) {
          this.error(errorObject_1.errorObject.e);
        } else {
          this.xhr = xhr;
          this.setupEvents(xhr, request);
          var result = void 0;
          if (user) {
            result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async, user, password);
          } else {
            result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async);
          }
          if (result === errorObject_1.errorObject) {
            this.error(errorObject_1.errorObject.e);
            return null;
          }
          if (async) {
            xhr.timeout = request.timeout;
            xhr.responseType = request.responseType;
          }
          if ("withCredentials" in xhr) {
            xhr.withCredentials = !!request.withCredentials;
          }
          this.setHeaders(xhr, headers);
          result = body ? tryCatch_1.tryCatch(xhr.send).call(xhr, body) : tryCatch_1.tryCatch(xhr.send).call(xhr);
          if (result === errorObject_1.errorObject) {
            this.error(errorObject_1.errorObject.e);
            return null;
          }
        }
        return xhr;
      };
      AjaxSubscriber2.prototype.serializeBody = function(body, contentType) {
        if (!body || typeof body === "string") {
          return body;
        } else if (root_1.root.FormData && body instanceof root_1.root.FormData) {
          return body;
        }
        if (contentType) {
          var splitIndex = contentType.indexOf(";");
          if (splitIndex !== -1) {
            contentType = contentType.substring(0, splitIndex);
          }
        }
        switch (contentType) {
          case "application/x-www-form-urlencoded":
            return Object.keys(body).map(function(key) {
              return encodeURIComponent(key) + "=" + encodeURIComponent(body[key]);
            }).join("&");
          case "application/json":
            return JSON.stringify(body);
          default:
            return body;
        }
      };
      AjaxSubscriber2.prototype.setHeaders = function(xhr, headers) {
        for (var key in headers) {
          if (headers.hasOwnProperty(key)) {
            xhr.setRequestHeader(key, headers[key]);
          }
        }
      };
      AjaxSubscriber2.prototype.setupEvents = function(xhr, request) {
        var progressSubscriber = request.progressSubscriber;
        function xhrTimeout(e2) {
          var _a = xhrTimeout, subscriber = _a.subscriber, progressSubscriber2 = _a.progressSubscriber, request2 = _a.request;
          if (progressSubscriber2) {
            progressSubscriber2.error(e2);
          }
          subscriber.error(new AjaxTimeoutError(this, request2));
        }
        ;
        xhr.ontimeout = xhrTimeout;
        xhrTimeout.request = request;
        xhrTimeout.subscriber = this;
        xhrTimeout.progressSubscriber = progressSubscriber;
        if (xhr.upload && "withCredentials" in xhr) {
          if (progressSubscriber) {
            var xhrProgress_1;
            xhrProgress_1 = function(e2) {
              var progressSubscriber2 = xhrProgress_1.progressSubscriber;
              progressSubscriber2.next(e2);
            };
            if (root_1.root.XDomainRequest) {
              xhr.onprogress = xhrProgress_1;
            } else {
              xhr.upload.onprogress = xhrProgress_1;
            }
            xhrProgress_1.progressSubscriber = progressSubscriber;
          }
          var xhrError_1;
          xhrError_1 = function(e2) {
            var _a = xhrError_1, progressSubscriber2 = _a.progressSubscriber, subscriber = _a.subscriber, request2 = _a.request;
            if (progressSubscriber2) {
              progressSubscriber2.error(e2);
            }
            subscriber.error(new AjaxError("ajax error", this, request2));
          };
          xhr.onerror = xhrError_1;
          xhrError_1.request = request;
          xhrError_1.subscriber = this;
          xhrError_1.progressSubscriber = progressSubscriber;
        }
        function xhrReadyStateChange(e2) {
          var _a = xhrReadyStateChange, subscriber = _a.subscriber, progressSubscriber2 = _a.progressSubscriber, request2 = _a.request;
          if (this.readyState === 4) {
            var status_1 = this.status === 1223 ? 204 : this.status;
            var response = this.responseType === "text" ? this.response || this.responseText : this.response;
            if (status_1 === 0) {
              status_1 = response ? 200 : 0;
            }
            if (200 <= status_1 && status_1 < 300) {
              if (progressSubscriber2) {
                progressSubscriber2.complete();
              }
              subscriber.next(e2);
              subscriber.complete();
            } else {
              if (progressSubscriber2) {
                progressSubscriber2.error(e2);
              }
              subscriber.error(new AjaxError("ajax error " + status_1, this, request2));
            }
          }
        }
        ;
        xhr.onreadystatechange = xhrReadyStateChange;
        xhrReadyStateChange.subscriber = this;
        xhrReadyStateChange.progressSubscriber = progressSubscriber;
        xhrReadyStateChange.request = request;
      };
      AjaxSubscriber2.prototype.unsubscribe = function() {
        var _a = this, done = _a.done, xhr = _a.xhr;
        if (!done && xhr && xhr.readyState !== 4 && typeof xhr.abort === "function") {
          xhr.abort();
        }
        _super.prototype.unsubscribe.call(this);
      };
      return AjaxSubscriber2;
    }(Subscriber_1.Subscriber);
    exports.AjaxSubscriber = AjaxSubscriber;
    var AjaxResponse = function() {
      function AjaxResponse2(originalEvent, xhr, request) {
        this.originalEvent = originalEvent;
        this.xhr = xhr;
        this.request = request;
        this.status = xhr.status;
        this.responseType = xhr.responseType || request.responseType;
        this.response = parseXhrResponse(this.responseType, xhr);
      }
      return AjaxResponse2;
    }();
    exports.AjaxResponse = AjaxResponse;
    var AjaxError = function(_super) {
      __extends(AjaxError2, _super);
      function AjaxError2(message, xhr, request) {
        _super.call(this, message);
        this.message = message;
        this.xhr = xhr;
        this.request = request;
        this.status = xhr.status;
        this.responseType = xhr.responseType || request.responseType;
        this.response = parseXhrResponse(this.responseType, xhr);
      }
      return AjaxError2;
    }(Error);
    exports.AjaxError = AjaxError;
    function parseXhrResponse(responseType, xhr) {
      switch (responseType) {
        case "json":
          if ("response" in xhr) {
            return xhr.responseType ? xhr.response : JSON.parse(xhr.response || xhr.responseText || "null");
          } else {
            return JSON.parse(xhr.responseText || "null");
          }
        case "xml":
          return xhr.responseXML;
        case "text":
        default:
          return "response" in xhr ? xhr.response : xhr.responseText;
      }
    }
    var AjaxTimeoutError = function(_super) {
      __extends(AjaxTimeoutError2, _super);
      function AjaxTimeoutError2(xhr, request) {
        _super.call(this, "ajax timeout", xhr, request);
      }
      return AjaxTimeoutError2;
    }(AjaxError);
    exports.AjaxTimeoutError = AjaxTimeoutError;
  }
});

// node_modules/rxjs/observable/dom/ajax.js
var require_ajax = __commonJS({
  "node_modules/rxjs/observable/dom/ajax.js"(exports) {
    "use strict";
    var AjaxObservable_1 = require_AjaxObservable();
    exports.ajax = AjaxObservable_1.AjaxObservable.create;
  }
});

// node_modules/rxjs/add/observable/dom/ajax.js
var require_ajax2 = __commonJS({
  "node_modules/rxjs/add/observable/dom/ajax.js"() {
    "use strict";
    var Observable_1 = require_Observable();
    var ajax_1 = require_ajax();
    Observable_1.Observable.ajax = ajax_1.ajax;
  }
});

// node_modules/rxjs/observable/empty.js
var require_empty = __commonJS({
  "node_modules/rxjs/observable/empty.js"(exports) {
    "use strict";
    var EmptyObservable_1 = require_EmptyObservable();
    exports.empty = EmptyObservable_1.EmptyObservable.create;
  }
});

// node_modules/rxjs/add/observable/empty.js
var require_empty2 = __commonJS({
  "node_modules/rxjs/add/observable/empty.js"() {
    "use strict";
    var Observable_1 = require_Observable();
    var empty_1 = require_empty();
    Observable_1.Observable.empty = empty_1.empty;
  }
});

// node_modules/rxjs/observable/PromiseObservable.js
var require_PromiseObservable = __commonJS({
  "node_modules/rxjs/observable/PromiseObservable.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var root_1 = require_root();
    var Observable_1 = require_Observable();
    var PromiseObservable = function(_super) {
      __extends(PromiseObservable2, _super);
      function PromiseObservable2(promise, scheduler) {
        _super.call(this);
        this.promise = promise;
        this.scheduler = scheduler;
      }
      PromiseObservable2.create = function(promise, scheduler) {
        return new PromiseObservable2(promise, scheduler);
      };
      PromiseObservable2.prototype._subscribe = function(subscriber) {
        var _this = this;
        var promise = this.promise;
        var scheduler = this.scheduler;
        if (scheduler == null) {
          if (this._isScalar) {
            if (!subscriber.closed) {
              subscriber.next(this.value);
              subscriber.complete();
            }
          } else {
            promise.then(function(value) {
              _this.value = value;
              _this._isScalar = true;
              if (!subscriber.closed) {
                subscriber.next(value);
                subscriber.complete();
              }
            }, function(err) {
              if (!subscriber.closed) {
                subscriber.error(err);
              }
            }).then(null, function(err) {
              root_1.root.setTimeout(function() {
                throw err;
              });
            });
          }
        } else {
          if (this._isScalar) {
            if (!subscriber.closed) {
              return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber });
            }
          } else {
            promise.then(function(value) {
              _this.value = value;
              _this._isScalar = true;
              if (!subscriber.closed) {
                subscriber.add(scheduler.schedule(dispatchNext, 0, { value, subscriber }));
              }
            }, function(err) {
              if (!subscriber.closed) {
                subscriber.add(scheduler.schedule(dispatchError, 0, { err, subscriber }));
              }
            }).then(null, function(err) {
              root_1.root.setTimeout(function() {
                throw err;
              });
            });
          }
        }
      };
      return PromiseObservable2;
    }(Observable_1.Observable);
    exports.PromiseObservable = PromiseObservable;
    function dispatchNext(arg) {
      var value = arg.value, subscriber = arg.subscriber;
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }
    function dispatchError(arg) {
      var err = arg.err, subscriber = arg.subscriber;
      if (!subscriber.closed) {
        subscriber.error(err);
      }
    }
  }
});

// node_modules/rxjs/observable/IteratorObservable.js
var require_IteratorObservable = __commonJS({
  "node_modules/rxjs/observable/IteratorObservable.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var root_1 = require_root();
    var Observable_1 = require_Observable();
    var iterator_1 = require_iterator();
    var IteratorObservable = function(_super) {
      __extends(IteratorObservable2, _super);
      function IteratorObservable2(iterator, scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
        if (iterator == null) {
          throw new Error("iterator cannot be null.");
        }
        this.iterator = getIterator(iterator);
      }
      IteratorObservable2.create = function(iterator, scheduler) {
        return new IteratorObservable2(iterator, scheduler);
      };
      IteratorObservable2.dispatch = function(state) {
        var index = state.index, hasError = state.hasError, iterator = state.iterator, subscriber = state.subscriber;
        if (hasError) {
          subscriber.error(state.error);
          return;
        }
        var result = iterator.next();
        if (result.done) {
          subscriber.complete();
          return;
        }
        subscriber.next(result.value);
        state.index = index + 1;
        if (subscriber.closed) {
          if (typeof iterator.return === "function") {
            iterator.return();
          }
          return;
        }
        this.schedule(state);
      };
      IteratorObservable2.prototype._subscribe = function(subscriber) {
        var index = 0;
        var _a = this, iterator = _a.iterator, scheduler = _a.scheduler;
        if (scheduler) {
          return scheduler.schedule(IteratorObservable2.dispatch, 0, {
            index,
            iterator,
            subscriber
          });
        } else {
          do {
            var result = iterator.next();
            if (result.done) {
              subscriber.complete();
              break;
            } else {
              subscriber.next(result.value);
            }
            if (subscriber.closed) {
              if (typeof iterator.return === "function") {
                iterator.return();
              }
              break;
            }
          } while (true);
        }
      };
      return IteratorObservable2;
    }(Observable_1.Observable);
    exports.IteratorObservable = IteratorObservable;
    var StringIterator = function() {
      function StringIterator2(str, idx, len) {
        if (idx === void 0) {
          idx = 0;
        }
        if (len === void 0) {
          len = str.length;
        }
        this.str = str;
        this.idx = idx;
        this.len = len;
      }
      StringIterator2.prototype[iterator_1.iterator] = function() {
        return this;
      };
      StringIterator2.prototype.next = function() {
        return this.idx < this.len ? {
          done: false,
          value: this.str.charAt(this.idx++)
        } : {
          done: true,
          value: void 0
        };
      };
      return StringIterator2;
    }();
    var ArrayIterator = function() {
      function ArrayIterator2(arr, idx, len) {
        if (idx === void 0) {
          idx = 0;
        }
        if (len === void 0) {
          len = toLength(arr);
        }
        this.arr = arr;
        this.idx = idx;
        this.len = len;
      }
      ArrayIterator2.prototype[iterator_1.iterator] = function() {
        return this;
      };
      ArrayIterator2.prototype.next = function() {
        return this.idx < this.len ? {
          done: false,
          value: this.arr[this.idx++]
        } : {
          done: true,
          value: void 0
        };
      };
      return ArrayIterator2;
    }();
    function getIterator(obj) {
      var i = obj[iterator_1.iterator];
      if (!i && typeof obj === "string") {
        return new StringIterator(obj);
      }
      if (!i && obj.length !== void 0) {
        return new ArrayIterator(obj);
      }
      if (!i) {
        throw new TypeError("object is not iterable");
      }
      return obj[iterator_1.iterator]();
    }
    var maxSafeInteger = Math.pow(2, 53) - 1;
    function toLength(o2) {
      var len = +o2.length;
      if (isNaN(len)) {
        return 0;
      }
      if (len === 0 || !numberIsFinite(len)) {
        return len;
      }
      len = sign(len) * Math.floor(Math.abs(len));
      if (len <= 0) {
        return 0;
      }
      if (len > maxSafeInteger) {
        return maxSafeInteger;
      }
      return len;
    }
    function numberIsFinite(value) {
      return typeof value === "number" && root_1.root.isFinite(value);
    }
    function sign(value) {
      var valueAsNumber = +value;
      if (valueAsNumber === 0) {
        return valueAsNumber;
      }
      if (isNaN(valueAsNumber)) {
        return valueAsNumber;
      }
      return valueAsNumber < 0 ? -1 : 1;
    }
  }
});

// node_modules/rxjs/observable/ArrayLikeObservable.js
var require_ArrayLikeObservable = __commonJS({
  "node_modules/rxjs/observable/ArrayLikeObservable.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var Observable_1 = require_Observable();
    var ScalarObservable_1 = require_ScalarObservable();
    var EmptyObservable_1 = require_EmptyObservable();
    var ArrayLikeObservable = function(_super) {
      __extends(ArrayLikeObservable2, _super);
      function ArrayLikeObservable2(arrayLike, scheduler) {
        _super.call(this);
        this.arrayLike = arrayLike;
        this.scheduler = scheduler;
        if (!scheduler && arrayLike.length === 1) {
          this._isScalar = true;
          this.value = arrayLike[0];
        }
      }
      ArrayLikeObservable2.create = function(arrayLike, scheduler) {
        var length = arrayLike.length;
        if (length === 0) {
          return new EmptyObservable_1.EmptyObservable();
        } else if (length === 1) {
          return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);
        } else {
          return new ArrayLikeObservable2(arrayLike, scheduler);
        }
      };
      ArrayLikeObservable2.dispatch = function(state) {
        var arrayLike = state.arrayLike, index = state.index, length = state.length, subscriber = state.subscriber;
        if (subscriber.closed) {
          return;
        }
        if (index >= length) {
          subscriber.complete();
          return;
        }
        subscriber.next(arrayLike[index]);
        state.index = index + 1;
        this.schedule(state);
      };
      ArrayLikeObservable2.prototype._subscribe = function(subscriber) {
        var index = 0;
        var _a = this, arrayLike = _a.arrayLike, scheduler = _a.scheduler;
        var length = arrayLike.length;
        if (scheduler) {
          return scheduler.schedule(ArrayLikeObservable2.dispatch, 0, {
            arrayLike,
            index,
            length,
            subscriber
          });
        } else {
          for (var i = 0; i < length && !subscriber.closed; i++) {
            subscriber.next(arrayLike[i]);
          }
          subscriber.complete();
        }
      };
      return ArrayLikeObservable2;
    }(Observable_1.Observable);
    exports.ArrayLikeObservable = ArrayLikeObservable;
  }
});

// node_modules/rxjs/operators/observeOn.js
var require_observeOn = __commonJS({
  "node_modules/rxjs/operators/observeOn.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var Subscriber_1 = require_Subscriber();
    var Notification_1 = require_Notification();
    function observeOn(scheduler, delay) {
      if (delay === void 0) {
        delay = 0;
      }
      return function observeOnOperatorFunction(source) {
        return source.lift(new ObserveOnOperator(scheduler, delay));
      };
    }
    exports.observeOn = observeOn;
    var ObserveOnOperator = function() {
      function ObserveOnOperator2(scheduler, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        this.scheduler = scheduler;
        this.delay = delay;
      }
      ObserveOnOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
      };
      return ObserveOnOperator2;
    }();
    exports.ObserveOnOperator = ObserveOnOperator;
    var ObserveOnSubscriber = function(_super) {
      __extends(ObserveOnSubscriber2, _super);
      function ObserveOnSubscriber2(destination, scheduler, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        _super.call(this, destination);
        this.scheduler = scheduler;
        this.delay = delay;
      }
      ObserveOnSubscriber2.dispatch = function(arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
      };
      ObserveOnSubscriber2.prototype.scheduleMessage = function(notification) {
        this.add(this.scheduler.schedule(ObserveOnSubscriber2.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
      };
      ObserveOnSubscriber2.prototype._next = function(value) {
        this.scheduleMessage(Notification_1.Notification.createNext(value));
      };
      ObserveOnSubscriber2.prototype._error = function(err) {
        this.scheduleMessage(Notification_1.Notification.createError(err));
      };
      ObserveOnSubscriber2.prototype._complete = function() {
        this.scheduleMessage(Notification_1.Notification.createComplete());
      };
      return ObserveOnSubscriber2;
    }(Subscriber_1.Subscriber);
    exports.ObserveOnSubscriber = ObserveOnSubscriber;
    var ObserveOnMessage = function() {
      function ObserveOnMessage2(notification, destination) {
        this.notification = notification;
        this.destination = destination;
      }
      return ObserveOnMessage2;
    }();
    exports.ObserveOnMessage = ObserveOnMessage;
  }
});

// node_modules/rxjs/observable/FromObservable.js
var require_FromObservable = __commonJS({
  "node_modules/rxjs/observable/FromObservable.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var isArray_1 = require_isArray();
    var isArrayLike_1 = require_isArrayLike();
    var isPromise_1 = require_isPromise();
    var PromiseObservable_1 = require_PromiseObservable();
    var IteratorObservable_1 = require_IteratorObservable();
    var ArrayObservable_1 = require_ArrayObservable();
    var ArrayLikeObservable_1 = require_ArrayLikeObservable();
    var iterator_1 = require_iterator();
    var Observable_1 = require_Observable();
    var observeOn_1 = require_observeOn();
    var observable_1 = require_observable();
    var FromObservable = function(_super) {
      __extends(FromObservable2, _super);
      function FromObservable2(ish, scheduler) {
        _super.call(this, null);
        this.ish = ish;
        this.scheduler = scheduler;
      }
      FromObservable2.create = function(ish, scheduler) {
        if (ish != null) {
          if (typeof ish[observable_1.observable] === "function") {
            if (ish instanceof Observable_1.Observable && !scheduler) {
              return ish;
            }
            return new FromObservable2(ish, scheduler);
          } else if (isArray_1.isArray(ish)) {
            return new ArrayObservable_1.ArrayObservable(ish, scheduler);
          } else if (isPromise_1.isPromise(ish)) {
            return new PromiseObservable_1.PromiseObservable(ish, scheduler);
          } else if (typeof ish[iterator_1.iterator] === "function" || typeof ish === "string") {
            return new IteratorObservable_1.IteratorObservable(ish, scheduler);
          } else if (isArrayLike_1.isArrayLike(ish)) {
            return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);
          }
        }
        throw new TypeError((ish !== null && typeof ish || ish) + " is not observable");
      };
      FromObservable2.prototype._subscribe = function(subscriber) {
        var ish = this.ish;
        var scheduler = this.scheduler;
        if (scheduler == null) {
          return ish[observable_1.observable]().subscribe(subscriber);
        } else {
          return ish[observable_1.observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));
        }
      };
      return FromObservable2;
    }(Observable_1.Observable);
    exports.FromObservable = FromObservable;
  }
});

// node_modules/rxjs/observable/from.js
var require_from = __commonJS({
  "node_modules/rxjs/observable/from.js"(exports) {
    "use strict";
    var FromObservable_1 = require_FromObservable();
    exports.from = FromObservable_1.FromObservable.create;
  }
});

// node_modules/rxjs/add/observable/from.js
var require_from2 = __commonJS({
  "node_modules/rxjs/add/observable/from.js"() {
    "use strict";
    var Observable_1 = require_Observable();
    var from_1 = require_from();
    Observable_1.Observable.from = from_1.from;
  }
});

// node_modules/rxjs/util/isNumeric.js
var require_isNumeric = __commonJS({
  "node_modules/rxjs/util/isNumeric.js"(exports) {
    "use strict";
    var isArray_1 = require_isArray();
    function isNumeric(val) {
      return !isArray_1.isArray(val) && val - parseFloat(val) + 1 >= 0;
    }
    exports.isNumeric = isNumeric;
  }
});

// node_modules/rxjs/observable/IntervalObservable.js
var require_IntervalObservable = __commonJS({
  "node_modules/rxjs/observable/IntervalObservable.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var isNumeric_1 = require_isNumeric();
    var Observable_1 = require_Observable();
    var async_1 = require_async();
    var IntervalObservable = function(_super) {
      __extends(IntervalObservable2, _super);
      function IntervalObservable2(period, scheduler) {
        if (period === void 0) {
          period = 0;
        }
        if (scheduler === void 0) {
          scheduler = async_1.async;
        }
        _super.call(this);
        this.period = period;
        this.scheduler = scheduler;
        if (!isNumeric_1.isNumeric(period) || period < 0) {
          this.period = 0;
        }
        if (!scheduler || typeof scheduler.schedule !== "function") {
          this.scheduler = async_1.async;
        }
      }
      IntervalObservable2.create = function(period, scheduler) {
        if (period === void 0) {
          period = 0;
        }
        if (scheduler === void 0) {
          scheduler = async_1.async;
        }
        return new IntervalObservable2(period, scheduler);
      };
      IntervalObservable2.dispatch = function(state) {
        var index = state.index, subscriber = state.subscriber, period = state.period;
        subscriber.next(index);
        if (subscriber.closed) {
          return;
        }
        state.index += 1;
        this.schedule(state, period);
      };
      IntervalObservable2.prototype._subscribe = function(subscriber) {
        var index = 0;
        var period = this.period;
        var scheduler = this.scheduler;
        subscriber.add(scheduler.schedule(IntervalObservable2.dispatch, period, {
          index,
          subscriber,
          period
        }));
      };
      return IntervalObservable2;
    }(Observable_1.Observable);
    exports.IntervalObservable = IntervalObservable;
  }
});

// node_modules/rxjs/observable/interval.js
var require_interval = __commonJS({
  "node_modules/rxjs/observable/interval.js"(exports) {
    "use strict";
    var IntervalObservable_1 = require_IntervalObservable();
    exports.interval = IntervalObservable_1.IntervalObservable.create;
  }
});

// node_modules/rxjs/add/observable/interval.js
var require_interval2 = __commonJS({
  "node_modules/rxjs/add/observable/interval.js"() {
    "use strict";
    var Observable_1 = require_Observable();
    var interval_1 = require_interval();
    Observable_1.Observable.interval = interval_1.interval;
  }
});

// node_modules/rxjs/observable/of.js
var require_of = __commonJS({
  "node_modules/rxjs/observable/of.js"(exports) {
    "use strict";
    var ArrayObservable_1 = require_ArrayObservable();
    exports.of = ArrayObservable_1.ArrayObservable.of;
  }
});

// node_modules/rxjs/add/observable/of.js
var require_of2 = __commonJS({
  "node_modules/rxjs/add/observable/of.js"() {
    "use strict";
    var Observable_1 = require_Observable();
    var of_1 = require_of();
    Observable_1.Observable.of = of_1.of;
  }
});

// node_modules/rxjs/observable/ErrorObservable.js
var require_ErrorObservable = __commonJS({
  "node_modules/rxjs/observable/ErrorObservable.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var Observable_1 = require_Observable();
    var ErrorObservable = function(_super) {
      __extends(ErrorObservable2, _super);
      function ErrorObservable2(error, scheduler) {
        _super.call(this);
        this.error = error;
        this.scheduler = scheduler;
      }
      ErrorObservable2.create = function(error, scheduler) {
        return new ErrorObservable2(error, scheduler);
      };
      ErrorObservable2.dispatch = function(arg) {
        var error = arg.error, subscriber = arg.subscriber;
        subscriber.error(error);
      };
      ErrorObservable2.prototype._subscribe = function(subscriber) {
        var error = this.error;
        var scheduler = this.scheduler;
        subscriber.syncErrorThrowable = true;
        if (scheduler) {
          return scheduler.schedule(ErrorObservable2.dispatch, 0, {
            error,
            subscriber
          });
        } else {
          subscriber.error(error);
        }
      };
      return ErrorObservable2;
    }(Observable_1.Observable);
    exports.ErrorObservable = ErrorObservable;
  }
});

// node_modules/rxjs/observable/throw.js
var require_throw = __commonJS({
  "node_modules/rxjs/observable/throw.js"(exports) {
    "use strict";
    var ErrorObservable_1 = require_ErrorObservable();
    exports._throw = ErrorObservable_1.ErrorObservable.create;
  }
});

// node_modules/rxjs/add/observable/throw.js
var require_throw2 = __commonJS({
  "node_modules/rxjs/add/observable/throw.js"() {
    "use strict";
    var Observable_1 = require_Observable();
    var throw_1 = require_throw();
    Observable_1.Observable.throw = throw_1._throw;
  }
});

// node_modules/@babel/runtime/helpers/arrayWithHoles.js
var require_arrayWithHoles = __commonJS({
  "node_modules/@babel/runtime/helpers/arrayWithHoles.js"(exports, module) {
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    module.exports = _arrayWithHoles;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/iterableToArray.js
var require_iterableToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/iterableToArray.js"(exports, module) {
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    module.exports = _iterableToArray;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/arrayLikeToArray.js
var require_arrayLikeToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/arrayLikeToArray.js"(exports, module) {
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    module.exports = _arrayLikeToArray;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js
var require_unsupportedIterableToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js"(exports, module) {
    var arrayLikeToArray = require_arrayLikeToArray();
    function _unsupportedIterableToArray(o2, minLen) {
      if (!o2)
        return;
      if (typeof o2 === "string")
        return arrayLikeToArray(o2, minLen);
      var n2 = Object.prototype.toString.call(o2).slice(8, -1);
      if (n2 === "Object" && o2.constructor)
        n2 = o2.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return arrayLikeToArray(o2, minLen);
    }
    module.exports = _unsupportedIterableToArray;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/nonIterableRest.js
var require_nonIterableRest = __commonJS({
  "node_modules/@babel/runtime/helpers/nonIterableRest.js"(exports, module) {
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    module.exports = _nonIterableRest;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/toArray.js
var require_toArray = __commonJS({
  "node_modules/@babel/runtime/helpers/toArray.js"(exports, module) {
    var arrayWithHoles = require_arrayWithHoles();
    var iterableToArray = require_iterableToArray();
    var unsupportedIterableToArray = require_unsupportedIterableToArray();
    var nonIterableRest = require_nonIterableRest();
    function _toArray(arr) {
      return arrayWithHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableRest();
    }
    module.exports = _toArray;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/botframework-directlinejs/lib/parseFilename.js
var require_parseFilename = __commonJS({
  "node_modules/botframework-directlinejs/lib/parseFilename.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = parseFilename;
    var _toArray2 = _interopRequireDefault(require_toArray());
    function parseFilename(filename) {
      if (!filename) {
        return {
          extname: "",
          name: ""
        };
      } else if (~filename.indexOf(".")) {
        var _filename$split$rever = filename.split(".").reverse(), _filename$split$rever2 = (0, _toArray2["default"])(_filename$split$rever), extensionWithoutDot = _filename$split$rever2[0], nameSegments = _filename$split$rever2.slice(1);
        return {
          extname: "." + extensionWithoutDot,
          name: nameSegments.reverse().join(".")
        };
      } else {
        return {
          extname: "",
          name: filename
        };
      }
    }
  }
});

// node_modules/botframework-directlinejs/lib/dedupeFilenames.js
var require_dedupeFilenames = __commonJS({
  "node_modules/botframework-directlinejs/lib/dedupeFilenames.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = dedupeFilenames;
    var _parseFilename2 = _interopRequireDefault(require_parseFilename());
    function dedupeFilenames(array) {
      var nextArray = [];
      array.forEach(function(value) {
        var _parseFilename = (0, _parseFilename2["default"])(value), extname = _parseFilename.extname, name = _parseFilename.name;
        var count = 0;
        var nextValue = value;
        while (nextArray.includes(nextValue)) {
          nextValue = [name, "(".concat(++count, ")")].filter(function(segment) {
            return segment;
          }).join(" ") + extname;
        }
        nextArray.push(nextValue);
      });
      return nextArray;
    }
  }
});

// node_modules/regenerator-runtime/runtime.js
var require_runtime = __commonJS({
  "node_modules/regenerator-runtime/runtime.js"(exports, module) {
    var runtime = function(exports2) {
      "use strict";
      var Op = Object.prototype;
      var hasOwn = Op.hasOwnProperty;
      var defineProperty = Object.defineProperty || function(obj, key, desc) {
        obj[key] = desc.value;
      };
      var undefined2;
      var $Symbol = typeof Symbol === "function" ? Symbol : {};
      var iteratorSymbol = $Symbol.iterator || "@@iterator";
      var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
      var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define2(obj, key, value) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
        return obj[key];
      }
      try {
        define2({}, "");
      } catch (err) {
        define2 = function(obj, key, value) {
          return obj[key] = value;
        };
      }
      function wrap(innerFn, outerFn, self2, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
        var generator = Object.create(protoGenerator.prototype);
        var context = new Context(tryLocsList || []);
        defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self2, context) });
        return generator;
      }
      exports2.wrap = wrap;
      function tryCatch(fn, obj, arg) {
        try {
          return { type: "normal", arg: fn.call(obj, arg) };
        } catch (err) {
          return { type: "throw", arg: err };
        }
      }
      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed";
      var ContinueSentinel = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var IteratorPrototype = {};
      define2(IteratorPrototype, iteratorSymbol, function() {
        return this;
      });
      var getProto = Object.getPrototypeOf;
      var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
        IteratorPrototype = NativeIteratorPrototype;
      }
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      GeneratorFunction.prototype = GeneratorFunctionPrototype;
      defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: true });
      defineProperty(
        GeneratorFunctionPrototype,
        "constructor",
        { value: GeneratorFunction, configurable: true }
      );
      GeneratorFunction.displayName = define2(
        GeneratorFunctionPrototype,
        toStringTagSymbol,
        "GeneratorFunction"
      );
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
          define2(prototype, method, function(arg) {
            return this._invoke(method, arg);
          });
        });
      }
      exports2.isGeneratorFunction = function(genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };
      exports2.mark = function(genFun) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;
          define2(genFun, toStringTagSymbol, "GeneratorFunction");
        }
        genFun.prototype = Object.create(Gp);
        return genFun;
      };
      exports2.awrap = function(arg) {
        return { __await: arg };
      };
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);
          if (record.type === "throw") {
            reject(record.arg);
          } else {
            var result = record.arg;
            var value = result.value;
            if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
              return PromiseImpl.resolve(value.__await).then(function(value2) {
                invoke("next", value2, resolve, reject);
              }, function(err) {
                invoke("throw", err, resolve, reject);
              });
            }
            return PromiseImpl.resolve(value).then(function(unwrapped) {
              result.value = unwrapped;
              resolve(result);
            }, function(error) {
              return invoke("throw", error, resolve, reject);
            });
          }
        }
        var previousPromise;
        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function(resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(
            callInvokeWithMethodAndArg,
            callInvokeWithMethodAndArg
          ) : callInvokeWithMethodAndArg();
        }
        defineProperty(this, "_invoke", { value: enqueue });
      }
      defineIteratorMethods(AsyncIterator.prototype);
      define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
      });
      exports2.AsyncIterator = AsyncIterator;
      exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
        if (PromiseImpl === void 0)
          PromiseImpl = Promise;
        var iter = new AsyncIterator(
          wrap(innerFn, outerFn, self2, tryLocsList),
          PromiseImpl
        );
        return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      };
      function makeInvokeMethod(innerFn, self2, context) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }
          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            }
            return doneResult();
          }
          context.method = method;
          context.arg = arg;
          while (true) {
            var delegate = context.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel)
                  continue;
                return delegateResult;
              }
            }
            if (context.method === "next") {
              context.sent = context._sent = context.arg;
            } else if (context.method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw context.arg;
              }
              context.dispatchException(context.arg);
            } else if (context.method === "return") {
              context.abrupt("return", context.arg);
            }
            state = GenStateExecuting;
            var record = tryCatch(innerFn, self2, context);
            if (record.type === "normal") {
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;
              if (record.arg === ContinueSentinel) {
                continue;
              }
              return {
                value: record.arg,
                done: context.done
              };
            } else if (record.type === "throw") {
              state = GenStateCompleted;
              context.method = "throw";
              context.arg = record.arg;
            }
          }
        };
      }
      function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];
        if (method === undefined2) {
          context.delegate = null;
          if (context.method === "throw") {
            if (delegate.iterator["return"]) {
              context.method = "return";
              context.arg = undefined2;
              maybeInvokeDelegate(delegate, context);
              if (context.method === "throw") {
                return ContinueSentinel;
              }
            }
            context.method = "throw";
            context.arg = new TypeError(
              "The iterator does not provide a 'throw' method"
            );
          }
          return ContinueSentinel;
        }
        var record = tryCatch(method, delegate.iterator, context.arg);
        if (record.type === "throw") {
          context.method = "throw";
          context.arg = record.arg;
          context.delegate = null;
          return ContinueSentinel;
        }
        var info = record.arg;
        if (!info) {
          context.method = "throw";
          context.arg = new TypeError("iterator result is not an object");
          context.delegate = null;
          return ContinueSentinel;
        }
        if (info.done) {
          context[delegate.resultName] = info.value;
          context.next = delegate.nextLoc;
          if (context.method !== "return") {
            context.method = "next";
            context.arg = undefined2;
          }
        } else {
          return info;
        }
        context.delegate = null;
        return ContinueSentinel;
      }
      defineIteratorMethods(Gp);
      define2(Gp, toStringTagSymbol, "Generator");
      define2(Gp, iteratorSymbol, function() {
        return this;
      });
      define2(Gp, "toString", function() {
        return "[object Generator]";
      });
      function pushTryEntry(locs) {
        var entry = { tryLoc: locs[0] };
        if (1 in locs) {
          entry.catchLoc = locs[1];
        }
        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }
        this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{ tryLoc: "root" }];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }
      exports2.keys = function(val) {
        var object = Object(val);
        var keys = [];
        for (var key in object) {
          keys.push(key);
        }
        keys.reverse();
        return function next() {
          while (keys.length) {
            var key2 = keys.pop();
            if (key2 in object) {
              next.value = key2;
              next.done = false;
              return next;
            }
          }
          next.done = true;
          return next;
        };
      };
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }
          if (typeof iterable.next === "function") {
            return iterable;
          }
          if (!isNaN(iterable.length)) {
            var i = -1, next = function next2() {
              while (++i < iterable.length) {
                if (hasOwn.call(iterable, i)) {
                  next2.value = iterable[i];
                  next2.done = false;
                  return next2;
                }
              }
              next2.value = undefined2;
              next2.done = true;
              return next2;
            };
            return next.next = next;
          }
        }
        return { next: doneResult };
      }
      exports2.values = values;
      function doneResult() {
        return { value: undefined2, done: true };
      }
      Context.prototype = {
        constructor: Context,
        reset: function(skipTempReset) {
          this.prev = 0;
          this.next = 0;
          this.sent = this._sent = undefined2;
          this.done = false;
          this.delegate = null;
          this.method = "next";
          this.arg = undefined2;
          this.tryEntries.forEach(resetTryEntry);
          if (!skipTempReset) {
            for (var name in this) {
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined2;
              }
            }
          }
        },
        stop: function() {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;
          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }
          return this.rval;
        },
        dispatchException: function(exception) {
          if (this.done) {
            throw exception;
          }
          var context = this;
          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;
            if (caught) {
              context.method = "next";
              context.arg = undefined2;
            }
            return !!caught;
          }
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            var record = entry.completion;
            if (entry.tryLoc === "root") {
              return handle("end");
            }
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },
        abrupt: function(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            finallyEntry = null;
          }
          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;
          if (finallyEntry) {
            this.method = "next";
            this.next = finallyEntry.finallyLoc;
            return ContinueSentinel;
          }
          return this.complete(record);
        },
        complete: function(record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }
          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = this.arg = record.arg;
            this.method = "return";
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }
          return ContinueSentinel;
        },
        finish: function(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },
        "catch": function(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function(iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName,
            nextLoc
          };
          if (this.method === "next") {
            this.arg = undefined2;
          }
          return ContinueSentinel;
        }
      };
      return exports2;
    }(
      typeof module === "object" ? module.exports : {}
    );
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// node_modules/@babel/runtime/regenerator/index.js
var require_regenerator = __commonJS({
  "node_modules/@babel/runtime/regenerator/index.js"(exports, module) {
    module.exports = require_runtime();
  }
});

// node_modules/@babel/runtime/helpers/arrayWithoutHoles.js
var require_arrayWithoutHoles = __commonJS({
  "node_modules/@babel/runtime/helpers/arrayWithoutHoles.js"(exports, module) {
    var arrayLikeToArray = require_arrayLikeToArray();
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return arrayLikeToArray(arr);
    }
    module.exports = _arrayWithoutHoles;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/nonIterableSpread.js
var require_nonIterableSpread = __commonJS({
  "node_modules/@babel/runtime/helpers/nonIterableSpread.js"(exports, module) {
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    module.exports = _nonIterableSpread;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/toConsumableArray.js
var require_toConsumableArray = __commonJS({
  "node_modules/@babel/runtime/helpers/toConsumableArray.js"(exports, module) {
    var arrayWithoutHoles = require_arrayWithoutHoles();
    var iterableToArray = require_iterableToArray();
    var unsupportedIterableToArray = require_unsupportedIterableToArray();
    var nonIterableSpread = require_nonIterableSpread();
    function _toConsumableArray(arr) {
      return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
    }
    module.exports = _toConsumableArray;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/@babel/runtime/helpers/asyncToGenerator.js
var require_asyncToGenerator = __commonJS({
  "node_modules/@babel/runtime/helpers/asyncToGenerator.js"(exports, module) {
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    module.exports = _asyncToGenerator;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e2, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e2 = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e2 = e2 * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e2 & (1 << -nBits) - 1;
      e2 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e2 === 0) {
        e2 = 1 - eBias;
      } else if (e2 === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e2 = e2 - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e2 - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e2, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e2 = eMax;
      } else {
        e2 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e2)) < 1) {
          e2--;
          c *= 2;
        }
        if (e2 + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e2++;
          c /= 2;
        }
        if (e2 + eBias >= eMax) {
          m = 0;
          e2 = eMax;
        } else if (e2 + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e2 = e2 + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e2 = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e2 = e2 << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e2 & 255, i += d, e2 /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e2) {
        return false;
      }
    }
    Object.defineProperty(Buffer.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer.prototype);
      return buf;
    }
    function Buffer(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer.alloc(+length);
    }
    Buffer.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer.prototype;
    };
    Buffer.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer.from(b, b.offset, b.byteLength);
      if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b)
        return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer = Buffer.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer.isBuffer(buf))
              buf = Buffer.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer.prototype._isBuffer = true;
    function swap(b, n2, m) {
      const i = b[n2];
      b[n2] = b[m];
      b[m] = i;
    }
    Buffer.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer.prototype.toLocaleString = Buffer.prototype.toString;
    Buffer.prototype.equals = function equals(b) {
      if (!Buffer.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer.compare(this, b) === 0;
    };
    Buffer.prototype.inspect = function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
    }
    Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer.from(target, target.offset, target.byteLength);
      }
      if (!Buffer.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer.from(val, encoding);
      }
      if (Buffer.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n2 = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n2} and < 2${n2} ** ${(byteLength2 + 1) * 8}${n2}`;
          } else {
            range = `>= -(2${n2} ** ${(byteLength2 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n2}`;
          }
        } else {
          range = `>= ${min}${n2} and <= ${max}${n2}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/botframework-streaming/lib/index-browser.js
var require_index_browser = __commonJS({
  "node_modules/botframework-streaming/lib/index-browser.js"(exports, module) {
    (function(f) {
      if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = f();
      } else if (typeof define === "function" && define.amd) {
        define([], f);
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window;
        } else if (typeof global !== "undefined") {
          g = global;
        } else if (typeof self !== "undefined") {
          g = self;
        } else {
          g = this;
        }
        g.BFSE = f();
      }
    })(function() {
      var define2, module2, exports2;
      return function() {
        function r2(e2, n2, t2) {
          function o2(i2, f) {
            if (!n2[i2]) {
              if (!e2[i2]) {
                var c = "function" == typeof __require && __require;
                if (!f && c)
                  return c(i2, true);
                if (u)
                  return u(i2, true);
                var a = new Error("Cannot find module '" + i2 + "'");
                throw a.code = "MODULE_NOT_FOUND", a;
              }
              var p = n2[i2] = { exports: {} };
              e2[i2][0].call(p.exports, function(r3) {
                var n3 = e2[i2][1][r3];
                return o2(n3 || r3);
              }, p, p.exports, r2, e2, n2, t2);
            }
            return n2[i2].exports;
          }
          for (var u = "function" == typeof __require && __require, i = 0; i < t2.length; i++)
            o2(t2[i]);
          return o2;
        }
        return r2;
      }()({ 1: [function(require2, module3, exports3) {
        "use strict";
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e2) {
                reject(e2);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e2) {
                reject(e2);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        var __generator = this && this.__generator || function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t2[0] & 1)
              throw t2[1];
            return t2[1];
          }, trys: [], ops: [] }, f, y, t2, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n2) {
            return function(v) {
              return step([n2, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
                  return t2;
                if (y = 0, t2)
                  op = [op[0] & 2, t2.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t2 = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t2[1]) {
                      _.label = t2[1];
                      t2 = op;
                      break;
                    }
                    if (t2 && _.label < t2[2]) {
                      _.label = t2[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t2[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e2) {
                op = [6, e2];
                y = 0;
              } finally {
                f = t2 = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.PayloadAssembler = void 0;
        var subscribableStream_1 = require2("../subscribableStream");
        var payloads_1 = require2("../payloads");
        var contentStream_1 = require2("../contentStream");
        var PayloadAssembler = function() {
          function PayloadAssembler2(streamManager, params) {
            this.streamManager = streamManager;
            this._byteOrderMark = 65279;
            this._utf = "utf8";
            if (params.header) {
              this.id = params.header.id;
              this.payloadType = params.header.payloadType;
              this.contentLength = params.header.payloadLength;
              this.end = params.header.end;
            } else {
              this.id = params.id;
            }
            if (!this.id) {
              throw Error("An ID must be supplied when creating an assembler.");
            }
            this._onCompleted = params.onCompleted;
          }
          PayloadAssembler2.prototype.getPayloadStream = function() {
            if (!this.stream) {
              this.stream = this.createPayloadStream();
            }
            return this.stream;
          };
          PayloadAssembler2.prototype.onReceive = function(header, stream, _contentLength) {
            this.end = header.end;
            if (header.payloadType === payloads_1.PayloadTypes.response || header.payloadType === payloads_1.PayloadTypes.request) {
              this.process(stream).then().catch();
            } else if (header.end) {
              stream.end();
            }
          };
          PayloadAssembler2.prototype.close = function() {
            this.streamManager.closeStream(this.id);
          };
          PayloadAssembler2.prototype.createPayloadStream = function() {
            return new subscribableStream_1.SubscribableStream();
          };
          PayloadAssembler2.prototype.payloadFromJson = function(json) {
            return JSON.parse(json.charCodeAt(0) === this._byteOrderMark ? json.slice(1) : json);
          };
          PayloadAssembler2.prototype.stripBOM = function(input) {
            return input.charCodeAt(0) === this._byteOrderMark ? input.slice(1) : input;
          };
          PayloadAssembler2.prototype.process = function(stream) {
            return __awaiter(this, void 0, void 0, function() {
              var streamData, streamDataAsString;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    streamData = stream.read(stream.length);
                    if (!streamData) {
                      return [2];
                    }
                    streamDataAsString = streamData.toString(this._utf);
                    if (!(this.payloadType === payloads_1.PayloadTypes.request))
                      return [3, 2];
                    return [4, this.processRequest(streamDataAsString)];
                  case 1:
                    _a.sent();
                    return [3, 4];
                  case 2:
                    if (!(this.payloadType === payloads_1.PayloadTypes.response))
                      return [3, 4];
                    return [4, this.processResponse(streamDataAsString)];
                  case 3:
                    _a.sent();
                    _a.label = 4;
                  case 4:
                    return [2];
                }
              });
            });
          };
          PayloadAssembler2.prototype.processResponse = function(streamDataAsString) {
            return __awaiter(this, void 0, void 0, function() {
              var responsePayload, receiveResponse;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    responsePayload = this.payloadFromJson(this.stripBOM(streamDataAsString));
                    receiveResponse = { streams: [], statusCode: responsePayload.statusCode };
                    return [4, this.processStreams(responsePayload, receiveResponse)];
                  case 1:
                    _a.sent();
                    return [2];
                }
              });
            });
          };
          PayloadAssembler2.prototype.processRequest = function(streamDataAsString) {
            return __awaiter(this, void 0, void 0, function() {
              var requestPayload, receiveRequest;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    requestPayload = this.payloadFromJson(streamDataAsString);
                    receiveRequest = { streams: [], path: requestPayload.path, verb: requestPayload.verb };
                    return [4, this.processStreams(requestPayload, receiveRequest)];
                  case 1:
                    _a.sent();
                    return [2];
                }
              });
            });
          };
          PayloadAssembler2.prototype.processStreams = function(responsePayload, receiveResponse) {
            return __awaiter(this, void 0, void 0, function() {
              var _this = this;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    if (responsePayload.streams) {
                      responsePayload.streams.forEach(function(responseStream) {
                        var contentAssembler = _this.streamManager.getPayloadAssembler(responseStream.id);
                        contentAssembler.payloadType = responseStream.contentType;
                        contentAssembler.contentLength = responseStream.length;
                        receiveResponse.streams.push(new contentStream_1.ContentStream(responseStream.id, contentAssembler));
                      });
                    }
                    return [4, this._onCompleted(this.id, receiveResponse)];
                  case 1:
                    _a.sent();
                    return [2];
                }
              });
            });
          };
          return PayloadAssembler2;
        }();
        exports3.PayloadAssembler = PayloadAssembler;
      }, { "../contentStream": 2, "../payloads": 16, "../subscribableStream": 27 }], 2: [function(require2, module3, exports3) {
        "use strict";
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e2) {
                reject(e2);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e2) {
                reject(e2);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        var __generator = this && this.__generator || function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t2[0] & 1)
              throw t2[1];
            return t2[1];
          }, trys: [], ops: [] }, f, y, t2, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n2) {
            return function(v) {
              return step([n2, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
                  return t2;
                if (y = 0, t2)
                  op = [op[0] & 2, t2.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t2 = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t2[1]) {
                      _.label = t2[1];
                      t2 = op;
                      break;
                    }
                    if (t2 && _.label < t2[2]) {
                      _.label = t2[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t2[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e2) {
                op = [6, e2];
                y = 0;
              } finally {
                f = t2 = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.ContentStream = void 0;
        var ContentStream = function() {
          function ContentStream2(id, assembler) {
            if (!assembler) {
              throw Error("Null Argument Exception");
            }
            this.id = id;
            this.assembler = assembler;
          }
          Object.defineProperty(ContentStream2.prototype, "contentType", {
            get: function() {
              return this.assembler.payloadType;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(ContentStream2.prototype, "length", {
            get: function() {
              return this.assembler.contentLength;
            },
            enumerable: false,
            configurable: true
          });
          ContentStream2.prototype.getStream = function() {
            if (!this.stream) {
              this.stream = this.assembler.getPayloadStream();
            }
            return this.stream;
          };
          ContentStream2.prototype.cancel = function() {
            this.assembler.close();
          };
          ContentStream2.prototype.readAsString = function() {
            return __awaiter(this, void 0, void 0, function() {
              var bufferArray;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.readAll()];
                  case 1:
                    bufferArray = _a.sent().bufferArray;
                    return [2, (bufferArray || []).map(function(result) {
                      return result.toString("utf8");
                    }).join("")];
                }
              });
            });
          };
          ContentStream2.prototype.readAsJson = function() {
            return __awaiter(this, void 0, void 0, function() {
              var stringToParse;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.readAsString()];
                  case 1:
                    stringToParse = _a.sent();
                    return [2, JSON.parse(stringToParse)];
                }
              });
            });
          };
          ContentStream2.prototype.readAll = function() {
            return __awaiter(this, void 0, void 0, function() {
              var allData, count, stream, chunk, readToEnd;
              var _this = this;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    allData = [];
                    count = 0;
                    stream = this.getStream();
                    while (count < stream.length) {
                      chunk = stream.read(stream.length);
                      allData.push(chunk);
                      count += chunk.length;
                    }
                    if (!(count < this.length))
                      return [3, 2];
                    readToEnd = new Promise(function(resolve) {
                      var callback = function(cs) {
                        return function(chunk2) {
                          allData.push(chunk2);
                          count += chunk2.length;
                          if (count === cs.length) {
                            resolve(true);
                          }
                        };
                      };
                      stream.subscribe(callback(_this));
                    });
                    return [4, readToEnd];
                  case 1:
                    _a.sent();
                    _a.label = 2;
                  case 2:
                    return [2, { bufferArray: allData, size: count }];
                }
              });
            });
          };
          return ContentStream2;
        }();
        exports3.ContentStream = ContentStream;
      }, {}], 3: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.CancelDisassembler = void 0;
        var CancelDisassembler = function() {
          function CancelDisassembler2(sender, id, payloadType) {
            this.sender = sender;
            this.id = id;
            this.payloadType = payloadType;
          }
          CancelDisassembler2.prototype.disassemble = function() {
            var header = {
              payloadType: this.payloadType,
              payloadLength: 0,
              id: this.id,
              end: true
            };
            this.sender.sendPayload(header);
          };
          return CancelDisassembler2;
        }();
        exports3.CancelDisassembler = CancelDisassembler;
      }, {}], 4: [function(require2, module3, exports3) {
        "use strict";
        var __extends = this && this.__extends || function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e2) {
                reject(e2);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e2) {
                reject(e2);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        var __generator = this && this.__generator || function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t2[0] & 1)
              throw t2[1];
            return t2[1];
          }, trys: [], ops: [] }, f, y, t2, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n2) {
            return function(v) {
              return step([n2, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
                  return t2;
                if (y = 0, t2)
                  op = [op[0] & 2, t2.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t2 = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t2[1]) {
                      _.label = t2[1];
                      t2 = op;
                      break;
                    }
                    if (t2 && _.label < t2[2]) {
                      _.label = t2[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t2[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e2) {
                op = [6, e2];
                y = 0;
              } finally {
                f = t2 = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.HttpContentStreamDisassembler = void 0;
        var payloadDisassembler_1 = require2("./payloadDisassembler");
        var payloads_1 = require2("../payloads");
        var HttpContentStreamDisassembler = function(_super) {
          __extends(HttpContentStreamDisassembler2, _super);
          function HttpContentStreamDisassembler2(sender, contentStream) {
            var _this = _super.call(this, sender, contentStream.id) || this;
            _this.payloadType = payloads_1.PayloadTypes.stream;
            _this.contentStream = contentStream;
            return _this;
          }
          HttpContentStreamDisassembler2.prototype.getStream = function() {
            return __awaiter(this, void 0, void 0, function() {
              var stream;
              return __generator(this, function(_a) {
                stream = this.contentStream.content.getStream();
                return [2, { stream, streamLength: stream.length }];
              });
            });
          };
          return HttpContentStreamDisassembler2;
        }(payloadDisassembler_1.PayloadDisassembler);
        exports3.HttpContentStreamDisassembler = HttpContentStreamDisassembler;
      }, { "../payloads": 16, "./payloadDisassembler": 5 }], 5: [function(require2, module3, exports3) {
        "use strict";
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e2) {
                reject(e2);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e2) {
                reject(e2);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        var __generator = this && this.__generator || function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t2[0] & 1)
              throw t2[1];
            return t2[1];
          }, trys: [], ops: [] }, f, y, t2, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n2) {
            return function(v) {
              return step([n2, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
                  return t2;
                if (y = 0, t2)
                  op = [op[0] & 2, t2.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t2 = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t2[1]) {
                      _.label = t2[1];
                      t2 = op;
                      break;
                    }
                    if (t2 && _.label < t2[2]) {
                      _.label = t2[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t2[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e2) {
                op = [6, e2];
                y = 0;
              } finally {
                f = t2 = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.PayloadDisassembler = void 0;
        var subscribableStream_1 = require2("../subscribableStream");
        var PayloadDisassembler = function() {
          function PayloadDisassembler2(sender, id) {
            this.sender = sender;
            this.id = id;
          }
          PayloadDisassembler2.serialize = function(item) {
            var stream = new subscribableStream_1.SubscribableStream();
            stream.write(JSON.stringify(item));
            stream.end();
            return { stream, streamLength: stream.length };
          };
          PayloadDisassembler2.prototype.disassemble = function() {
            return __awaiter(this, void 0, void 0, function() {
              var _a, stream, streamLength;
              return __generator(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    return [4, this.getStream()];
                  case 1:
                    _a = _b.sent(), stream = _a.stream, streamLength = _a.streamLength;
                    this.stream = stream;
                    this.streamLength = streamLength;
                    return [2, this.send()];
                }
              });
            });
          };
          PayloadDisassembler2.prototype.send = function() {
            return __awaiter(this, void 0, void 0, function() {
              var header;
              return __generator(this, function(_a) {
                header = {
                  payloadType: this.payloadType,
                  payloadLength: this.streamLength,
                  id: this.id,
                  end: true
                };
                this.sender.sendPayload(header, this.stream);
                return [2];
              });
            });
          };
          return PayloadDisassembler2;
        }();
        exports3.PayloadDisassembler = PayloadDisassembler;
      }, { "../subscribableStream": 27 }], 6: [function(require2, module3, exports3) {
        "use strict";
        var __extends = this && this.__extends || function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e2) {
                reject(e2);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e2) {
                reject(e2);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        var __generator = this && this.__generator || function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t2[0] & 1)
              throw t2[1];
            return t2[1];
          }, trys: [], ops: [] }, f, y, t2, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n2) {
            return function(v) {
              return step([n2, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
                  return t2;
                if (y = 0, t2)
                  op = [op[0] & 2, t2.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t2 = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t2[1]) {
                      _.label = t2[1];
                      t2 = op;
                      break;
                    }
                    if (t2 && _.label < t2[2]) {
                      _.label = t2[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t2[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e2) {
                op = [6, e2];
                y = 0;
              } finally {
                f = t2 = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.RequestDisassembler = void 0;
        var payloadTypes_1 = require2("../payloads/payloadTypes");
        var payloadDisassembler_1 = require2("./payloadDisassembler");
        var RequestDisassembler = function(_super) {
          __extends(RequestDisassembler2, _super);
          function RequestDisassembler2(sender, id, request) {
            var _this = _super.call(this, sender, id) || this;
            _this.request = request;
            _this.payloadType = payloadTypes_1.PayloadTypes.request;
            return _this;
          }
          RequestDisassembler2.prototype.getStream = function() {
            var _a, _b, _c, _d;
            return __awaiter(this, void 0, void 0, function() {
              var payload;
              return __generator(this, function(_e) {
                payload = { verb: (_a = this.request) === null || _a === void 0 ? void 0 : _a.verb, path: (_b = this.request) === null || _b === void 0 ? void 0 : _b.path, streams: [] };
                (_d = (_c = this.request) === null || _c === void 0 ? void 0 : _c.streams) === null || _d === void 0 ? void 0 : _d.forEach(function(stream) {
                  payload.streams.push(stream.description);
                });
                return [2, payloadDisassembler_1.PayloadDisassembler.serialize(payload)];
              });
            });
          };
          return RequestDisassembler2;
        }(payloadDisassembler_1.PayloadDisassembler);
        exports3.RequestDisassembler = RequestDisassembler;
      }, { "../payloads/payloadTypes": 19, "./payloadDisassembler": 5 }], 7: [function(require2, module3, exports3) {
        "use strict";
        var __extends = this && this.__extends || function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e2) {
                reject(e2);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e2) {
                reject(e2);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        var __generator = this && this.__generator || function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t2[0] & 1)
              throw t2[1];
            return t2[1];
          }, trys: [], ops: [] }, f, y, t2, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n2) {
            return function(v) {
              return step([n2, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
                  return t2;
                if (y = 0, t2)
                  op = [op[0] & 2, t2.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t2 = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t2[1]) {
                      _.label = t2[1];
                      t2 = op;
                      break;
                    }
                    if (t2 && _.label < t2[2]) {
                      _.label = t2[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t2[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e2) {
                op = [6, e2];
                y = 0;
              } finally {
                f = t2 = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.ResponseDisassembler = void 0;
        var payloadTypes_1 = require2("../payloads/payloadTypes");
        var payloadDisassembler_1 = require2("./payloadDisassembler");
        var ResponseDisassembler = function(_super) {
          __extends(ResponseDisassembler2, _super);
          function ResponseDisassembler2(sender, id, response) {
            var _this = _super.call(this, sender, id) || this;
            _this.payloadType = payloadTypes_1.PayloadTypes.response;
            _this.response = response;
            return _this;
          }
          ResponseDisassembler2.prototype.getStream = function() {
            return __awaiter(this, void 0, void 0, function() {
              var payload;
              return __generator(this, function(_a) {
                payload = { statusCode: this.response.statusCode, streams: [] };
                if (this.response.streams) {
                  this.response.streams.forEach(function(stream) {
                    payload.streams.push(stream.description);
                  });
                }
                return [2, payloadDisassembler_1.PayloadDisassembler.serialize(payload)];
              });
            });
          };
          return ResponseDisassembler2;
        }(payloadDisassembler_1.PayloadDisassembler);
        exports3.ResponseDisassembler = ResponseDisassembler;
      }, { "../payloads/payloadTypes": 19, "./payloadDisassembler": 5 }], 8: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.HttpContent = exports3.HttpContentStream = void 0;
        var protocol_base_1 = require2("./utilities/protocol-base");
        var HttpContentStream = function() {
          function HttpContentStream2(content) {
            var _a, _b, _c, _d, _e, _f;
            this.content = content;
            this.id = protocol_base_1.generateGuid();
            this.description = {
              id: this.id,
              type: (_c = (_b = (_a = this.content) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b.type) !== null && _c !== void 0 ? _c : "unknown",
              length: (_f = (_e = (_d = this.content) === null || _d === void 0 ? void 0 : _d.headers) === null || _e === void 0 ? void 0 : _e.contentLength) !== null && _f !== void 0 ? _f : 0
            };
          }
          return HttpContentStream2;
        }();
        exports3.HttpContentStream = HttpContentStream;
        var HttpContent = function() {
          function HttpContent2(headers, stream) {
            this.headers = headers;
            this.stream = stream;
          }
          HttpContent2.prototype.getStream = function() {
            return this.stream;
          };
          return HttpContent2;
        }();
        exports3.HttpContent = HttpContent;
      }, { "./utilities/protocol-base": 28 }], 9: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.WebSocketClient = exports3.BrowserWebSocket = exports3.SubscribableStream = exports3.StreamingResponse = exports3.StreamingRequest = exports3.RequestHandler = exports3.HttpContent = exports3.ContentStream = void 0;
        var contentStream_1 = require2("./contentStream");
        Object.defineProperty(exports3, "ContentStream", { enumerable: true, get: function() {
          return contentStream_1.ContentStream;
        } });
        var httpContentStream_1 = require2("./httpContentStream");
        Object.defineProperty(exports3, "HttpContent", { enumerable: true, get: function() {
          return httpContentStream_1.HttpContent;
        } });
        var requestHandler_1 = require2("./requestHandler");
        Object.defineProperty(exports3, "RequestHandler", { enumerable: true, get: function() {
          return requestHandler_1.RequestHandler;
        } });
        var streamingRequest_1 = require2("./streamingRequest");
        Object.defineProperty(exports3, "StreamingRequest", { enumerable: true, get: function() {
          return streamingRequest_1.StreamingRequest;
        } });
        var streamingResponse_1 = require2("./streamingResponse");
        Object.defineProperty(exports3, "StreamingResponse", { enumerable: true, get: function() {
          return streamingResponse_1.StreamingResponse;
        } });
        var subscribableStream_1 = require2("./subscribableStream");
        Object.defineProperty(exports3, "SubscribableStream", { enumerable: true, get: function() {
          return subscribableStream_1.SubscribableStream;
        } });
        var index_browser_1 = require2("./webSocket/index-browser");
        Object.defineProperty(exports3, "BrowserWebSocket", { enumerable: true, get: function() {
          return index_browser_1.BrowserWebSocket;
        } });
        Object.defineProperty(exports3, "WebSocketClient", { enumerable: true, get: function() {
          return index_browser_1.WebSocketClient;
        } });
      }, { "./contentStream": 2, "./httpContentStream": 8, "./requestHandler": 24, "./streamingRequest": 25, "./streamingResponse": 26, "./subscribableStream": 27, "./webSocket/index-browser": 31 }], 10: [function(require2, module3, exports3) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(o2, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          Object.defineProperty(o2, k2, { enumerable: true, get: function() {
            return m[k];
          } });
        } : function(o2, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o2[k2] = m[k];
        });
        var __exportStar = this && this.__exportStar || function(m, exports4) {
          for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports4, p))
              __createBinding(exports4, m, p);
        };
        Object.defineProperty(exports3, "__esModule", { value: true });
        __exportStar(require2("./payloadReceiver"), exports3);
        __exportStar(require2("./payloadSender"), exports3);
        __exportStar(require2("./transportDisconnectedEvent"), exports3);
        __exportStar(require2("./transportDisconnectedEventHandler"), exports3);
      }, { "./payloadReceiver": 11, "./payloadSender": 12, "./transportDisconnectedEvent": 13, "./transportDisconnectedEventHandler": 14 }], 11: [function(require2, module3, exports3) {
        "use strict";
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e2) {
                reject(e2);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e2) {
                reject(e2);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        var __generator = this && this.__generator || function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t2[0] & 1)
              throw t2[1];
            return t2[1];
          }, trys: [], ops: [] }, f, y, t2, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n2) {
            return function(v) {
              return step([n2, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
                  return t2;
                if (y = 0, t2)
                  op = [op[0] & 2, t2.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t2 = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t2[1]) {
                      _.label = t2[1];
                      t2 = op;
                      break;
                    }
                    if (t2 && _.label < t2[2]) {
                      _.label = t2[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t2[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e2) {
                op = [6, e2];
                y = 0;
              } finally {
                f = t2 = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.PayloadReceiver = void 0;
        var payloadTypes_1 = require2("../payloads/payloadTypes");
        var headerSerializer_1 = require2("../payloads/headerSerializer");
        var payloadConstants_1 = require2("../payloads/payloadConstants");
        var transportDisconnectedEvent_1 = require2("./transportDisconnectedEvent");
        var PayloadReceiver = function() {
          function PayloadReceiver2() {
          }
          Object.defineProperty(PayloadReceiver2.prototype, "isConnected", {
            get: function() {
              return this._receiver != null;
            },
            enumerable: false,
            configurable: true
          });
          PayloadReceiver2.prototype.connect = function(receiver) {
            this._receiver = receiver;
            return this.receivePackets();
          };
          PayloadReceiver2.prototype.subscribe = function(getStream, receiveAction) {
            this._getStream = getStream;
            this._receiveAction = receiveAction;
          };
          PayloadReceiver2.prototype.disconnect = function(event) {
            var _a, _b;
            if (event === void 0) {
              event = transportDisconnectedEvent_1.TransportDisconnectedEvent.Empty;
            }
            if (!this.isConnected) {
              return;
            }
            try {
              this._receiver.close();
              (_a = this.disconnected) === null || _a === void 0 ? void 0 : _a.call(this, this, event);
            } catch (err) {
              (_b = this.disconnected) === null || _b === void 0 ? void 0 : _b.call(this, this, new transportDisconnectedEvent_1.TransportDisconnectedEvent(err.message));
            } finally {
              this._receiver = null;
            }
          };
          PayloadReceiver2.prototype.receivePackets = function() {
            return __awaiter(this, void 0, void 0, function() {
              var readSoFar, _a, header, isStream, bytesActuallyRead, contentStream, count, _b, err_1;
              return __generator(this, function(_c) {
                switch (_c.label) {
                  case 0:
                    if (!this.isConnected)
                      return [3, 11];
                    _c.label = 1;
                  case 1:
                    _c.trys.push([1, 9, , 10]);
                    readSoFar = 0;
                    _c.label = 2;
                  case 2:
                    if (!(readSoFar < payloadConstants_1.PayloadConstants.MaxHeaderLength))
                      return [3, 4];
                    _a = this;
                    return [4, this._receiver.receive(payloadConstants_1.PayloadConstants.MaxHeaderLength - readSoFar)];
                  case 3:
                    _a._receiveHeaderBuffer = _c.sent();
                    if (this._receiveHeaderBuffer) {
                      readSoFar += this._receiveHeaderBuffer.length;
                    }
                    return [3, 2];
                  case 4:
                    header = headerSerializer_1.HeaderSerializer.deserialize(this._receiveHeaderBuffer);
                    isStream = header.payloadType === payloadTypes_1.PayloadTypes.stream;
                    if (!(header.payloadLength > 0))
                      return [3, 8];
                    bytesActuallyRead = 0;
                    contentStream = this._getStream(header);
                    _c.label = 5;
                  case 5:
                    if (!(bytesActuallyRead < header.payloadLength && bytesActuallyRead < payloadConstants_1.PayloadConstants.MaxPayloadLength))
                      return [3, 7];
                    count = Math.min(header.payloadLength - bytesActuallyRead, payloadConstants_1.PayloadConstants.MaxPayloadLength);
                    _b = this;
                    return [4, this._receiver.receive(count)];
                  case 6:
                    _b._receivePayloadBuffer = _c.sent();
                    bytesActuallyRead += this._receivePayloadBuffer.byteLength;
                    contentStream.write(this._receivePayloadBuffer);
                    if (isStream) {
                      this._receiveAction(header, contentStream, bytesActuallyRead);
                    }
                    return [3, 5];
                  case 7:
                    if (!isStream) {
                      this._receiveAction(header, contentStream, bytesActuallyRead);
                    }
                    _c.label = 8;
                  case 8:
                    return [3, 10];
                  case 9:
                    err_1 = _c.sent();
                    this.disconnect(new transportDisconnectedEvent_1.TransportDisconnectedEvent(err_1.message));
                    return [3, 10];
                  case 10:
                    return [3, 0];
                  case 11:
                    return [2];
                }
              });
            });
          };
          return PayloadReceiver2;
        }();
        exports3.PayloadReceiver = PayloadReceiver;
      }, { "../payloads/headerSerializer": 15, "../payloads/payloadConstants": 18, "../payloads/payloadTypes": 19, "./transportDisconnectedEvent": 13 }], 12: [function(require2, module3, exports3) {
        (function(Buffer) {
          (function() {
            "use strict";
            Object.defineProperty(exports3, "__esModule", { value: true });
            exports3.PayloadSender = void 0;
            var headerSerializer_1 = require2("../payloads/headerSerializer");
            var payloadConstants_1 = require2("../payloads/payloadConstants");
            var transportDisconnectedEvent_1 = require2("./transportDisconnectedEvent");
            var PayloadSender = function() {
              function PayloadSender2() {
              }
              Object.defineProperty(PayloadSender2.prototype, "isConnected", {
                get: function() {
                  return this._sender != null;
                },
                enumerable: false,
                configurable: true
              });
              PayloadSender2.prototype.connect = function(sender) {
                this._sender = sender;
              };
              PayloadSender2.prototype.sendPayload = function(header, payload, sentCallback) {
                var packet = { header, payload, sentCallback };
                this.writePacket(packet);
              };
              PayloadSender2.prototype.disconnect = function(event) {
                var _a, _b;
                if (event === void 0) {
                  event = transportDisconnectedEvent_1.TransportDisconnectedEvent.Empty;
                }
                if (!this.isConnected) {
                  return;
                }
                try {
                  this._sender.close();
                  (_a = this.disconnected) === null || _a === void 0 ? void 0 : _a.call(this, this, event);
                } catch (err) {
                  (_b = this.disconnected) === null || _b === void 0 ? void 0 : _b.call(this, this, new transportDisconnectedEvent_1.TransportDisconnectedEvent(err.message));
                } finally {
                  this._sender = null;
                }
              };
              PayloadSender2.prototype.writePacket = function(packet) {
                try {
                  if (packet.header.payloadLength > 0 && packet.payload) {
                    var leftOver = packet.header.payloadLength;
                    while (leftOver > 0) {
                      var count = leftOver <= payloadConstants_1.PayloadConstants.MaxPayloadLength ? leftOver : payloadConstants_1.PayloadConstants.MaxPayloadLength;
                      var chunk = packet.payload.read(count);
                      var header = packet.header;
                      header.payloadLength = count;
                      header.end = leftOver <= payloadConstants_1.PayloadConstants.MaxPayloadLength;
                      var sendHeaderBuffer = Buffer.alloc(payloadConstants_1.PayloadConstants.MaxHeaderLength);
                      headerSerializer_1.HeaderSerializer.serialize(header, sendHeaderBuffer);
                      this._sender.send(sendHeaderBuffer);
                      this._sender.send(chunk);
                      leftOver -= chunk.length;
                    }
                    if (packet.sentCallback) {
                      packet.sentCallback();
                    }
                  }
                } catch (err) {
                  this.disconnect(new transportDisconnectedEvent_1.TransportDisconnectedEvent(err.message));
                }
              };
              return PayloadSender2;
            }();
            exports3.PayloadSender = PayloadSender;
          }).call(this);
        }).call(this, require2("buffer").Buffer);
      }, { "../payloads/headerSerializer": 15, "../payloads/payloadConstants": 18, "./transportDisconnectedEvent": 13, "buffer": 50 }], 13: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.TransportDisconnectedEvent = void 0;
        var TransportDisconnectedEvent = function() {
          function TransportDisconnectedEvent2(reason) {
            this.reason = reason;
          }
          TransportDisconnectedEvent2.Empty = new TransportDisconnectedEvent2();
          return TransportDisconnectedEvent2;
        }();
        exports3.TransportDisconnectedEvent = TransportDisconnectedEvent;
      }, {}], 14: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true });
      }, {}], 15: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.HeaderSerializer = void 0;
        var payloadConstants_1 = require2("./payloadConstants");
        var HeaderSerializer = function() {
          function HeaderSerializer2() {
          }
          HeaderSerializer2.serialize = function(header, buffer) {
            buffer.write(header.payloadType, this.TypeOffset, 1, this.Encoding);
            buffer.write(this.Delimiter, this.TypeDelimiterOffset, 1, this.Encoding);
            buffer.write(this.headerLengthPadder(header.payloadLength, this.LengthLength, "0"), this.LengthOffset, this.LengthLength, this.Encoding);
            buffer.write(this.Delimiter, this.LengthDelimeterOffset, 1, this.Encoding);
            buffer.write(header.id, this.IdOffset);
            buffer.write(this.Delimiter, this.IdDelimeterOffset, 1, this.Encoding);
            buffer.write(header.end ? this.End : this.NotEnd, this.EndOffset);
            buffer.write(this.Terminator, this.TerminatorOffset);
          };
          HeaderSerializer2.deserialize = function(buffer) {
            var jsonBuffer = buffer.toString(this.Encoding);
            var headerArray = jsonBuffer.split(this.Delimiter);
            if (headerArray.length !== 4) {
              throw Error("Cannot parse header, header is malformed. Header: " + jsonBuffer);
            }
            var payloadType = headerArray[0], length = headerArray[1], id = headerArray[2], headerEnd = headerArray[3];
            var end = headerEnd === "1\n";
            var payloadLength = Number(length);
            var header = { end, payloadLength, payloadType, id };
            if (!(header.payloadLength <= payloadConstants_1.PayloadConstants.MaxPayloadLength && header.payloadLength >= payloadConstants_1.PayloadConstants.MinLength)) {
              throw Error("Header length of " + header.payloadLength + " is missing or malformed");
            }
            if (header.payloadType.length !== this.TypeDelimiterOffset) {
              throw Error("Header type '" + header.payloadType.length + "' is missing or malformed.");
            }
            if (!header.id || !header.id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i) || header.id.length !== this.IdLength) {
              throw Error("Header ID '" + header.id + "' is missing or malformed.");
            }
            if (!(headerEnd === "0\n" || headerEnd === "1\n")) {
              throw Error("Header End is missing or not a valid value. Header end: '" + headerEnd + "'");
            }
            return header;
          };
          HeaderSerializer2.headerLengthPadder = function(lengthValue, totalLength, padChar) {
            var result = Array(totalLength + 1).join(padChar);
            var lengthString = lengthValue.toString();
            return (result + lengthString).slice(lengthString.length);
          };
          HeaderSerializer2.Delimiter = ".";
          HeaderSerializer2.Terminator = "\n";
          HeaderSerializer2.End = "1";
          HeaderSerializer2.NotEnd = "0";
          HeaderSerializer2.TypeOffset = 0;
          HeaderSerializer2.TypeDelimiterOffset = 1;
          HeaderSerializer2.LengthOffset = 2;
          HeaderSerializer2.LengthLength = 6;
          HeaderSerializer2.LengthDelimeterOffset = 8;
          HeaderSerializer2.IdOffset = 9;
          HeaderSerializer2.IdLength = 36;
          HeaderSerializer2.IdDelimeterOffset = 45;
          HeaderSerializer2.EndOffset = 46;
          HeaderSerializer2.TerminatorOffset = 47;
          HeaderSerializer2.Encoding = "utf8";
          return HeaderSerializer2;
        }();
        exports3.HeaderSerializer = HeaderSerializer;
      }, { "./payloadConstants": 18 }], 16: [function(require2, module3, exports3) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(o2, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          Object.defineProperty(o2, k2, { enumerable: true, get: function() {
            return m[k];
          } });
        } : function(o2, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o2[k2] = m[k];
        });
        var __exportStar = this && this.__exportStar || function(m, exports4) {
          for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports4, p))
              __createBinding(exports4, m, p);
        };
        Object.defineProperty(exports3, "__esModule", { value: true });
        __exportStar(require2("./headerSerializer"), exports3);
        __exportStar(require2("./streamManager"), exports3);
        __exportStar(require2("./payloadAssemblerManager"), exports3);
        __exportStar(require2("./payloadTypes"), exports3);
        __exportStar(require2("./requestManager"), exports3);
        __exportStar(require2("./sendOperations"), exports3);
        __exportStar(require2("./streamManager"), exports3);
      }, { "./headerSerializer": 15, "./payloadAssemblerManager": 17, "./payloadTypes": 19, "./requestManager": 20, "./sendOperations": 21, "./streamManager": 22 }], 17: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.PayloadAssemblerManager = void 0;
        var payloadAssembler_1 = require2("../assemblers/payloadAssembler");
        var payloadTypes_1 = require2("./payloadTypes");
        var PayloadAssemblerManager = function() {
          function PayloadAssemblerManager2(streamManager, onReceiveResponse, onReceiveRequest) {
            this.streamManager = streamManager;
            this.onReceiveResponse = onReceiveResponse;
            this.onReceiveRequest = onReceiveRequest;
            this.activeAssemblers = {};
          }
          PayloadAssemblerManager2.prototype.getPayloadStream = function(header) {
            if (header.payloadType === payloadTypes_1.PayloadTypes.stream) {
              return this.streamManager.getPayloadStream(header);
            } else if (!this.activeAssemblers[header.id]) {
              var assembler = this.createPayloadAssembler(header);
              if (assembler) {
                this.activeAssemblers[header.id] = assembler;
                return assembler.getPayloadStream();
              }
            }
          };
          PayloadAssemblerManager2.prototype.onReceive = function(header, contentStream, contentLength) {
            if (header.payloadType === payloadTypes_1.PayloadTypes.stream) {
              this.streamManager.onReceive(header, contentStream, contentLength);
            } else {
              if (this.activeAssemblers && this.activeAssemblers[header.id]) {
                var assembler = this.activeAssemblers[header.id];
                assembler.onReceive(header, contentStream, contentLength);
              }
              if (header.end) {
                delete this.activeAssemblers[header.id];
              }
            }
          };
          PayloadAssemblerManager2.prototype.createPayloadAssembler = function(header) {
            if (header.payloadType === payloadTypes_1.PayloadTypes.request) {
              return new payloadAssembler_1.PayloadAssembler(this.streamManager, {
                header,
                onCompleted: this.onReceiveRequest
              });
            } else if (header.payloadType === payloadTypes_1.PayloadTypes.response) {
              return new payloadAssembler_1.PayloadAssembler(this.streamManager, {
                header,
                onCompleted: this.onReceiveResponse
              });
            }
          };
          return PayloadAssemblerManager2;
        }();
        exports3.PayloadAssemblerManager = PayloadAssemblerManager;
      }, { "../assemblers/payloadAssembler": 1, "./payloadTypes": 19 }], 18: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.PayloadConstants = void 0;
        var PayloadConstants;
        (function(PayloadConstants2) {
          PayloadConstants2[PayloadConstants2["MaxPayloadLength"] = 4096] = "MaxPayloadLength";
          PayloadConstants2[PayloadConstants2["MaxHeaderLength"] = 48] = "MaxHeaderLength";
          PayloadConstants2[PayloadConstants2["MaxLength"] = 999999] = "MaxLength";
          PayloadConstants2[PayloadConstants2["MinLength"] = 0] = "MinLength";
        })(PayloadConstants = exports3.PayloadConstants || (exports3.PayloadConstants = {}));
      }, {}], 19: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.PayloadTypes = void 0;
        var PayloadTypes;
        (function(PayloadTypes2) {
          PayloadTypes2["request"] = "A";
          PayloadTypes2["response"] = "B";
          PayloadTypes2["stream"] = "S";
          PayloadTypes2["cancelAll"] = "X";
          PayloadTypes2["cancelStream"] = "C";
        })(PayloadTypes = exports3.PayloadTypes || (exports3.PayloadTypes = {}));
      }, {}], 20: [function(require2, module3, exports3) {
        "use strict";
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e2) {
                reject(e2);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e2) {
                reject(e2);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        var __generator = this && this.__generator || function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t2[0] & 1)
              throw t2[1];
            return t2[1];
          }, trys: [], ops: [] }, f, y, t2, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n2) {
            return function(v) {
              return step([n2, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
                  return t2;
                if (y = 0, t2)
                  op = [op[0] & 2, t2.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t2 = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t2[1]) {
                      _.label = t2[1];
                      t2 = op;
                      break;
                    }
                    if (t2 && _.label < t2[2]) {
                      _.label = t2[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t2[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e2) {
                op = [6, e2];
                y = 0;
              } finally {
                f = t2 = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.RequestManager = void 0;
        var PendingRequest = function() {
          function PendingRequest2() {
          }
          return PendingRequest2;
        }();
        var RequestManager = function() {
          function RequestManager2() {
            this._pendingRequests = {};
          }
          RequestManager2.prototype.pendingRequestCount = function() {
            return Object.keys(this._pendingRequests).length;
          };
          RequestManager2.prototype.signalResponse = function(requestId, response) {
            return __awaiter(this, void 0, void 0, function() {
              var pendingRequest;
              return __generator(this, function(_a) {
                pendingRequest = this._pendingRequests[requestId];
                if (pendingRequest) {
                  pendingRequest.resolve(response);
                  delete this._pendingRequests[requestId];
                  return [2, true];
                }
                return [2, false];
              });
            });
          };
          RequestManager2.prototype.getResponse = function(requestId) {
            var pendingRequest = this._pendingRequests[requestId];
            if (pendingRequest) {
              return Promise.reject("requestId '" + requestId + "' already exists in RequestManager");
            }
            pendingRequest = new PendingRequest();
            pendingRequest.requestId = requestId;
            var promise = new Promise(function(resolve, reject) {
              pendingRequest.resolve = resolve;
              pendingRequest.reject = reject;
            });
            this._pendingRequests[requestId] = pendingRequest;
            return promise;
          };
          return RequestManager2;
        }();
        exports3.RequestManager = RequestManager;
      }, {}], 21: [function(require2, module3, exports3) {
        "use strict";
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e2) {
                reject(e2);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e2) {
                reject(e2);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        var __generator = this && this.__generator || function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t2[0] & 1)
              throw t2[1];
            return t2[1];
          }, trys: [], ops: [] }, f, y, t2, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n2) {
            return function(v) {
              return step([n2, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
                  return t2;
                if (y = 0, t2)
                  op = [op[0] & 2, t2.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t2 = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t2[1]) {
                      _.label = t2[1];
                      t2 = op;
                      break;
                    }
                    if (t2 && _.label < t2[2]) {
                      _.label = t2[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t2[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e2) {
                op = [6, e2];
                y = 0;
              } finally {
                f = t2 = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.SendOperations = void 0;
        var cancelDisassembler_1 = require2("../disassemblers/cancelDisassembler");
        var httpContentStreamDisassembler_1 = require2("../disassemblers/httpContentStreamDisassembler");
        var requestDisassembler_1 = require2("../disassemblers/requestDisassembler");
        var responseDisassembler_1 = require2("../disassemblers/responseDisassembler");
        var payloadTypes_1 = require2("./payloadTypes");
        var SendOperations = function() {
          function SendOperations2(payloadSender) {
            this.payloadSender = payloadSender;
          }
          SendOperations2.prototype.sendRequest = function(id, request) {
            return __awaiter(this, void 0, void 0, function() {
              var disassembler;
              var _this = this;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    disassembler = new requestDisassembler_1.RequestDisassembler(this.payloadSender, id, request);
                    return [4, disassembler.disassemble()];
                  case 1:
                    _a.sent();
                    if (request.streams) {
                      request.streams.forEach(function(contentStream) {
                        return __awaiter(_this, void 0, void 0, function() {
                          return __generator(this, function(_a2) {
                            switch (_a2.label) {
                              case 0:
                                return [4, new httpContentStreamDisassembler_1.HttpContentStreamDisassembler(this.payloadSender, contentStream).disassemble()];
                              case 1:
                                _a2.sent();
                                return [2];
                            }
                          });
                        });
                      });
                    }
                    return [2];
                }
              });
            });
          };
          SendOperations2.prototype.sendResponse = function(id, response) {
            return __awaiter(this, void 0, void 0, function() {
              var disassembler;
              var _this = this;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    disassembler = new responseDisassembler_1.ResponseDisassembler(this.payloadSender, id, response);
                    return [4, disassembler.disassemble()];
                  case 1:
                    _a.sent();
                    if (response.streams) {
                      response.streams.forEach(function(contentStream) {
                        return __awaiter(_this, void 0, void 0, function() {
                          return __generator(this, function(_a2) {
                            switch (_a2.label) {
                              case 0:
                                return [4, new httpContentStreamDisassembler_1.HttpContentStreamDisassembler(this.payloadSender, contentStream).disassemble()];
                              case 1:
                                _a2.sent();
                                return [2];
                            }
                          });
                        });
                      });
                    }
                    return [2];
                }
              });
            });
          };
          SendOperations2.prototype.sendCancelStream = function(id) {
            return __awaiter(this, void 0, void 0, function() {
              var disassembler;
              return __generator(this, function(_a) {
                disassembler = new cancelDisassembler_1.CancelDisassembler(this.payloadSender, id, payloadTypes_1.PayloadTypes.cancelStream);
                disassembler.disassemble();
                return [2];
              });
            });
          };
          return SendOperations2;
        }();
        exports3.SendOperations = SendOperations;
      }, { "../disassemblers/cancelDisassembler": 3, "../disassemblers/httpContentStreamDisassembler": 4, "../disassemblers/requestDisassembler": 6, "../disassemblers/responseDisassembler": 7, "./payloadTypes": 19 }], 22: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.StreamManager = void 0;
        var payloadAssembler_1 = require2("../assemblers/payloadAssembler");
        var StreamManager = function() {
          function StreamManager2(onCancelStream) {
            this.onCancelStream = onCancelStream;
            this.activeAssemblers = [];
          }
          StreamManager2.prototype.getPayloadAssembler = function(id) {
            if (!this.activeAssemblers[id]) {
              var assembler = new payloadAssembler_1.PayloadAssembler(this, { id });
              this.activeAssemblers[id] = assembler;
              return assembler;
            } else {
              return this.activeAssemblers[id];
            }
          };
          StreamManager2.prototype.getPayloadStream = function(header) {
            var assembler = this.getPayloadAssembler(header.id);
            return assembler.getPayloadStream();
          };
          StreamManager2.prototype.onReceive = function(header, contentStream, contentLength) {
            if (!this.activeAssemblers[header.id]) {
              return;
            }
            this.activeAssemblers[header.id].onReceive(header, contentStream, contentLength);
          };
          StreamManager2.prototype.closeStream = function(id) {
            if (!this.activeAssemblers[id]) {
              return;
            } else {
              var assembler = this.activeAssemblers[id];
              this.activeAssemblers.splice(this.activeAssemblers.indexOf(id), 1);
              var targetStream = assembler.getPayloadStream();
              if (assembler.contentLength && targetStream.length < assembler.contentLength || !assembler.end) {
                this.onCancelStream(assembler);
              }
            }
          };
          return StreamManager2;
        }();
        exports3.StreamManager = StreamManager;
      }, { "../assemblers/payloadAssembler": 1 }], 23: [function(require2, module3, exports3) {
        "use strict";
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e2) {
                reject(e2);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e2) {
                reject(e2);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        var __generator = this && this.__generator || function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t2[0] & 1)
              throw t2[1];
            return t2[1];
          }, trys: [], ops: [] }, f, y, t2, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n2) {
            return function(v) {
              return step([n2, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
                  return t2;
                if (y = 0, t2)
                  op = [op[0] & 2, t2.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t2 = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t2[1]) {
                      _.label = t2[1];
                      t2 = op;
                      break;
                    }
                    if (t2 && _.label < t2[2]) {
                      _.label = t2[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t2[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e2) {
                op = [6, e2];
                y = 0;
              } finally {
                f = t2 = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.ProtocolAdapter = void 0;
        var payloadAssemblerManager_1 = require2("./payloads/payloadAssemblerManager");
        var sendOperations_1 = require2("./payloads/sendOperations");
        var streamManager_1 = require2("./payloads/streamManager");
        var protocol_base_1 = require2("./utilities/protocol-base");
        var ProtocolAdapter = function() {
          function ProtocolAdapter2(requestHandler, requestManager, sender, receiver) {
            var _this = this;
            this.requestHandler = requestHandler;
            this.requestManager = requestManager;
            this.payloadSender = sender;
            this.payloadReceiver = receiver;
            this.sendOperations = new sendOperations_1.SendOperations(this.payloadSender);
            this.streamManager = new streamManager_1.StreamManager(this.onCancelStream);
            this.assemblerManager = new payloadAssemblerManager_1.PayloadAssemblerManager(this.streamManager, function(id, response) {
              return _this.onReceiveResponse(id, response);
            }, function(id, request) {
              return _this.onReceiveRequest(id, request);
            });
            this.payloadReceiver.subscribe(function(header) {
              return _this.assemblerManager.getPayloadStream(header);
            }, function(header, contentStream, contentLength) {
              return _this.assemblerManager.onReceive(header, contentStream, contentLength);
            });
          }
          ProtocolAdapter2.prototype.sendRequest = function(request) {
            return __awaiter(this, void 0, void 0, function() {
              var requestId;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    requestId = protocol_base_1.generateGuid();
                    return [4, this.sendOperations.sendRequest(requestId, request)];
                  case 1:
                    _a.sent();
                    return [2, this.requestManager.getResponse(requestId)];
                }
              });
            });
          };
          ProtocolAdapter2.prototype.onReceiveRequest = function(id, request) {
            return __awaiter(this, void 0, void 0, function() {
              var response;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    if (!this.requestHandler)
                      return [3, 3];
                    return [4, this.requestHandler.processRequest(request)];
                  case 1:
                    response = _a.sent();
                    if (!response)
                      return [3, 3];
                    return [4, this.sendOperations.sendResponse(id, response)];
                  case 2:
                    _a.sent();
                    _a.label = 3;
                  case 3:
                    return [2];
                }
              });
            });
          };
          ProtocolAdapter2.prototype.onReceiveResponse = function(id, response) {
            return __awaiter(this, void 0, void 0, function() {
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.requestManager.signalResponse(id, response)];
                  case 1:
                    _a.sent();
                    return [2];
                }
              });
            });
          };
          ProtocolAdapter2.prototype.onCancelStream = function(contentStreamAssembler) {
            this.sendOperations.sendCancelStream(contentStreamAssembler.id).catch();
          };
          return ProtocolAdapter2;
        }();
        exports3.ProtocolAdapter = ProtocolAdapter;
      }, { "./payloads/payloadAssemblerManager": 17, "./payloads/sendOperations": 21, "./payloads/streamManager": 22, "./utilities/protocol-base": 28 }], 24: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.RequestHandler = void 0;
        var RequestHandler = function() {
          function RequestHandler2() {
          }
          return RequestHandler2;
        }();
        exports3.RequestHandler = RequestHandler;
      }, {}], 25: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.StreamingRequest = void 0;
        var httpContentStream_1 = require2("./httpContentStream");
        var subscribableStream_1 = require2("./subscribableStream");
        var StreamingRequest = function() {
          function StreamingRequest2() {
            this.streams = [];
          }
          StreamingRequest2.create = function(method, path, body) {
            var request = new StreamingRequest2();
            request.verb = method;
            request.path = path;
            if (body) {
              request.setBody(body);
            }
            return request;
          };
          StreamingRequest2.prototype.addStream = function(content) {
            if (!content) {
              throw new Error("Argument Undefined Exception: content undefined.");
            }
            this.streams.push(new httpContentStream_1.HttpContentStream(content));
          };
          StreamingRequest2.prototype.setBody = function(body) {
            if (typeof body === "string") {
              var stream = new subscribableStream_1.SubscribableStream();
              stream.write(body, "utf8");
              this.addStream(new httpContentStream_1.HttpContent({
                type: "application/json; charset=utf-8",
                contentLength: stream.length
              }, stream));
            } else if (typeof body === "object") {
              this.addStream(body);
            }
          };
          return StreamingRequest2;
        }();
        exports3.StreamingRequest = StreamingRequest;
      }, { "./httpContentStream": 8, "./subscribableStream": 27 }], 26: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.StreamingResponse = void 0;
        var httpContentStream_1 = require2("./httpContentStream");
        var subscribableStream_1 = require2("./subscribableStream");
        var StreamingResponse = function() {
          function StreamingResponse2() {
            this.streams = [];
          }
          StreamingResponse2.create = function(statusCode, body) {
            var response = new StreamingResponse2();
            response.statusCode = statusCode;
            if (body) {
              response.addStream(body);
            }
            return response;
          };
          StreamingResponse2.prototype.addStream = function(content) {
            this.streams.push(new httpContentStream_1.HttpContentStream(content));
          };
          StreamingResponse2.prototype.setBody = function(body) {
            var stream = new subscribableStream_1.SubscribableStream();
            stream.write(JSON.stringify(body), "utf8");
            this.addStream(new httpContentStream_1.HttpContent({
              type: "application/json; charset=utf-8",
              contentLength: stream.length
            }, stream));
          };
          return StreamingResponse2;
        }();
        exports3.StreamingResponse = StreamingResponse;
      }, { "./httpContentStream": 8, "./subscribableStream": 27 }], 27: [function(require2, module3, exports3) {
        (function(Buffer) {
          (function() {
            "use strict";
            var __extends = this && this.__extends || function() {
              var extendStatics = function(d, b) {
                extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                  d2.__proto__ = b2;
                } || function(d2, b2) {
                  for (var p in b2)
                    if (Object.prototype.hasOwnProperty.call(b2, p))
                      d2[p] = b2[p];
                };
                return extendStatics(d, b);
              };
              return function(d, b) {
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
            }();
            Object.defineProperty(exports3, "__esModule", { value: true });
            exports3.SubscribableStream = void 0;
            var stream_1 = require2("stream");
            var SubscribableStream = function(_super) {
              __extends(SubscribableStream2, _super);
              function SubscribableStream2(options) {
                var _this = _super.call(this, options) || this;
                _this.length = 0;
                _this.bufferList = [];
                return _this;
              }
              SubscribableStream2.prototype._write = function(chunk, _encoding, callback) {
                var buffer = Buffer.from(chunk);
                this.bufferList.push(buffer);
                this.length += chunk.length;
                if (this._onData) {
                  this._onData(buffer);
                }
                callback();
              };
              SubscribableStream2.prototype._read = function(size) {
                if (this.bufferList.length === 0) {
                  this.push(null);
                } else {
                  var total = 0;
                  while (total < size && this.bufferList.length > 0) {
                    var buffer = this.bufferList[0];
                    this.push(buffer);
                    this.bufferList.splice(0, 1);
                    total += buffer.length;
                  }
                }
              };
              SubscribableStream2.prototype.subscribe = function(onData) {
                this._onData = onData;
              };
              return SubscribableStream2;
            }(stream_1.Duplex);
            exports3.SubscribableStream = SubscribableStream;
          }).call(this);
        }).call(this, require2("buffer").Buffer);
      }, { "buffer": 50, "stream": 56 }], 28: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.generateGuid = void 0;
        var uuid_1 = require2("uuid");
        function generateGuid() {
          return uuid_1.v4();
        }
        exports3.generateGuid = generateGuid;
      }, { "uuid": 33 }], 29: [function(require2, module3, exports3) {
        "use strict";
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e2) {
                reject(e2);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e2) {
                reject(e2);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        var __generator = this && this.__generator || function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t2[0] & 1)
              throw t2[1];
            return t2[1];
          }, trys: [], ops: [] }, f, y, t2, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n2) {
            return function(v) {
              return step([n2, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
                  return t2;
                if (y = 0, t2)
                  op = [op[0] & 2, t2.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t2 = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t2[1]) {
                      _.label = t2[1];
                      t2 = op;
                      break;
                    }
                    if (t2 && _.label < t2[2]) {
                      _.label = t2[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t2[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e2) {
                op = [6, e2];
                y = 0;
              } finally {
                f = t2 = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.BrowserWebSocket = void 0;
        var BrowserWebSocket = function() {
          function BrowserWebSocket2(socket) {
            if (socket) {
              this.webSocket = socket;
            }
          }
          BrowserWebSocket2.prototype.connect = function(serverAddress) {
            return __awaiter(this, void 0, void 0, function() {
              var resolver, rejector;
              return __generator(this, function(_a) {
                if (!this.webSocket) {
                  this.webSocket = new WebSocket(serverAddress);
                }
                this.webSocket.onerror = function(e2) {
                  rejector(e2);
                };
                this.webSocket.onopen = function(e2) {
                  resolver(e2);
                };
                return [2, new Promise(function(resolve, reject) {
                  resolver = resolve;
                  rejector = reject;
                })];
              });
            });
          };
          Object.defineProperty(BrowserWebSocket2.prototype, "isConnected", {
            get: function() {
              return this.webSocket.readyState === 1;
            },
            enumerable: false,
            configurable: true
          });
          BrowserWebSocket2.prototype.write = function(buffer) {
            this.webSocket.send(buffer);
          };
          BrowserWebSocket2.prototype.close = function() {
            this.webSocket.close();
          };
          BrowserWebSocket2.prototype.setOnMessageHandler = function(handler) {
            var bufferKey = "buffer";
            var packets = [];
            this.webSocket.onmessage = function(evt) {
              var fileReader = new FileReader();
              var queueEntry = { buffer: null };
              packets.push(queueEntry);
              fileReader.onload = function(e2) {
                var t2 = e2.target;
                queueEntry[bufferKey] = t2.result;
                if (packets[0] === queueEntry) {
                  while (0 < packets.length && packets[0][bufferKey]) {
                    handler(packets[0][bufferKey]);
                    packets.splice(0, 1);
                  }
                }
              };
              fileReader.readAsArrayBuffer(evt.data);
            };
          };
          BrowserWebSocket2.prototype.setOnErrorHandler = function(handler) {
            this.webSocket.onerror = function(error) {
              if (error) {
                handler(error);
              }
            };
          };
          BrowserWebSocket2.prototype.setOnCloseHandler = function(handler) {
            this.webSocket.onclose = handler;
          };
          return BrowserWebSocket2;
        }();
        exports3.BrowserWebSocket = BrowserWebSocket;
      }, {}], 30: [function(require2, module3, exports3) {
        "use strict";
        var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e2) {
                reject(e2);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e2) {
                reject(e2);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        var __generator = this && this.__generator || function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t2[0] & 1)
              throw t2[1];
            return t2[1];
          }, trys: [], ops: [] }, f, y, t2, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n2) {
            return function(v) {
              return step([n2, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
                  return t2;
                if (y = 0, t2)
                  op = [op[0] & 2, t2.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t2 = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t2[1]) {
                      _.label = t2[1];
                      t2 = op;
                      break;
                    }
                    if (t2 && _.label < t2[2]) {
                      _.label = t2[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t2[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e2) {
                op = [6, e2];
                y = 0;
              } finally {
                f = t2 = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.WebSocketClient = void 0;
        var browserWebSocket_1 = require2("./browserWebSocket");
        var payloadTransport_1 = require2("../payloadTransport");
        var protocolAdapter_1 = require2("../protocolAdapter");
        var payloads_1 = require2("../payloads");
        var webSocketTransport_1 = require2("./webSocketTransport");
        var WebSocketClient = function() {
          function WebSocketClient2(_a) {
            var url = _a.url, requestHandler = _a.requestHandler, _b = _a.disconnectionHandler, disconnectionHandler = _b === void 0 ? null : _b;
            this._url = url;
            this._requestHandler = requestHandler;
            this._disconnectionHandler = disconnectionHandler;
            this._requestManager = new payloads_1.RequestManager();
            this._sender = new payloadTransport_1.PayloadSender();
            this._sender.disconnected = this.onConnectionDisconnected.bind(this);
            this._receiver = new payloadTransport_1.PayloadReceiver();
            this._receiver.disconnected = this.onConnectionDisconnected.bind(this);
            this._protocolAdapter = new protocolAdapter_1.ProtocolAdapter(this._requestHandler, this._requestManager, this._sender, this._receiver);
          }
          WebSocketClient2.prototype.connect = function() {
            return __awaiter(this, void 0, void 0, function() {
              var ws, transport;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    ws = new browserWebSocket_1.BrowserWebSocket();
                    return [4, ws.connect(this._url)];
                  case 1:
                    _a.sent();
                    transport = new webSocketTransport_1.WebSocketTransport(ws);
                    this._sender.connect(transport);
                    this._receiver.connect(transport);
                    return [2];
                }
              });
            });
          };
          WebSocketClient2.prototype.disconnect = function() {
            this._sender.disconnect(new payloadTransport_1.TransportDisconnectedEvent("Disconnect was called."));
            this._receiver.disconnect(new payloadTransport_1.TransportDisconnectedEvent("Disconnect was called."));
          };
          WebSocketClient2.prototype.send = function(request) {
            return __awaiter(this, void 0, void 0, function() {
              return __generator(this, function(_a) {
                return [2, this._protocolAdapter.sendRequest(request)];
              });
            });
          };
          WebSocketClient2.prototype.onConnectionDisconnected = function(sender, args) {
            if (this._disconnectionHandler != null) {
              this._disconnectionHandler("Disconnected");
              return;
            }
            throw new Error("Unable to re-connect client to transport for url " + this._url + ". Sender: '" + JSON.stringify(sender) + "'. Args:' " + JSON.stringify(args));
          };
          return WebSocketClient2;
        }();
        exports3.WebSocketClient = WebSocketClient;
      }, { "../payloadTransport": 10, "../payloads": 16, "../protocolAdapter": 23, "./browserWebSocket": 29, "./webSocketTransport": 32 }], 31: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.WebSocketTransport = exports3.WebSocketClient = exports3.BrowserWebSocket = void 0;
        var browserWebSocket_1 = require2("./browserWebSocket");
        Object.defineProperty(exports3, "BrowserWebSocket", { enumerable: true, get: function() {
          return browserWebSocket_1.BrowserWebSocket;
        } });
        var browserWebSocketClient_1 = require2("./browserWebSocketClient");
        Object.defineProperty(exports3, "WebSocketClient", { enumerable: true, get: function() {
          return browserWebSocketClient_1.WebSocketClient;
        } });
        var webSocketTransport_1 = require2("./webSocketTransport");
        Object.defineProperty(exports3, "WebSocketTransport", { enumerable: true, get: function() {
          return webSocketTransport_1.WebSocketTransport;
        } });
      }, { "./browserWebSocket": 29, "./browserWebSocketClient": 30, "./webSocketTransport": 32 }], 32: [function(require2, module3, exports3) {
        (function(Buffer) {
          (function() {
            "use strict";
            var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
              function adopt(value) {
                return value instanceof P ? value : new P(function(resolve) {
                  resolve(value);
                });
              }
              return new (P || (P = Promise))(function(resolve, reject) {
                function fulfilled(value) {
                  try {
                    step(generator.next(value));
                  } catch (e2) {
                    reject(e2);
                  }
                }
                function rejected(value) {
                  try {
                    step(generator["throw"](value));
                  } catch (e2) {
                    reject(e2);
                  }
                }
                function step(result) {
                  result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
              });
            };
            var __generator = this && this.__generator || function(thisArg, body) {
              var _ = { label: 0, sent: function() {
                if (t2[0] & 1)
                  throw t2[1];
                return t2[1];
              }, trys: [], ops: [] }, f, y, t2, g;
              return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
                return this;
              }), g;
              function verb(n2) {
                return function(v) {
                  return step([n2, v]);
                };
              }
              function step(op) {
                if (f)
                  throw new TypeError("Generator is already executing.");
                while (_)
                  try {
                    if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
                      return t2;
                    if (y = 0, t2)
                      op = [op[0] & 2, t2.value];
                    switch (op[0]) {
                      case 0:
                      case 1:
                        t2 = op;
                        break;
                      case 4:
                        _.label++;
                        return { value: op[1], done: false };
                      case 5:
                        _.label++;
                        y = op[1];
                        op = [0];
                        continue;
                      case 7:
                        op = _.ops.pop();
                        _.trys.pop();
                        continue;
                      default:
                        if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                          _ = 0;
                          continue;
                        }
                        if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                          _.label = op[1];
                          break;
                        }
                        if (op[0] === 6 && _.label < t2[1]) {
                          _.label = t2[1];
                          t2 = op;
                          break;
                        }
                        if (t2 && _.label < t2[2]) {
                          _.label = t2[2];
                          _.ops.push(op);
                          break;
                        }
                        if (t2[2])
                          _.ops.pop();
                        _.trys.pop();
                        continue;
                    }
                    op = body.call(thisArg, _);
                  } catch (e2) {
                    op = [6, e2];
                    y = 0;
                  } finally {
                    f = t2 = 0;
                  }
                if (op[0] & 5)
                  throw op[1];
                return { value: op[0] ? op[1] : void 0, done: true };
              }
            };
            Object.defineProperty(exports3, "__esModule", { value: true });
            exports3.WebSocketTransport = void 0;
            var WebSocketTransport = function() {
              function WebSocketTransport2(ws) {
                var _this = this;
                this.ws = ws;
                this._queue = [];
                this._activeOffset = 0;
                this._activeReceiveCount = 0;
                this.ws.setOnMessageHandler(function(data) {
                  _this.onReceive(data);
                });
                this.ws.setOnErrorHandler(function(err) {
                  _this.onError(err);
                });
                this.ws.setOnCloseHandler(function() {
                  _this.onClose();
                });
              }
              WebSocketTransport2.prototype.send = function(buffer) {
                var _a;
                if ((_a = this.ws) === null || _a === void 0 ? void 0 : _a.isConnected) {
                  this.ws.write(buffer);
                  return buffer.length;
                }
                return 0;
              };
              Object.defineProperty(WebSocketTransport2.prototype, "isConnected", {
                get: function() {
                  var _a;
                  return (_a = this.ws) === null || _a === void 0 ? void 0 : _a.isConnected;
                },
                enumerable: false,
                configurable: true
              });
              WebSocketTransport2.prototype.close = function() {
                var _a;
                if ((_a = this.ws) === null || _a === void 0 ? void 0 : _a.isConnected) {
                  this.ws.close();
                }
              };
              WebSocketTransport2.prototype.receive = function(count) {
                return __awaiter(this, void 0, void 0, function() {
                  var promise;
                  var _this = this;
                  return __generator(this, function(_a) {
                    if (this._activeReceiveResolve) {
                      throw new Error("Cannot call receive more than once before it has returned.");
                    }
                    this._activeReceiveCount = count;
                    promise = new Promise(function(resolve, reject) {
                      _this._activeReceiveResolve = resolve;
                      _this._activeReceiveReject = reject;
                    });
                    this.trySignalData();
                    return [2, promise];
                  });
                });
              };
              WebSocketTransport2.prototype.onReceive = function(data) {
                if (this._queue && data && data.byteLength > 0) {
                  this._queue.push(Buffer.from(data));
                  this.trySignalData();
                }
              };
              WebSocketTransport2.prototype.onClose = function() {
                if (this._activeReceiveReject) {
                  this._activeReceiveReject(new Error("Socket was closed."));
                }
                this._active = null;
                this._activeOffset = 0;
                this._activeReceiveResolve = null;
                this._activeReceiveReject = null;
                this._activeReceiveCount = 0;
                this.ws = null;
              };
              WebSocketTransport2.prototype.onError = function(err) {
                if (this._activeReceiveReject) {
                  this._activeReceiveReject(err);
                }
                this.onClose();
              };
              WebSocketTransport2.prototype.trySignalData = function() {
                if (this._activeReceiveResolve) {
                  if (!this._active && this._queue.length > 0) {
                    this._active = this._queue.shift();
                    this._activeOffset = 0;
                  }
                  if (this._active) {
                    if (this._activeOffset === 0 && this._active.length === this._activeReceiveCount) {
                      var buffer = this._active;
                      this._active = null;
                      this._activeReceiveResolve(buffer);
                    } else {
                      var available = Math.min(this._activeReceiveCount, this._active.length - this._activeOffset);
                      var buffer = Buffer.alloc(available);
                      this._active.copy(buffer, 0, this._activeOffset, this._activeOffset + available);
                      this._activeOffset += available;
                      if (this._activeOffset >= this._active.length) {
                        this._active = null;
                        this._activeOffset = 0;
                      }
                      this._activeReceiveResolve(buffer);
                    }
                    this._activeReceiveCount = 0;
                    this._activeReceiveReject = null;
                    this._activeReceiveResolve = null;
                  }
                }
              };
              return WebSocketTransport2;
            }();
            exports3.WebSocketTransport = WebSocketTransport;
          }).call(this);
        }).call(this, require2("buffer").Buffer);
      }, { "buffer": 50 }], 33: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        Object.defineProperty(exports3, "v1", {
          enumerable: true,
          get: function() {
            return _v.default;
          }
        });
        Object.defineProperty(exports3, "v3", {
          enumerable: true,
          get: function() {
            return _v2.default;
          }
        });
        Object.defineProperty(exports3, "v4", {
          enumerable: true,
          get: function() {
            return _v3.default;
          }
        });
        Object.defineProperty(exports3, "v5", {
          enumerable: true,
          get: function() {
            return _v4.default;
          }
        });
        Object.defineProperty(exports3, "NIL", {
          enumerable: true,
          get: function() {
            return _nil.default;
          }
        });
        Object.defineProperty(exports3, "version", {
          enumerable: true,
          get: function() {
            return _version.default;
          }
        });
        Object.defineProperty(exports3, "validate", {
          enumerable: true,
          get: function() {
            return _validate.default;
          }
        });
        Object.defineProperty(exports3, "stringify", {
          enumerable: true,
          get: function() {
            return _stringify.default;
          }
        });
        Object.defineProperty(exports3, "parse", {
          enumerable: true,
          get: function() {
            return _parse.default;
          }
        });
        var _v = _interopRequireDefault(require2("./v1.js"));
        var _v2 = _interopRequireDefault(require2("./v3.js"));
        var _v3 = _interopRequireDefault(require2("./v4.js"));
        var _v4 = _interopRequireDefault(require2("./v5.js"));
        var _nil = _interopRequireDefault(require2("./nil.js"));
        var _version = _interopRequireDefault(require2("./version.js"));
        var _validate = _interopRequireDefault(require2("./validate.js"));
        var _stringify = _interopRequireDefault(require2("./stringify.js"));
        var _parse = _interopRequireDefault(require2("./parse.js"));
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
      }, { "./nil.js": 35, "./parse.js": 36, "./stringify.js": 40, "./v1.js": 41, "./v3.js": 42, "./v4.js": 44, "./v5.js": 45, "./validate.js": 46, "./version.js": 47 }], 34: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.default = void 0;
        function md5(bytes) {
          if (typeof bytes === "string") {
            const msg = unescape(encodeURIComponent(bytes));
            bytes = new Uint8Array(msg.length);
            for (let i = 0; i < msg.length; ++i) {
              bytes[i] = msg.charCodeAt(i);
            }
          }
          return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
        }
        function md5ToHexEncodedArray(input) {
          const output = [];
          const length32 = input.length * 32;
          const hexTab = "0123456789abcdef";
          for (let i = 0; i < length32; i += 8) {
            const x = input[i >> 5] >>> i % 32 & 255;
            const hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
            output.push(hex);
          }
          return output;
        }
        function getOutputLength(inputLength8) {
          return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
        }
        function wordsToMd5(x, len) {
          x[len >> 5] |= 128 << len % 32;
          x[getOutputLength(len) - 1] = len;
          let a = 1732584193;
          let b = -271733879;
          let c = -1732584194;
          let d = 271733878;
          for (let i = 0; i < x.length; i += 16) {
            const olda = a;
            const oldb = b;
            const oldc = c;
            const oldd = d;
            a = md5ff(a, b, c, d, x[i], 7, -680876936);
            d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
            c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
            b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
            a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
            d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
            c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
            b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
            a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
            d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
            c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
            b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
            a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
            d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
            c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
            b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
            a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
            d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
            c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
            b = md5gg(b, c, d, a, x[i], 20, -373897302);
            a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
            d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
            c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
            b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
            a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
            d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
            c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
            b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
            a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
            d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
            c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
            b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
            a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
            d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
            c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
            b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
            a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
            d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
            c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
            b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
            a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
            d = md5hh(d, a, b, c, x[i], 11, -358537222);
            c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
            b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
            a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
            d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
            c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
            b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
            a = md5ii(a, b, c, d, x[i], 6, -198630844);
            d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
            c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
            b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
            a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
            d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
            c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
            b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
            a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
            d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
            c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
            b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
            a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
            d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
            c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
            b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
            a = safeAdd(a, olda);
            b = safeAdd(b, oldb);
            c = safeAdd(c, oldc);
            d = safeAdd(d, oldd);
          }
          return [a, b, c, d];
        }
        function bytesToWords(input) {
          if (input.length === 0) {
            return [];
          }
          const length8 = input.length * 8;
          const output = new Uint32Array(getOutputLength(length8));
          for (let i = 0; i < length8; i += 8) {
            output[i >> 5] |= (input[i / 8] & 255) << i % 32;
          }
          return output;
        }
        function safeAdd(x, y) {
          const lsw = (x & 65535) + (y & 65535);
          const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
          return msw << 16 | lsw & 65535;
        }
        function bitRotateLeft(num, cnt) {
          return num << cnt | num >>> 32 - cnt;
        }
        function md5cmn(q, a, b, x, s, t2) {
          return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t2)), s), b);
        }
        function md5ff(a, b, c, d, x, s, t2) {
          return md5cmn(b & c | ~b & d, a, b, x, s, t2);
        }
        function md5gg(a, b, c, d, x, s, t2) {
          return md5cmn(b & d | c & ~d, a, b, x, s, t2);
        }
        function md5hh(a, b, c, d, x, s, t2) {
          return md5cmn(b ^ c ^ d, a, b, x, s, t2);
        }
        function md5ii(a, b, c, d, x, s, t2) {
          return md5cmn(c ^ (b | ~d), a, b, x, s, t2);
        }
        var _default = md5;
        exports3.default = _default;
      }, {}], 35: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.default = void 0;
        var _default = "00000000-0000-0000-0000-000000000000";
        exports3.default = _default;
      }, {}], 36: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.default = void 0;
        var _validate = _interopRequireDefault(require2("./validate.js"));
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function parse(uuid) {
          if (!(0, _validate.default)(uuid)) {
            throw TypeError("Invalid UUID");
          }
          let v;
          const arr = new Uint8Array(16);
          arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
          arr[1] = v >>> 16 & 255;
          arr[2] = v >>> 8 & 255;
          arr[3] = v & 255;
          arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
          arr[5] = v & 255;
          arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
          arr[7] = v & 255;
          arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
          arr[9] = v & 255;
          arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
          arr[11] = v / 4294967296 & 255;
          arr[12] = v >>> 24 & 255;
          arr[13] = v >>> 16 & 255;
          arr[14] = v >>> 8 & 255;
          arr[15] = v & 255;
          return arr;
        }
        var _default = parse;
        exports3.default = _default;
      }, { "./validate.js": 46 }], 37: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.default = void 0;
        var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
        exports3.default = _default;
      }, {}], 38: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.default = rng;
        let getRandomValues;
        const rnds8 = new Uint8Array(16);
        function rng() {
          if (!getRandomValues) {
            getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
            if (!getRandomValues) {
              throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
            }
          }
          return getRandomValues(rnds8);
        }
      }, {}], 39: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.default = void 0;
        function f(s, x, y, z) {
          switch (s) {
            case 0:
              return x & y ^ ~x & z;
            case 1:
              return x ^ y ^ z;
            case 2:
              return x & y ^ x & z ^ y & z;
            case 3:
              return x ^ y ^ z;
          }
        }
        function ROTL(x, n2) {
          return x << n2 | x >>> 32 - n2;
        }
        function sha1(bytes) {
          const K = [1518500249, 1859775393, 2400959708, 3395469782];
          const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
          if (typeof bytes === "string") {
            const msg = unescape(encodeURIComponent(bytes));
            bytes = [];
            for (let i = 0; i < msg.length; ++i) {
              bytes.push(msg.charCodeAt(i));
            }
          } else if (!Array.isArray(bytes)) {
            bytes = Array.prototype.slice.call(bytes);
          }
          bytes.push(128);
          const l = bytes.length / 4 + 2;
          const N = Math.ceil(l / 16);
          const M = new Array(N);
          for (let i = 0; i < N; ++i) {
            const arr = new Uint32Array(16);
            for (let j = 0; j < 16; ++j) {
              arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
            }
            M[i] = arr;
          }
          M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
          M[N - 1][14] = Math.floor(M[N - 1][14]);
          M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
          for (let i = 0; i < N; ++i) {
            const W = new Uint32Array(80);
            for (let t2 = 0; t2 < 16; ++t2) {
              W[t2] = M[i][t2];
            }
            for (let t2 = 16; t2 < 80; ++t2) {
              W[t2] = ROTL(W[t2 - 3] ^ W[t2 - 8] ^ W[t2 - 14] ^ W[t2 - 16], 1);
            }
            let a = H[0];
            let b = H[1];
            let c = H[2];
            let d = H[3];
            let e2 = H[4];
            for (let t2 = 0; t2 < 80; ++t2) {
              const s = Math.floor(t2 / 20);
              const T = ROTL(a, 5) + f(s, b, c, d) + e2 + K[s] + W[t2] >>> 0;
              e2 = d;
              d = c;
              c = ROTL(b, 30) >>> 0;
              b = a;
              a = T;
            }
            H[0] = H[0] + a >>> 0;
            H[1] = H[1] + b >>> 0;
            H[2] = H[2] + c >>> 0;
            H[3] = H[3] + d >>> 0;
            H[4] = H[4] + e2 >>> 0;
          }
          return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
        }
        var _default = sha1;
        exports3.default = _default;
      }, {}], 40: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.default = void 0;
        var _validate = _interopRequireDefault(require2("./validate.js"));
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        const byteToHex = [];
        for (let i = 0; i < 256; ++i) {
          byteToHex.push((i + 256).toString(16).substr(1));
        }
        function stringify(arr, offset = 0) {
          const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
          if (!(0, _validate.default)(uuid)) {
            throw TypeError("Stringified UUID is invalid");
          }
          return uuid;
        }
        var _default = stringify;
        exports3.default = _default;
      }, { "./validate.js": 46 }], 41: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.default = void 0;
        var _rng = _interopRequireDefault(require2("./rng.js"));
        var _stringify = _interopRequireDefault(require2("./stringify.js"));
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        let _nodeId;
        let _clockseq;
        let _lastMSecs = 0;
        let _lastNSecs = 0;
        function v1(options, buf, offset) {
          let i = buf && offset || 0;
          const b = buf || new Array(16);
          options = options || {};
          let node = options.node || _nodeId;
          let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
          if (node == null || clockseq == null) {
            const seedBytes = options.random || (options.rng || _rng.default)();
            if (node == null) {
              node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
            }
            if (clockseq == null) {
              clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
            }
          }
          let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
          let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
          const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
          if (dt < 0 && options.clockseq === void 0) {
            clockseq = clockseq + 1 & 16383;
          }
          if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
            nsecs = 0;
          }
          if (nsecs >= 1e4) {
            throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
          }
          _lastMSecs = msecs;
          _lastNSecs = nsecs;
          _clockseq = clockseq;
          msecs += 122192928e5;
          const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
          b[i++] = tl >>> 24 & 255;
          b[i++] = tl >>> 16 & 255;
          b[i++] = tl >>> 8 & 255;
          b[i++] = tl & 255;
          const tmh = msecs / 4294967296 * 1e4 & 268435455;
          b[i++] = tmh >>> 8 & 255;
          b[i++] = tmh & 255;
          b[i++] = tmh >>> 24 & 15 | 16;
          b[i++] = tmh >>> 16 & 255;
          b[i++] = clockseq >>> 8 | 128;
          b[i++] = clockseq & 255;
          for (let n2 = 0; n2 < 6; ++n2) {
            b[i + n2] = node[n2];
          }
          return buf || (0, _stringify.default)(b);
        }
        var _default = v1;
        exports3.default = _default;
      }, { "./rng.js": 38, "./stringify.js": 40 }], 42: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.default = void 0;
        var _v = _interopRequireDefault(require2("./v35.js"));
        var _md = _interopRequireDefault(require2("./md5.js"));
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        const v3 = (0, _v.default)("v3", 48, _md.default);
        var _default = v3;
        exports3.default = _default;
      }, { "./md5.js": 34, "./v35.js": 43 }], 43: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.default = _default;
        exports3.URL = exports3.DNS = void 0;
        var _stringify = _interopRequireDefault(require2("./stringify.js"));
        var _parse = _interopRequireDefault(require2("./parse.js"));
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function stringToBytes(str) {
          str = unescape(encodeURIComponent(str));
          const bytes = [];
          for (let i = 0; i < str.length; ++i) {
            bytes.push(str.charCodeAt(i));
          }
          return bytes;
        }
        const DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
        exports3.DNS = DNS;
        const URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
        exports3.URL = URL;
        function _default(name, version, hashfunc) {
          function generateUUID(value, namespace, buf, offset) {
            if (typeof value === "string") {
              value = stringToBytes(value);
            }
            if (typeof namespace === "string") {
              namespace = (0, _parse.default)(namespace);
            }
            if (namespace.length !== 16) {
              throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
            }
            let bytes = new Uint8Array(16 + value.length);
            bytes.set(namespace);
            bytes.set(value, namespace.length);
            bytes = hashfunc(bytes);
            bytes[6] = bytes[6] & 15 | version;
            bytes[8] = bytes[8] & 63 | 128;
            if (buf) {
              offset = offset || 0;
              for (let i = 0; i < 16; ++i) {
                buf[offset + i] = bytes[i];
              }
              return buf;
            }
            return (0, _stringify.default)(bytes);
          }
          try {
            generateUUID.name = name;
          } catch (err) {
          }
          generateUUID.DNS = DNS;
          generateUUID.URL = URL;
          return generateUUID;
        }
      }, { "./parse.js": 36, "./stringify.js": 40 }], 44: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.default = void 0;
        var _rng = _interopRequireDefault(require2("./rng.js"));
        var _stringify = _interopRequireDefault(require2("./stringify.js"));
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function v4(options, buf, offset) {
          options = options || {};
          const rnds = options.random || (options.rng || _rng.default)();
          rnds[6] = rnds[6] & 15 | 64;
          rnds[8] = rnds[8] & 63 | 128;
          if (buf) {
            offset = offset || 0;
            for (let i = 0; i < 16; ++i) {
              buf[offset + i] = rnds[i];
            }
            return buf;
          }
          return (0, _stringify.default)(rnds);
        }
        var _default = v4;
        exports3.default = _default;
      }, { "./rng.js": 38, "./stringify.js": 40 }], 45: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.default = void 0;
        var _v = _interopRequireDefault(require2("./v35.js"));
        var _sha = _interopRequireDefault(require2("./sha1.js"));
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        const v5 = (0, _v.default)("v5", 80, _sha.default);
        var _default = v5;
        exports3.default = _default;
      }, { "./sha1.js": 39, "./v35.js": 43 }], 46: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.default = void 0;
        var _regex = _interopRequireDefault(require2("./regex.js"));
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function validate(uuid) {
          return typeof uuid === "string" && _regex.default.test(uuid);
        }
        var _default = validate;
        exports3.default = _default;
      }, { "./regex.js": 37 }], 47: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.default = void 0;
        var _validate = _interopRequireDefault(require2("./validate.js"));
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function version(uuid) {
          if (!(0, _validate.default)(uuid)) {
            throw TypeError("Invalid UUID");
          }
          return parseInt(uuid.substr(14, 1), 16);
        }
        var _default = version;
        exports3.default = _default;
      }, { "./validate.js": 46 }], 48: [function(require2, module3, exports3) {
        "use strict";
        exports3.byteLength = byteLength;
        exports3.toByteArray = toByteArray;
        exports3.fromByteArray = fromByteArray;
        var lookup = [];
        var revLookup = [];
        var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
        var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        for (var i = 0, len = code.length; i < len; ++i) {
          lookup[i] = code[i];
          revLookup[code.charCodeAt(i)] = i;
        }
        revLookup["-".charCodeAt(0)] = 62;
        revLookup["_".charCodeAt(0)] = 63;
        function getLens(b64) {
          var len2 = b64.length;
          if (len2 % 4 > 0) {
            throw new Error("Invalid string. Length must be a multiple of 4");
          }
          var validLen = b64.indexOf("=");
          if (validLen === -1)
            validLen = len2;
          var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
          return [validLen, placeHoldersLen];
        }
        function byteLength(b64) {
          var lens = getLens(b64);
          var validLen = lens[0];
          var placeHoldersLen = lens[1];
          return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
        }
        function _byteLength(b64, validLen, placeHoldersLen) {
          return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
        }
        function toByteArray(b64) {
          var tmp;
          var lens = getLens(b64);
          var validLen = lens[0];
          var placeHoldersLen = lens[1];
          var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
          var curByte = 0;
          var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
          var i2;
          for (i2 = 0; i2 < len2; i2 += 4) {
            tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
            arr[curByte++] = tmp >> 16 & 255;
            arr[curByte++] = tmp >> 8 & 255;
            arr[curByte++] = tmp & 255;
          }
          if (placeHoldersLen === 2) {
            tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
            arr[curByte++] = tmp & 255;
          }
          if (placeHoldersLen === 1) {
            tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
            arr[curByte++] = tmp >> 8 & 255;
            arr[curByte++] = tmp & 255;
          }
          return arr;
        }
        function tripletToBase64(num) {
          return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
        }
        function encodeChunk(uint8, start, end) {
          var tmp;
          var output = [];
          for (var i2 = start; i2 < end; i2 += 3) {
            tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
            output.push(tripletToBase64(tmp));
          }
          return output.join("");
        }
        function fromByteArray(uint8) {
          var tmp;
          var len2 = uint8.length;
          var extraBytes = len2 % 3;
          var parts = [];
          var maxChunkLength = 16383;
          for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
            parts.push(encodeChunk(
              uint8,
              i2,
              i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength
            ));
          }
          if (extraBytes === 1) {
            tmp = uint8[len2 - 1];
            parts.push(
              lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
            );
          } else if (extraBytes === 2) {
            tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
            parts.push(
              lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
            );
          }
          return parts.join("");
        }
      }, {}], 49: [function(require2, module3, exports3) {
      }, {}], 50: [function(require2, module3, exports3) {
        (function(Buffer) {
          (function() {
            "use strict";
            var base64 = require2("base64-js");
            var ieee754 = require2("ieee754");
            exports3.Buffer = Buffer2;
            exports3.SlowBuffer = SlowBuffer;
            exports3.INSPECT_MAX_BYTES = 50;
            var K_MAX_LENGTH = 2147483647;
            exports3.kMaxLength = K_MAX_LENGTH;
            Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
            if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
              console.error(
                "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
              );
            }
            function typedArraySupport() {
              try {
                var arr = new Uint8Array(1);
                arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
                  return 42;
                } };
                return arr.foo() === 42;
              } catch (e2) {
                return false;
              }
            }
            Object.defineProperty(Buffer2.prototype, "parent", {
              enumerable: true,
              get: function() {
                if (!Buffer2.isBuffer(this))
                  return void 0;
                return this.buffer;
              }
            });
            Object.defineProperty(Buffer2.prototype, "offset", {
              enumerable: true,
              get: function() {
                if (!Buffer2.isBuffer(this))
                  return void 0;
                return this.byteOffset;
              }
            });
            function createBuffer(length) {
              if (length > K_MAX_LENGTH) {
                throw new RangeError('The value "' + length + '" is invalid for option "size"');
              }
              var buf = new Uint8Array(length);
              buf.__proto__ = Buffer2.prototype;
              return buf;
            }
            function Buffer2(arg, encodingOrOffset, length) {
              if (typeof arg === "number") {
                if (typeof encodingOrOffset === "string") {
                  throw new TypeError(
                    'The "string" argument must be of type string. Received type number'
                  );
                }
                return allocUnsafe(arg);
              }
              return from(arg, encodingOrOffset, length);
            }
            if (typeof Symbol !== "undefined" && Symbol.species != null && Buffer2[Symbol.species] === Buffer2) {
              Object.defineProperty(Buffer2, Symbol.species, {
                value: null,
                configurable: true,
                enumerable: false,
                writable: false
              });
            }
            Buffer2.poolSize = 8192;
            function from(value, encodingOrOffset, length) {
              if (typeof value === "string") {
                return fromString(value, encodingOrOffset);
              }
              if (ArrayBuffer.isView(value)) {
                return fromArrayLike(value);
              }
              if (value == null) {
                throw TypeError(
                  "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
                );
              }
              if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
                return fromArrayBuffer(value, encodingOrOffset, length);
              }
              if (typeof value === "number") {
                throw new TypeError(
                  'The "value" argument must not be of type number. Received type number'
                );
              }
              var valueOf = value.valueOf && value.valueOf();
              if (valueOf != null && valueOf !== value) {
                return Buffer2.from(valueOf, encodingOrOffset, length);
              }
              var b = fromObject(value);
              if (b)
                return b;
              if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
                return Buffer2.from(
                  value[Symbol.toPrimitive]("string"),
                  encodingOrOffset,
                  length
                );
              }
              throw new TypeError(
                "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
              );
            }
            Buffer2.from = function(value, encodingOrOffset, length) {
              return from(value, encodingOrOffset, length);
            };
            Buffer2.prototype.__proto__ = Uint8Array.prototype;
            Buffer2.__proto__ = Uint8Array;
            function assertSize(size) {
              if (typeof size !== "number") {
                throw new TypeError('"size" argument must be of type number');
              } else if (size < 0) {
                throw new RangeError('The value "' + size + '" is invalid for option "size"');
              }
            }
            function alloc(size, fill, encoding) {
              assertSize(size);
              if (size <= 0) {
                return createBuffer(size);
              }
              if (fill !== void 0) {
                return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
              }
              return createBuffer(size);
            }
            Buffer2.alloc = function(size, fill, encoding) {
              return alloc(size, fill, encoding);
            };
            function allocUnsafe(size) {
              assertSize(size);
              return createBuffer(size < 0 ? 0 : checked(size) | 0);
            }
            Buffer2.allocUnsafe = function(size) {
              return allocUnsafe(size);
            };
            Buffer2.allocUnsafeSlow = function(size) {
              return allocUnsafe(size);
            };
            function fromString(string, encoding) {
              if (typeof encoding !== "string" || encoding === "") {
                encoding = "utf8";
              }
              if (!Buffer2.isEncoding(encoding)) {
                throw new TypeError("Unknown encoding: " + encoding);
              }
              var length = byteLength(string, encoding) | 0;
              var buf = createBuffer(length);
              var actual = buf.write(string, encoding);
              if (actual !== length) {
                buf = buf.slice(0, actual);
              }
              return buf;
            }
            function fromArrayLike(array) {
              var length = array.length < 0 ? 0 : checked(array.length) | 0;
              var buf = createBuffer(length);
              for (var i = 0; i < length; i += 1) {
                buf[i] = array[i] & 255;
              }
              return buf;
            }
            function fromArrayBuffer(array, byteOffset, length) {
              if (byteOffset < 0 || array.byteLength < byteOffset) {
                throw new RangeError('"offset" is outside of buffer bounds');
              }
              if (array.byteLength < byteOffset + (length || 0)) {
                throw new RangeError('"length" is outside of buffer bounds');
              }
              var buf;
              if (byteOffset === void 0 && length === void 0) {
                buf = new Uint8Array(array);
              } else if (length === void 0) {
                buf = new Uint8Array(array, byteOffset);
              } else {
                buf = new Uint8Array(array, byteOffset, length);
              }
              buf.__proto__ = Buffer2.prototype;
              return buf;
            }
            function fromObject(obj) {
              if (Buffer2.isBuffer(obj)) {
                var len = checked(obj.length) | 0;
                var buf = createBuffer(len);
                if (buf.length === 0) {
                  return buf;
                }
                obj.copy(buf, 0, 0, len);
                return buf;
              }
              if (obj.length !== void 0) {
                if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
                  return createBuffer(0);
                }
                return fromArrayLike(obj);
              }
              if (obj.type === "Buffer" && Array.isArray(obj.data)) {
                return fromArrayLike(obj.data);
              }
            }
            function checked(length) {
              if (length >= K_MAX_LENGTH) {
                throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
              }
              return length | 0;
            }
            function SlowBuffer(length) {
              if (+length != length) {
                length = 0;
              }
              return Buffer2.alloc(+length);
            }
            Buffer2.isBuffer = function isBuffer(b) {
              return b != null && b._isBuffer === true && b !== Buffer2.prototype;
            };
            Buffer2.compare = function compare(a, b) {
              if (isInstance(a, Uint8Array))
                a = Buffer2.from(a, a.offset, a.byteLength);
              if (isInstance(b, Uint8Array))
                b = Buffer2.from(b, b.offset, b.byteLength);
              if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
                throw new TypeError(
                  'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
                );
              }
              if (a === b)
                return 0;
              var x = a.length;
              var y = b.length;
              for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                if (a[i] !== b[i]) {
                  x = a[i];
                  y = b[i];
                  break;
                }
              }
              if (x < y)
                return -1;
              if (y < x)
                return 1;
              return 0;
            };
            Buffer2.isEncoding = function isEncoding(encoding) {
              switch (String(encoding).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return true;
                default:
                  return false;
              }
            };
            Buffer2.concat = function concat(list, length) {
              if (!Array.isArray(list)) {
                throw new TypeError('"list" argument must be an Array of Buffers');
              }
              if (list.length === 0) {
                return Buffer2.alloc(0);
              }
              var i;
              if (length === void 0) {
                length = 0;
                for (i = 0; i < list.length; ++i) {
                  length += list[i].length;
                }
              }
              var buffer = Buffer2.allocUnsafe(length);
              var pos = 0;
              for (i = 0; i < list.length; ++i) {
                var buf = list[i];
                if (isInstance(buf, Uint8Array)) {
                  buf = Buffer2.from(buf);
                }
                if (!Buffer2.isBuffer(buf)) {
                  throw new TypeError('"list" argument must be an Array of Buffers');
                }
                buf.copy(buffer, pos);
                pos += buf.length;
              }
              return buffer;
            };
            function byteLength(string, encoding) {
              if (Buffer2.isBuffer(string)) {
                return string.length;
              }
              if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
                return string.byteLength;
              }
              if (typeof string !== "string") {
                throw new TypeError(
                  'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
                );
              }
              var len = string.length;
              var mustMatch = arguments.length > 2 && arguments[2] === true;
              if (!mustMatch && len === 0)
                return 0;
              var loweredCase = false;
              for (; ; ) {
                switch (encoding) {
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return len;
                  case "utf8":
                  case "utf-8":
                    return utf8ToBytes(string).length;
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return len * 2;
                  case "hex":
                    return len >>> 1;
                  case "base64":
                    return base64ToBytes(string).length;
                  default:
                    if (loweredCase) {
                      return mustMatch ? -1 : utf8ToBytes(string).length;
                    }
                    encoding = ("" + encoding).toLowerCase();
                    loweredCase = true;
                }
              }
            }
            Buffer2.byteLength = byteLength;
            function slowToString(encoding, start, end) {
              var loweredCase = false;
              if (start === void 0 || start < 0) {
                start = 0;
              }
              if (start > this.length) {
                return "";
              }
              if (end === void 0 || end > this.length) {
                end = this.length;
              }
              if (end <= 0) {
                return "";
              }
              end >>>= 0;
              start >>>= 0;
              if (end <= start) {
                return "";
              }
              if (!encoding)
                encoding = "utf8";
              while (true) {
                switch (encoding) {
                  case "hex":
                    return hexSlice(this, start, end);
                  case "utf8":
                  case "utf-8":
                    return utf8Slice(this, start, end);
                  case "ascii":
                    return asciiSlice(this, start, end);
                  case "latin1":
                  case "binary":
                    return latin1Slice(this, start, end);
                  case "base64":
                    return base64Slice(this, start, end);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return utf16leSlice(this, start, end);
                  default:
                    if (loweredCase)
                      throw new TypeError("Unknown encoding: " + encoding);
                    encoding = (encoding + "").toLowerCase();
                    loweredCase = true;
                }
              }
            }
            Buffer2.prototype._isBuffer = true;
            function swap(b, n2, m) {
              var i = b[n2];
              b[n2] = b[m];
              b[m] = i;
            }
            Buffer2.prototype.swap16 = function swap16() {
              var len = this.length;
              if (len % 2 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 16-bits");
              }
              for (var i = 0; i < len; i += 2) {
                swap(this, i, i + 1);
              }
              return this;
            };
            Buffer2.prototype.swap32 = function swap32() {
              var len = this.length;
              if (len % 4 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 32-bits");
              }
              for (var i = 0; i < len; i += 4) {
                swap(this, i, i + 3);
                swap(this, i + 1, i + 2);
              }
              return this;
            };
            Buffer2.prototype.swap64 = function swap64() {
              var len = this.length;
              if (len % 8 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 64-bits");
              }
              for (var i = 0; i < len; i += 8) {
                swap(this, i, i + 7);
                swap(this, i + 1, i + 6);
                swap(this, i + 2, i + 5);
                swap(this, i + 3, i + 4);
              }
              return this;
            };
            Buffer2.prototype.toString = function toString() {
              var length = this.length;
              if (length === 0)
                return "";
              if (arguments.length === 0)
                return utf8Slice(this, 0, length);
              return slowToString.apply(this, arguments);
            };
            Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
            Buffer2.prototype.equals = function equals(b) {
              if (!Buffer2.isBuffer(b))
                throw new TypeError("Argument must be a Buffer");
              if (this === b)
                return true;
              return Buffer2.compare(this, b) === 0;
            };
            Buffer2.prototype.inspect = function inspect() {
              var str = "";
              var max = exports3.INSPECT_MAX_BYTES;
              str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
              if (this.length > max)
                str += " ... ";
              return "<Buffer " + str + ">";
            };
            Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
              if (isInstance(target, Uint8Array)) {
                target = Buffer2.from(target, target.offset, target.byteLength);
              }
              if (!Buffer2.isBuffer(target)) {
                throw new TypeError(
                  'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
                );
              }
              if (start === void 0) {
                start = 0;
              }
              if (end === void 0) {
                end = target ? target.length : 0;
              }
              if (thisStart === void 0) {
                thisStart = 0;
              }
              if (thisEnd === void 0) {
                thisEnd = this.length;
              }
              if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                throw new RangeError("out of range index");
              }
              if (thisStart >= thisEnd && start >= end) {
                return 0;
              }
              if (thisStart >= thisEnd) {
                return -1;
              }
              if (start >= end) {
                return 1;
              }
              start >>>= 0;
              end >>>= 0;
              thisStart >>>= 0;
              thisEnd >>>= 0;
              if (this === target)
                return 0;
              var x = thisEnd - thisStart;
              var y = end - start;
              var len = Math.min(x, y);
              var thisCopy = this.slice(thisStart, thisEnd);
              var targetCopy = target.slice(start, end);
              for (var i = 0; i < len; ++i) {
                if (thisCopy[i] !== targetCopy[i]) {
                  x = thisCopy[i];
                  y = targetCopy[i];
                  break;
                }
              }
              if (x < y)
                return -1;
              if (y < x)
                return 1;
              return 0;
            };
            function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
              if (buffer.length === 0)
                return -1;
              if (typeof byteOffset === "string") {
                encoding = byteOffset;
                byteOffset = 0;
              } else if (byteOffset > 2147483647) {
                byteOffset = 2147483647;
              } else if (byteOffset < -2147483648) {
                byteOffset = -2147483648;
              }
              byteOffset = +byteOffset;
              if (numberIsNaN(byteOffset)) {
                byteOffset = dir ? 0 : buffer.length - 1;
              }
              if (byteOffset < 0)
                byteOffset = buffer.length + byteOffset;
              if (byteOffset >= buffer.length) {
                if (dir)
                  return -1;
                else
                  byteOffset = buffer.length - 1;
              } else if (byteOffset < 0) {
                if (dir)
                  byteOffset = 0;
                else
                  return -1;
              }
              if (typeof val === "string") {
                val = Buffer2.from(val, encoding);
              }
              if (Buffer2.isBuffer(val)) {
                if (val.length === 0) {
                  return -1;
                }
                return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
              } else if (typeof val === "number") {
                val = val & 255;
                if (typeof Uint8Array.prototype.indexOf === "function") {
                  if (dir) {
                    return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                  } else {
                    return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                  }
                }
                return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
              }
              throw new TypeError("val must be string, number or Buffer");
            }
            function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
              var indexSize = 1;
              var arrLength = arr.length;
              var valLength = val.length;
              if (encoding !== void 0) {
                encoding = String(encoding).toLowerCase();
                if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
                  if (arr.length < 2 || val.length < 2) {
                    return -1;
                  }
                  indexSize = 2;
                  arrLength /= 2;
                  valLength /= 2;
                  byteOffset /= 2;
                }
              }
              function read(buf, i2) {
                if (indexSize === 1) {
                  return buf[i2];
                } else {
                  return buf.readUInt16BE(i2 * indexSize);
                }
              }
              var i;
              if (dir) {
                var foundIndex = -1;
                for (i = byteOffset; i < arrLength; i++) {
                  if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                    if (foundIndex === -1)
                      foundIndex = i;
                    if (i - foundIndex + 1 === valLength)
                      return foundIndex * indexSize;
                  } else {
                    if (foundIndex !== -1)
                      i -= i - foundIndex;
                    foundIndex = -1;
                  }
                }
              } else {
                if (byteOffset + valLength > arrLength)
                  byteOffset = arrLength - valLength;
                for (i = byteOffset; i >= 0; i--) {
                  var found = true;
                  for (var j = 0; j < valLength; j++) {
                    if (read(arr, i + j) !== read(val, j)) {
                      found = false;
                      break;
                    }
                  }
                  if (found)
                    return i;
                }
              }
              return -1;
            }
            Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
              return this.indexOf(val, byteOffset, encoding) !== -1;
            };
            Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
              return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
            };
            Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
              return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
            };
            function hexWrite(buf, string, offset, length) {
              offset = Number(offset) || 0;
              var remaining = buf.length - offset;
              if (!length) {
                length = remaining;
              } else {
                length = Number(length);
                if (length > remaining) {
                  length = remaining;
                }
              }
              var strLen = string.length;
              if (length > strLen / 2) {
                length = strLen / 2;
              }
              for (var i = 0; i < length; ++i) {
                var parsed = parseInt(string.substr(i * 2, 2), 16);
                if (numberIsNaN(parsed))
                  return i;
                buf[offset + i] = parsed;
              }
              return i;
            }
            function utf8Write(buf, string, offset, length) {
              return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
            }
            function asciiWrite(buf, string, offset, length) {
              return blitBuffer(asciiToBytes(string), buf, offset, length);
            }
            function latin1Write(buf, string, offset, length) {
              return asciiWrite(buf, string, offset, length);
            }
            function base64Write(buf, string, offset, length) {
              return blitBuffer(base64ToBytes(string), buf, offset, length);
            }
            function ucs2Write(buf, string, offset, length) {
              return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
            }
            Buffer2.prototype.write = function write(string, offset, length, encoding) {
              if (offset === void 0) {
                encoding = "utf8";
                length = this.length;
                offset = 0;
              } else if (length === void 0 && typeof offset === "string") {
                encoding = offset;
                length = this.length;
                offset = 0;
              } else if (isFinite(offset)) {
                offset = offset >>> 0;
                if (isFinite(length)) {
                  length = length >>> 0;
                  if (encoding === void 0)
                    encoding = "utf8";
                } else {
                  encoding = length;
                  length = void 0;
                }
              } else {
                throw new Error(
                  "Buffer.write(string, encoding, offset[, length]) is no longer supported"
                );
              }
              var remaining = this.length - offset;
              if (length === void 0 || length > remaining)
                length = remaining;
              if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
                throw new RangeError("Attempt to write outside buffer bounds");
              }
              if (!encoding)
                encoding = "utf8";
              var loweredCase = false;
              for (; ; ) {
                switch (encoding) {
                  case "hex":
                    return hexWrite(this, string, offset, length);
                  case "utf8":
                  case "utf-8":
                    return utf8Write(this, string, offset, length);
                  case "ascii":
                    return asciiWrite(this, string, offset, length);
                  case "latin1":
                  case "binary":
                    return latin1Write(this, string, offset, length);
                  case "base64":
                    return base64Write(this, string, offset, length);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return ucs2Write(this, string, offset, length);
                  default:
                    if (loweredCase)
                      throw new TypeError("Unknown encoding: " + encoding);
                    encoding = ("" + encoding).toLowerCase();
                    loweredCase = true;
                }
              }
            };
            Buffer2.prototype.toJSON = function toJSON() {
              return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
              };
            };
            function base64Slice(buf, start, end) {
              if (start === 0 && end === buf.length) {
                return base64.fromByteArray(buf);
              } else {
                return base64.fromByteArray(buf.slice(start, end));
              }
            }
            function utf8Slice(buf, start, end) {
              end = Math.min(buf.length, end);
              var res = [];
              var i = start;
              while (i < end) {
                var firstByte = buf[i];
                var codePoint = null;
                var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
                if (i + bytesPerSequence <= end) {
                  var secondByte, thirdByte, fourthByte, tempCodePoint;
                  switch (bytesPerSequence) {
                    case 1:
                      if (firstByte < 128) {
                        codePoint = firstByte;
                      }
                      break;
                    case 2:
                      secondByte = buf[i + 1];
                      if ((secondByte & 192) === 128) {
                        tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                        if (tempCodePoint > 127) {
                          codePoint = tempCodePoint;
                        }
                      }
                      break;
                    case 3:
                      secondByte = buf[i + 1];
                      thirdByte = buf[i + 2];
                      if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                        if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                          codePoint = tempCodePoint;
                        }
                      }
                      break;
                    case 4:
                      secondByte = buf[i + 1];
                      thirdByte = buf[i + 2];
                      fourthByte = buf[i + 3];
                      if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                          codePoint = tempCodePoint;
                        }
                      }
                  }
                }
                if (codePoint === null) {
                  codePoint = 65533;
                  bytesPerSequence = 1;
                } else if (codePoint > 65535) {
                  codePoint -= 65536;
                  res.push(codePoint >>> 10 & 1023 | 55296);
                  codePoint = 56320 | codePoint & 1023;
                }
                res.push(codePoint);
                i += bytesPerSequence;
              }
              return decodeCodePointsArray(res);
            }
            var MAX_ARGUMENTS_LENGTH = 4096;
            function decodeCodePointsArray(codePoints) {
              var len = codePoints.length;
              if (len <= MAX_ARGUMENTS_LENGTH) {
                return String.fromCharCode.apply(String, codePoints);
              }
              var res = "";
              var i = 0;
              while (i < len) {
                res += String.fromCharCode.apply(
                  String,
                  codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
                );
              }
              return res;
            }
            function asciiSlice(buf, start, end) {
              var ret = "";
              end = Math.min(buf.length, end);
              for (var i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i] & 127);
              }
              return ret;
            }
            function latin1Slice(buf, start, end) {
              var ret = "";
              end = Math.min(buf.length, end);
              for (var i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i]);
              }
              return ret;
            }
            function hexSlice(buf, start, end) {
              var len = buf.length;
              if (!start || start < 0)
                start = 0;
              if (!end || end < 0 || end > len)
                end = len;
              var out = "";
              for (var i = start; i < end; ++i) {
                out += toHex(buf[i]);
              }
              return out;
            }
            function utf16leSlice(buf, start, end) {
              var bytes = buf.slice(start, end);
              var res = "";
              for (var i = 0; i < bytes.length; i += 2) {
                res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
              }
              return res;
            }
            Buffer2.prototype.slice = function slice(start, end) {
              var len = this.length;
              start = ~~start;
              end = end === void 0 ? len : ~~end;
              if (start < 0) {
                start += len;
                if (start < 0)
                  start = 0;
              } else if (start > len) {
                start = len;
              }
              if (end < 0) {
                end += len;
                if (end < 0)
                  end = 0;
              } else if (end > len) {
                end = len;
              }
              if (end < start)
                end = start;
              var newBuf = this.subarray(start, end);
              newBuf.__proto__ = Buffer2.prototype;
              return newBuf;
            };
            function checkOffset(offset, ext, length) {
              if (offset % 1 !== 0 || offset < 0)
                throw new RangeError("offset is not uint");
              if (offset + ext > length)
                throw new RangeError("Trying to access beyond buffer length");
            }
            Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
              offset = offset >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert)
                checkOffset(offset, byteLength2, this.length);
              var val = this[offset];
              var mul = 1;
              var i = 0;
              while (++i < byteLength2 && (mul *= 256)) {
                val += this[offset + i] * mul;
              }
              return val;
            };
            Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
              offset = offset >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert) {
                checkOffset(offset, byteLength2, this.length);
              }
              var val = this[offset + --byteLength2];
              var mul = 1;
              while (byteLength2 > 0 && (mul *= 256)) {
                val += this[offset + --byteLength2] * mul;
              }
              return val;
            };
            Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 1, this.length);
              return this[offset];
            };
            Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 2, this.length);
              return this[offset] | this[offset + 1] << 8;
            };
            Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 2, this.length);
              return this[offset] << 8 | this[offset + 1];
            };
            Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 4, this.length);
              return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
            };
            Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 4, this.length);
              return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
            };
            Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
              offset = offset >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert)
                checkOffset(offset, byteLength2, this.length);
              var val = this[offset];
              var mul = 1;
              var i = 0;
              while (++i < byteLength2 && (mul *= 256)) {
                val += this[offset + i] * mul;
              }
              mul *= 128;
              if (val >= mul)
                val -= Math.pow(2, 8 * byteLength2);
              return val;
            };
            Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
              offset = offset >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert)
                checkOffset(offset, byteLength2, this.length);
              var i = byteLength2;
              var mul = 1;
              var val = this[offset + --i];
              while (i > 0 && (mul *= 256)) {
                val += this[offset + --i] * mul;
              }
              mul *= 128;
              if (val >= mul)
                val -= Math.pow(2, 8 * byteLength2);
              return val;
            };
            Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 1, this.length);
              if (!(this[offset] & 128))
                return this[offset];
              return (255 - this[offset] + 1) * -1;
            };
            Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 2, this.length);
              var val = this[offset] | this[offset + 1] << 8;
              return val & 32768 ? val | 4294901760 : val;
            };
            Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 2, this.length);
              var val = this[offset + 1] | this[offset] << 8;
              return val & 32768 ? val | 4294901760 : val;
            };
            Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 4, this.length);
              return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
            };
            Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 4, this.length);
              return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
            };
            Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 4, this.length);
              return ieee754.read(this, offset, true, 23, 4);
            };
            Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 4, this.length);
              return ieee754.read(this, offset, false, 23, 4);
            };
            Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 8, this.length);
              return ieee754.read(this, offset, true, 52, 8);
            };
            Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 8, this.length);
              return ieee754.read(this, offset, false, 52, 8);
            };
            function checkInt(buf, value, offset, ext, max, min) {
              if (!Buffer2.isBuffer(buf))
                throw new TypeError('"buffer" argument must be a Buffer instance');
              if (value > max || value < min)
                throw new RangeError('"value" argument is out of bounds');
              if (offset + ext > buf.length)
                throw new RangeError("Index out of range");
            }
            Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
              value = +value;
              offset = offset >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
                checkInt(this, value, offset, byteLength2, maxBytes, 0);
              }
              var mul = 1;
              var i = 0;
              this[offset] = value & 255;
              while (++i < byteLength2 && (mul *= 256)) {
                this[offset + i] = value / mul & 255;
              }
              return offset + byteLength2;
            };
            Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
              value = +value;
              offset = offset >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
                checkInt(this, value, offset, byteLength2, maxBytes, 0);
              }
              var i = byteLength2 - 1;
              var mul = 1;
              this[offset + i] = value & 255;
              while (--i >= 0 && (mul *= 256)) {
                this[offset + i] = value / mul & 255;
              }
              return offset + byteLength2;
            };
            Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 1, 255, 0);
              this[offset] = value & 255;
              return offset + 1;
            };
            Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 2, 65535, 0);
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
              return offset + 2;
            };
            Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 2, 65535, 0);
              this[offset] = value >>> 8;
              this[offset + 1] = value & 255;
              return offset + 2;
            };
            Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 4, 4294967295, 0);
              this[offset + 3] = value >>> 24;
              this[offset + 2] = value >>> 16;
              this[offset + 1] = value >>> 8;
              this[offset] = value & 255;
              return offset + 4;
            };
            Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 4, 4294967295, 0);
              this[offset] = value >>> 24;
              this[offset + 1] = value >>> 16;
              this[offset + 2] = value >>> 8;
              this[offset + 3] = value & 255;
              return offset + 4;
            };
            Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength2 - 1);
                checkInt(this, value, offset, byteLength2, limit - 1, -limit);
              }
              var i = 0;
              var mul = 1;
              var sub = 0;
              this[offset] = value & 255;
              while (++i < byteLength2 && (mul *= 256)) {
                if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                  sub = 1;
                }
                this[offset + i] = (value / mul >> 0) - sub & 255;
              }
              return offset + byteLength2;
            };
            Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength2 - 1);
                checkInt(this, value, offset, byteLength2, limit - 1, -limit);
              }
              var i = byteLength2 - 1;
              var mul = 1;
              var sub = 0;
              this[offset + i] = value & 255;
              while (--i >= 0 && (mul *= 256)) {
                if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                  sub = 1;
                }
                this[offset + i] = (value / mul >> 0) - sub & 255;
              }
              return offset + byteLength2;
            };
            Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 1, 127, -128);
              if (value < 0)
                value = 255 + value + 1;
              this[offset] = value & 255;
              return offset + 1;
            };
            Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 2, 32767, -32768);
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
              return offset + 2;
            };
            Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 2, 32767, -32768);
              this[offset] = value >>> 8;
              this[offset + 1] = value & 255;
              return offset + 2;
            };
            Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 4, 2147483647, -2147483648);
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
              this[offset + 2] = value >>> 16;
              this[offset + 3] = value >>> 24;
              return offset + 4;
            };
            Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 4, 2147483647, -2147483648);
              if (value < 0)
                value = 4294967295 + value + 1;
              this[offset] = value >>> 24;
              this[offset + 1] = value >>> 16;
              this[offset + 2] = value >>> 8;
              this[offset + 3] = value & 255;
              return offset + 4;
            };
            function checkIEEE754(buf, value, offset, ext, max, min) {
              if (offset + ext > buf.length)
                throw new RangeError("Index out of range");
              if (offset < 0)
                throw new RangeError("Index out of range");
            }
            function writeFloat(buf, value, offset, littleEndian, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) {
                checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
              }
              ieee754.write(buf, value, offset, littleEndian, 23, 4);
              return offset + 4;
            }
            Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
              return writeFloat(this, value, offset, true, noAssert);
            };
            Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
              return writeFloat(this, value, offset, false, noAssert);
            };
            function writeDouble(buf, value, offset, littleEndian, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) {
                checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
              }
              ieee754.write(buf, value, offset, littleEndian, 52, 8);
              return offset + 8;
            }
            Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
              return writeDouble(this, value, offset, true, noAssert);
            };
            Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
              return writeDouble(this, value, offset, false, noAssert);
            };
            Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
              if (!Buffer2.isBuffer(target))
                throw new TypeError("argument should be a Buffer");
              if (!start)
                start = 0;
              if (!end && end !== 0)
                end = this.length;
              if (targetStart >= target.length)
                targetStart = target.length;
              if (!targetStart)
                targetStart = 0;
              if (end > 0 && end < start)
                end = start;
              if (end === start)
                return 0;
              if (target.length === 0 || this.length === 0)
                return 0;
              if (targetStart < 0) {
                throw new RangeError("targetStart out of bounds");
              }
              if (start < 0 || start >= this.length)
                throw new RangeError("Index out of range");
              if (end < 0)
                throw new RangeError("sourceEnd out of bounds");
              if (end > this.length)
                end = this.length;
              if (target.length - targetStart < end - start) {
                end = target.length - targetStart + start;
              }
              var len = end - start;
              if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
                this.copyWithin(targetStart, start, end);
              } else if (this === target && start < targetStart && targetStart < end) {
                for (var i = len - 1; i >= 0; --i) {
                  target[i + targetStart] = this[i + start];
                }
              } else {
                Uint8Array.prototype.set.call(
                  target,
                  this.subarray(start, end),
                  targetStart
                );
              }
              return len;
            };
            Buffer2.prototype.fill = function fill(val, start, end, encoding) {
              if (typeof val === "string") {
                if (typeof start === "string") {
                  encoding = start;
                  start = 0;
                  end = this.length;
                } else if (typeof end === "string") {
                  encoding = end;
                  end = this.length;
                }
                if (encoding !== void 0 && typeof encoding !== "string") {
                  throw new TypeError("encoding must be a string");
                }
                if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
                  throw new TypeError("Unknown encoding: " + encoding);
                }
                if (val.length === 1) {
                  var code = val.charCodeAt(0);
                  if (encoding === "utf8" && code < 128 || encoding === "latin1") {
                    val = code;
                  }
                }
              } else if (typeof val === "number") {
                val = val & 255;
              }
              if (start < 0 || this.length < start || this.length < end) {
                throw new RangeError("Out of range index");
              }
              if (end <= start) {
                return this;
              }
              start = start >>> 0;
              end = end === void 0 ? this.length : end >>> 0;
              if (!val)
                val = 0;
              var i;
              if (typeof val === "number") {
                for (i = start; i < end; ++i) {
                  this[i] = val;
                }
              } else {
                var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
                var len = bytes.length;
                if (len === 0) {
                  throw new TypeError('The value "' + val + '" is invalid for argument "value"');
                }
                for (i = 0; i < end - start; ++i) {
                  this[i + start] = bytes[i % len];
                }
              }
              return this;
            };
            var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
            function base64clean(str) {
              str = str.split("=")[0];
              str = str.trim().replace(INVALID_BASE64_RE, "");
              if (str.length < 2)
                return "";
              while (str.length % 4 !== 0) {
                str = str + "=";
              }
              return str;
            }
            function toHex(n2) {
              if (n2 < 16)
                return "0" + n2.toString(16);
              return n2.toString(16);
            }
            function utf8ToBytes(string, units) {
              units = units || Infinity;
              var codePoint;
              var length = string.length;
              var leadSurrogate = null;
              var bytes = [];
              for (var i = 0; i < length; ++i) {
                codePoint = string.charCodeAt(i);
                if (codePoint > 55295 && codePoint < 57344) {
                  if (!leadSurrogate) {
                    if (codePoint > 56319) {
                      if ((units -= 3) > -1)
                        bytes.push(239, 191, 189);
                      continue;
                    } else if (i + 1 === length) {
                      if ((units -= 3) > -1)
                        bytes.push(239, 191, 189);
                      continue;
                    }
                    leadSurrogate = codePoint;
                    continue;
                  }
                  if (codePoint < 56320) {
                    if ((units -= 3) > -1)
                      bytes.push(239, 191, 189);
                    leadSurrogate = codePoint;
                    continue;
                  }
                  codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
                } else if (leadSurrogate) {
                  if ((units -= 3) > -1)
                    bytes.push(239, 191, 189);
                }
                leadSurrogate = null;
                if (codePoint < 128) {
                  if ((units -= 1) < 0)
                    break;
                  bytes.push(codePoint);
                } else if (codePoint < 2048) {
                  if ((units -= 2) < 0)
                    break;
                  bytes.push(
                    codePoint >> 6 | 192,
                    codePoint & 63 | 128
                  );
                } else if (codePoint < 65536) {
                  if ((units -= 3) < 0)
                    break;
                  bytes.push(
                    codePoint >> 12 | 224,
                    codePoint >> 6 & 63 | 128,
                    codePoint & 63 | 128
                  );
                } else if (codePoint < 1114112) {
                  if ((units -= 4) < 0)
                    break;
                  bytes.push(
                    codePoint >> 18 | 240,
                    codePoint >> 12 & 63 | 128,
                    codePoint >> 6 & 63 | 128,
                    codePoint & 63 | 128
                  );
                } else {
                  throw new Error("Invalid code point");
                }
              }
              return bytes;
            }
            function asciiToBytes(str) {
              var byteArray = [];
              for (var i = 0; i < str.length; ++i) {
                byteArray.push(str.charCodeAt(i) & 255);
              }
              return byteArray;
            }
            function utf16leToBytes(str, units) {
              var c, hi, lo;
              var byteArray = [];
              for (var i = 0; i < str.length; ++i) {
                if ((units -= 2) < 0)
                  break;
                c = str.charCodeAt(i);
                hi = c >> 8;
                lo = c % 256;
                byteArray.push(lo);
                byteArray.push(hi);
              }
              return byteArray;
            }
            function base64ToBytes(str) {
              return base64.toByteArray(base64clean(str));
            }
            function blitBuffer(src, dst, offset, length) {
              for (var i = 0; i < length; ++i) {
                if (i + offset >= dst.length || i >= src.length)
                  break;
                dst[i + offset] = src[i];
              }
              return i;
            }
            function isInstance(obj, type) {
              return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
            }
            function numberIsNaN(obj) {
              return obj !== obj;
            }
          }).call(this);
        }).call(this, require2("buffer").Buffer);
      }, { "base64-js": 48, "buffer": 50, "ieee754": 52 }], 51: [function(require2, module3, exports3) {
        "use strict";
        var R = typeof Reflect === "object" ? Reflect : null;
        var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
          return Function.prototype.apply.call(target, receiver, args);
        };
        var ReflectOwnKeys;
        if (R && typeof R.ownKeys === "function") {
          ReflectOwnKeys = R.ownKeys;
        } else if (Object.getOwnPropertySymbols) {
          ReflectOwnKeys = function ReflectOwnKeys2(target) {
            return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
          };
        } else {
          ReflectOwnKeys = function ReflectOwnKeys2(target) {
            return Object.getOwnPropertyNames(target);
          };
        }
        function ProcessEmitWarning(warning) {
          if (console && console.warn)
            console.warn(warning);
        }
        var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
          return value !== value;
        };
        function EventEmitter() {
          EventEmitter.init.call(this);
        }
        module3.exports = EventEmitter;
        module3.exports.once = once;
        EventEmitter.EventEmitter = EventEmitter;
        EventEmitter.prototype._events = void 0;
        EventEmitter.prototype._eventsCount = 0;
        EventEmitter.prototype._maxListeners = void 0;
        var defaultMaxListeners = 10;
        function checkListener(listener) {
          if (typeof listener !== "function") {
            throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
          }
        }
        Object.defineProperty(EventEmitter, "defaultMaxListeners", {
          enumerable: true,
          get: function() {
            return defaultMaxListeners;
          },
          set: function(arg) {
            if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
              throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
            }
            defaultMaxListeners = arg;
          }
        });
        EventEmitter.init = function() {
          if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
            this._events = /* @__PURE__ */ Object.create(null);
            this._eventsCount = 0;
          }
          this._maxListeners = this._maxListeners || void 0;
        };
        EventEmitter.prototype.setMaxListeners = function setMaxListeners(n2) {
          if (typeof n2 !== "number" || n2 < 0 || NumberIsNaN(n2)) {
            throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n2 + ".");
          }
          this._maxListeners = n2;
          return this;
        };
        function _getMaxListeners(that) {
          if (that._maxListeners === void 0)
            return EventEmitter.defaultMaxListeners;
          return that._maxListeners;
        }
        EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
          return _getMaxListeners(this);
        };
        EventEmitter.prototype.emit = function emit(type) {
          var args = [];
          for (var i = 1; i < arguments.length; i++)
            args.push(arguments[i]);
          var doError = type === "error";
          var events = this._events;
          if (events !== void 0)
            doError = doError && events.error === void 0;
          else if (!doError)
            return false;
          if (doError) {
            var er;
            if (args.length > 0)
              er = args[0];
            if (er instanceof Error) {
              throw er;
            }
            var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
            err.context = er;
            throw err;
          }
          var handler = events[type];
          if (handler === void 0)
            return false;
          if (typeof handler === "function") {
            ReflectApply(handler, this, args);
          } else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i = 0; i < len; ++i)
              ReflectApply(listeners[i], this, args);
          }
          return true;
        };
        function _addListener(target, type, listener, prepend) {
          var m;
          var events;
          var existing;
          checkListener(listener);
          events = target._events;
          if (events === void 0) {
            events = target._events = /* @__PURE__ */ Object.create(null);
            target._eventsCount = 0;
          } else {
            if (events.newListener !== void 0) {
              target.emit(
                "newListener",
                type,
                listener.listener ? listener.listener : listener
              );
              events = target._events;
            }
            existing = events[type];
          }
          if (existing === void 0) {
            existing = events[type] = listener;
            ++target._eventsCount;
          } else {
            if (typeof existing === "function") {
              existing = events[type] = prepend ? [listener, existing] : [existing, listener];
            } else if (prepend) {
              existing.unshift(listener);
            } else {
              existing.push(listener);
            }
            m = _getMaxListeners(target);
            if (m > 0 && existing.length > m && !existing.warned) {
              existing.warned = true;
              var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
              w.name = "MaxListenersExceededWarning";
              w.emitter = target;
              w.type = type;
              w.count = existing.length;
              ProcessEmitWarning(w);
            }
          }
          return target;
        }
        EventEmitter.prototype.addListener = function addListener(type, listener) {
          return _addListener(this, type, listener, false);
        };
        EventEmitter.prototype.on = EventEmitter.prototype.addListener;
        EventEmitter.prototype.prependListener = function prependListener(type, listener) {
          return _addListener(this, type, listener, true);
        };
        function onceWrapper() {
          if (!this.fired) {
            this.target.removeListener(this.type, this.wrapFn);
            this.fired = true;
            if (arguments.length === 0)
              return this.listener.call(this.target);
            return this.listener.apply(this.target, arguments);
          }
        }
        function _onceWrap(target, type, listener) {
          var state = { fired: false, wrapFn: void 0, target, type, listener };
          var wrapped = onceWrapper.bind(state);
          wrapped.listener = listener;
          state.wrapFn = wrapped;
          return wrapped;
        }
        EventEmitter.prototype.once = function once2(type, listener) {
          checkListener(listener);
          this.on(type, _onceWrap(this, type, listener));
          return this;
        };
        EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
          checkListener(listener);
          this.prependListener(type, _onceWrap(this, type, listener));
          return this;
        };
        EventEmitter.prototype.removeListener = function removeListener(type, listener) {
          var list, events, position, i, originalListener;
          checkListener(listener);
          events = this._events;
          if (events === void 0)
            return this;
          list = events[type];
          if (list === void 0)
            return this;
          if (list === listener || list.listener === listener) {
            if (--this._eventsCount === 0)
              this._events = /* @__PURE__ */ Object.create(null);
            else {
              delete events[type];
              if (events.removeListener)
                this.emit("removeListener", type, list.listener || listener);
            }
          } else if (typeof list !== "function") {
            position = -1;
            for (i = list.length - 1; i >= 0; i--) {
              if (list[i] === listener || list[i].listener === listener) {
                originalListener = list[i].listener;
                position = i;
                break;
              }
            }
            if (position < 0)
              return this;
            if (position === 0)
              list.shift();
            else {
              spliceOne(list, position);
            }
            if (list.length === 1)
              events[type] = list[0];
            if (events.removeListener !== void 0)
              this.emit("removeListener", type, originalListener || listener);
          }
          return this;
        };
        EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
        EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
          var listeners, events, i;
          events = this._events;
          if (events === void 0)
            return this;
          if (events.removeListener === void 0) {
            if (arguments.length === 0) {
              this._events = /* @__PURE__ */ Object.create(null);
              this._eventsCount = 0;
            } else if (events[type] !== void 0) {
              if (--this._eventsCount === 0)
                this._events = /* @__PURE__ */ Object.create(null);
              else
                delete events[type];
            }
            return this;
          }
          if (arguments.length === 0) {
            var keys = Object.keys(events);
            var key;
            for (i = 0; i < keys.length; ++i) {
              key = keys[i];
              if (key === "removeListener")
                continue;
              this.removeAllListeners(key);
            }
            this.removeAllListeners("removeListener");
            this._events = /* @__PURE__ */ Object.create(null);
            this._eventsCount = 0;
            return this;
          }
          listeners = events[type];
          if (typeof listeners === "function") {
            this.removeListener(type, listeners);
          } else if (listeners !== void 0) {
            for (i = listeners.length - 1; i >= 0; i--) {
              this.removeListener(type, listeners[i]);
            }
          }
          return this;
        };
        function _listeners(target, type, unwrap) {
          var events = target._events;
          if (events === void 0)
            return [];
          var evlistener = events[type];
          if (evlistener === void 0)
            return [];
          if (typeof evlistener === "function")
            return unwrap ? [evlistener.listener || evlistener] : [evlistener];
          return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
        }
        EventEmitter.prototype.listeners = function listeners(type) {
          return _listeners(this, type, true);
        };
        EventEmitter.prototype.rawListeners = function rawListeners(type) {
          return _listeners(this, type, false);
        };
        EventEmitter.listenerCount = function(emitter, type) {
          if (typeof emitter.listenerCount === "function") {
            return emitter.listenerCount(type);
          } else {
            return listenerCount.call(emitter, type);
          }
        };
        EventEmitter.prototype.listenerCount = listenerCount;
        function listenerCount(type) {
          var events = this._events;
          if (events !== void 0) {
            var evlistener = events[type];
            if (typeof evlistener === "function") {
              return 1;
            } else if (evlistener !== void 0) {
              return evlistener.length;
            }
          }
          return 0;
        }
        EventEmitter.prototype.eventNames = function eventNames() {
          return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
        };
        function arrayClone(arr, n2) {
          var copy = new Array(n2);
          for (var i = 0; i < n2; ++i)
            copy[i] = arr[i];
          return copy;
        }
        function spliceOne(list, index) {
          for (; index + 1 < list.length; index++)
            list[index] = list[index + 1];
          list.pop();
        }
        function unwrapListeners(arr) {
          var ret = new Array(arr.length);
          for (var i = 0; i < ret.length; ++i) {
            ret[i] = arr[i].listener || arr[i];
          }
          return ret;
        }
        function once(emitter, name) {
          return new Promise(function(resolve, reject) {
            function eventListener() {
              if (errorListener !== void 0) {
                emitter.removeListener("error", errorListener);
              }
              resolve([].slice.call(arguments));
            }
            ;
            var errorListener;
            if (name !== "error") {
              errorListener = function errorListener2(err) {
                emitter.removeListener(name, eventListener);
                reject(err);
              };
              emitter.once("error", errorListener);
            }
            emitter.once(name, eventListener);
          });
        }
      }, {}], 52: [function(require2, module3, exports3) {
        exports3.read = function(buffer, offset, isLE, mLen, nBytes) {
          var e2, m;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var nBits = -7;
          var i = isLE ? nBytes - 1 : 0;
          var d = isLE ? -1 : 1;
          var s = buffer[offset + i];
          i += d;
          e2 = s & (1 << -nBits) - 1;
          s >>= -nBits;
          nBits += eLen;
          for (; nBits > 0; e2 = e2 * 256 + buffer[offset + i], i += d, nBits -= 8) {
          }
          m = e2 & (1 << -nBits) - 1;
          e2 >>= -nBits;
          nBits += mLen;
          for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
          }
          if (e2 === 0) {
            e2 = 1 - eBias;
          } else if (e2 === eMax) {
            return m ? NaN : (s ? -1 : 1) * Infinity;
          } else {
            m = m + Math.pow(2, mLen);
            e2 = e2 - eBias;
          }
          return (s ? -1 : 1) * m * Math.pow(2, e2 - mLen);
        };
        exports3.write = function(buffer, value, offset, isLE, mLen, nBytes) {
          var e2, m, c;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
          var i = isLE ? 0 : nBytes - 1;
          var d = isLE ? 1 : -1;
          var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
          value = Math.abs(value);
          if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e2 = eMax;
          } else {
            e2 = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e2)) < 1) {
              e2--;
              c *= 2;
            }
            if (e2 + eBias >= 1) {
              value += rt / c;
            } else {
              value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
              e2++;
              c /= 2;
            }
            if (e2 + eBias >= eMax) {
              m = 0;
              e2 = eMax;
            } else if (e2 + eBias >= 1) {
              m = (value * c - 1) * Math.pow(2, mLen);
              e2 = e2 + eBias;
            } else {
              m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
              e2 = 0;
            }
          }
          for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
          }
          e2 = e2 << mLen | m;
          eLen += mLen;
          for (; eLen > 0; buffer[offset + i] = e2 & 255, i += d, e2 /= 256, eLen -= 8) {
          }
          buffer[offset + i - d] |= s * 128;
        };
      }, {}], 53: [function(require2, module3, exports3) {
        if (typeof Object.create === "function") {
          module3.exports = function inherits(ctor, superCtor) {
            if (superCtor) {
              ctor.super_ = superCtor;
              ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                  value: ctor,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
            }
          };
        } else {
          module3.exports = function inherits(ctor, superCtor) {
            if (superCtor) {
              ctor.super_ = superCtor;
              var TempCtor = function() {
              };
              TempCtor.prototype = superCtor.prototype;
              ctor.prototype = new TempCtor();
              ctor.prototype.constructor = ctor;
            }
          };
        }
      }, {}], 54: [function(require2, module3, exports3) {
        var process = module3.exports = {};
        var cachedSetTimeout;
        var cachedClearTimeout;
        function defaultSetTimout() {
          throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
          throw new Error("clearTimeout has not been defined");
        }
        (function() {
          try {
            if (typeof setTimeout === "function") {
              cachedSetTimeout = setTimeout;
            } else {
              cachedSetTimeout = defaultSetTimout;
            }
          } catch (e2) {
            cachedSetTimeout = defaultSetTimout;
          }
          try {
            if (typeof clearTimeout === "function") {
              cachedClearTimeout = clearTimeout;
            } else {
              cachedClearTimeout = defaultClearTimeout;
            }
          } catch (e2) {
            cachedClearTimeout = defaultClearTimeout;
          }
        })();
        function runTimeout(fun) {
          if (cachedSetTimeout === setTimeout) {
            return setTimeout(fun, 0);
          }
          if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
          }
          try {
            return cachedSetTimeout(fun, 0);
          } catch (e2) {
            try {
              return cachedSetTimeout.call(null, fun, 0);
            } catch (e3) {
              return cachedSetTimeout.call(this, fun, 0);
            }
          }
        }
        function runClearTimeout(marker) {
          if (cachedClearTimeout === clearTimeout) {
            return clearTimeout(marker);
          }
          if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
          }
          try {
            return cachedClearTimeout(marker);
          } catch (e2) {
            try {
              return cachedClearTimeout.call(null, marker);
            } catch (e3) {
              return cachedClearTimeout.call(this, marker);
            }
          }
        }
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;
        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return;
          }
          draining = false;
          if (currentQueue.length) {
            queue = currentQueue.concat(queue);
          } else {
            queueIndex = -1;
          }
          if (queue.length) {
            drainQueue();
          }
        }
        function drainQueue() {
          if (draining) {
            return;
          }
          var timeout = runTimeout(cleanUpNextTick);
          draining = true;
          var len = queue.length;
          while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
              if (currentQueue) {
                currentQueue[queueIndex].run();
              }
            }
            queueIndex = -1;
            len = queue.length;
          }
          currentQueue = null;
          draining = false;
          runClearTimeout(timeout);
        }
        process.nextTick = function(fun) {
          var args = new Array(arguments.length - 1);
          if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
            }
          }
          queue.push(new Item(fun, args));
          if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
          }
        };
        function Item(fun, array) {
          this.fun = fun;
          this.array = array;
        }
        Item.prototype.run = function() {
          this.fun.apply(null, this.array);
        };
        process.title = "browser";
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = "";
        process.versions = {};
        function noop() {
        }
        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.prependListener = noop;
        process.prependOnceListener = noop;
        process.listeners = function(name) {
          return [];
        };
        process.binding = function(name) {
          throw new Error("process.binding is not supported");
        };
        process.cwd = function() {
          return "/";
        };
        process.chdir = function(dir) {
          throw new Error("process.chdir is not supported");
        };
        process.umask = function() {
          return 0;
        };
      }, {}], 55: [function(require2, module3, exports3) {
        var buffer = require2("buffer");
        var Buffer = buffer.Buffer;
        function copyProps(src, dst) {
          for (var key in src) {
            dst[key] = src[key];
          }
        }
        if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
          module3.exports = buffer;
        } else {
          copyProps(buffer, exports3);
          exports3.Buffer = SafeBuffer;
        }
        function SafeBuffer(arg, encodingOrOffset, length) {
          return Buffer(arg, encodingOrOffset, length);
        }
        SafeBuffer.prototype = Object.create(Buffer.prototype);
        copyProps(Buffer, SafeBuffer);
        SafeBuffer.from = function(arg, encodingOrOffset, length) {
          if (typeof arg === "number") {
            throw new TypeError("Argument must not be a number");
          }
          return Buffer(arg, encodingOrOffset, length);
        };
        SafeBuffer.alloc = function(size, fill, encoding) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          var buf = Buffer(size);
          if (fill !== void 0) {
            if (typeof encoding === "string") {
              buf.fill(fill, encoding);
            } else {
              buf.fill(fill);
            }
          } else {
            buf.fill(0);
          }
          return buf;
        };
        SafeBuffer.allocUnsafe = function(size) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return Buffer(size);
        };
        SafeBuffer.allocUnsafeSlow = function(size) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return buffer.SlowBuffer(size);
        };
      }, { "buffer": 50 }], 56: [function(require2, module3, exports3) {
        module3.exports = Stream;
        var EE = require2("events").EventEmitter;
        var inherits = require2("inherits");
        inherits(Stream, EE);
        Stream.Readable = require2("readable-stream/lib/_stream_readable.js");
        Stream.Writable = require2("readable-stream/lib/_stream_writable.js");
        Stream.Duplex = require2("readable-stream/lib/_stream_duplex.js");
        Stream.Transform = require2("readable-stream/lib/_stream_transform.js");
        Stream.PassThrough = require2("readable-stream/lib/_stream_passthrough.js");
        Stream.finished = require2("readable-stream/lib/internal/streams/end-of-stream.js");
        Stream.pipeline = require2("readable-stream/lib/internal/streams/pipeline.js");
        Stream.Stream = Stream;
        function Stream() {
          EE.call(this);
        }
        Stream.prototype.pipe = function(dest, options) {
          var source = this;
          function ondata(chunk) {
            if (dest.writable) {
              if (false === dest.write(chunk) && source.pause) {
                source.pause();
              }
            }
          }
          source.on("data", ondata);
          function ondrain() {
            if (source.readable && source.resume) {
              source.resume();
            }
          }
          dest.on("drain", ondrain);
          if (!dest._isStdio && (!options || options.end !== false)) {
            source.on("end", onend);
            source.on("close", onclose);
          }
          var didOnEnd = false;
          function onend() {
            if (didOnEnd)
              return;
            didOnEnd = true;
            dest.end();
          }
          function onclose() {
            if (didOnEnd)
              return;
            didOnEnd = true;
            if (typeof dest.destroy === "function")
              dest.destroy();
          }
          function onerror(er) {
            cleanup();
            if (EE.listenerCount(this, "error") === 0) {
              throw er;
            }
          }
          source.on("error", onerror);
          dest.on("error", onerror);
          function cleanup() {
            source.removeListener("data", ondata);
            dest.removeListener("drain", ondrain);
            source.removeListener("end", onend);
            source.removeListener("close", onclose);
            source.removeListener("error", onerror);
            dest.removeListener("error", onerror);
            source.removeListener("end", cleanup);
            source.removeListener("close", cleanup);
            dest.removeListener("close", cleanup);
          }
          source.on("end", cleanup);
          source.on("close", cleanup);
          dest.on("close", cleanup);
          dest.emit("pipe", source);
          return dest;
        };
      }, { "events": 51, "inherits": 53, "readable-stream/lib/_stream_duplex.js": 58, "readable-stream/lib/_stream_passthrough.js": 59, "readable-stream/lib/_stream_readable.js": 60, "readable-stream/lib/_stream_transform.js": 61, "readable-stream/lib/_stream_writable.js": 62, "readable-stream/lib/internal/streams/end-of-stream.js": 66, "readable-stream/lib/internal/streams/pipeline.js": 68 }], 57: [function(require2, module3, exports3) {
        "use strict";
        function _inheritsLoose(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        var codes = {};
        function createErrorType(code, message, Base) {
          if (!Base) {
            Base = Error;
          }
          function getMessage(arg1, arg2, arg3) {
            if (typeof message === "string") {
              return message;
            } else {
              return message(arg1, arg2, arg3);
            }
          }
          var NodeError = function(_Base) {
            _inheritsLoose(NodeError2, _Base);
            function NodeError2(arg1, arg2, arg3) {
              return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
            }
            return NodeError2;
          }(Base);
          NodeError.prototype.name = Base.name;
          NodeError.prototype.code = code;
          codes[code] = NodeError;
        }
        function oneOf(expected, thing) {
          if (Array.isArray(expected)) {
            var len = expected.length;
            expected = expected.map(function(i) {
              return String(i);
            });
            if (len > 2) {
              return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
            } else if (len === 2) {
              return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
            } else {
              return "of ".concat(thing, " ").concat(expected[0]);
            }
          } else {
            return "of ".concat(thing, " ").concat(String(expected));
          }
        }
        function startsWith(str, search, pos) {
          return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
        }
        function endsWith(str, search, this_len) {
          if (this_len === void 0 || this_len > str.length) {
            this_len = str.length;
          }
          return str.substring(this_len - search.length, this_len) === search;
        }
        function includes(str, search, start) {
          if (typeof start !== "number") {
            start = 0;
          }
          if (start + search.length > str.length) {
            return false;
          } else {
            return str.indexOf(search, start) !== -1;
          }
        }
        createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
          return 'The value "' + value + '" is invalid for option "' + name + '"';
        }, TypeError);
        createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
          var determiner;
          if (typeof expected === "string" && startsWith(expected, "not ")) {
            determiner = "must not be";
            expected = expected.replace(/^not /, "");
          } else {
            determiner = "must be";
          }
          var msg;
          if (endsWith(name, " argument")) {
            msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
          } else {
            var type = includes(name, ".") ? "property" : "argument";
            msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
          }
          msg += ". Received type ".concat(typeof actual);
          return msg;
        }, TypeError);
        createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
        createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
          return "The " + name + " method is not implemented";
        });
        createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
        createErrorType("ERR_STREAM_DESTROYED", function(name) {
          return "Cannot call " + name + " after a stream was destroyed";
        });
        createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
        createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
        createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
        createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
        createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
          return "Unknown encoding: " + arg;
        }, TypeError);
        createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
        module3.exports.codes = codes;
      }, {}], 58: [function(require2, module3, exports3) {
        (function(process) {
          (function() {
            "use strict";
            var objectKeys = Object.keys || function(obj) {
              var keys2 = [];
              for (var key in obj) {
                keys2.push(key);
              }
              return keys2;
            };
            module3.exports = Duplex;
            var Readable = require2("./_stream_readable");
            var Writable = require2("./_stream_writable");
            require2("inherits")(Duplex, Readable);
            {
              var keys = objectKeys(Writable.prototype);
              for (var v = 0; v < keys.length; v++) {
                var method = keys[v];
                if (!Duplex.prototype[method])
                  Duplex.prototype[method] = Writable.prototype[method];
              }
            }
            function Duplex(options) {
              if (!(this instanceof Duplex))
                return new Duplex(options);
              Readable.call(this, options);
              Writable.call(this, options);
              this.allowHalfOpen = true;
              if (options) {
                if (options.readable === false)
                  this.readable = false;
                if (options.writable === false)
                  this.writable = false;
                if (options.allowHalfOpen === false) {
                  this.allowHalfOpen = false;
                  this.once("end", onend);
                }
              }
            }
            Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
              enumerable: false,
              get: function get() {
                return this._writableState.highWaterMark;
              }
            });
            Object.defineProperty(Duplex.prototype, "writableBuffer", {
              enumerable: false,
              get: function get() {
                return this._writableState && this._writableState.getBuffer();
              }
            });
            Object.defineProperty(Duplex.prototype, "writableLength", {
              enumerable: false,
              get: function get() {
                return this._writableState.length;
              }
            });
            function onend() {
              if (this._writableState.ended)
                return;
              process.nextTick(onEndNT, this);
            }
            function onEndNT(self2) {
              self2.end();
            }
            Object.defineProperty(Duplex.prototype, "destroyed", {
              enumerable: false,
              get: function get() {
                if (this._readableState === void 0 || this._writableState === void 0) {
                  return false;
                }
                return this._readableState.destroyed && this._writableState.destroyed;
              },
              set: function set(value) {
                if (this._readableState === void 0 || this._writableState === void 0) {
                  return;
                }
                this._readableState.destroyed = value;
                this._writableState.destroyed = value;
              }
            });
          }).call(this);
        }).call(this, require2("_process"));
      }, { "./_stream_readable": 60, "./_stream_writable": 62, "_process": 54, "inherits": 53 }], 59: [function(require2, module3, exports3) {
        "use strict";
        module3.exports = PassThrough;
        var Transform = require2("./_stream_transform");
        require2("inherits")(PassThrough, Transform);
        function PassThrough(options) {
          if (!(this instanceof PassThrough))
            return new PassThrough(options);
          Transform.call(this, options);
        }
        PassThrough.prototype._transform = function(chunk, encoding, cb) {
          cb(null, chunk);
        };
      }, { "./_stream_transform": 61, "inherits": 53 }], 60: [function(require2, module3, exports3) {
        (function(process, global2) {
          (function() {
            "use strict";
            module3.exports = Readable;
            var Duplex;
            Readable.ReadableState = ReadableState;
            var EE = require2("events").EventEmitter;
            var EElistenerCount = function EElistenerCount2(emitter, type) {
              return emitter.listeners(type).length;
            };
            var Stream = require2("./internal/streams/stream");
            var Buffer = require2("buffer").Buffer;
            var OurUint8Array = global2.Uint8Array || function() {
            };
            function _uint8ArrayToBuffer(chunk) {
              return Buffer.from(chunk);
            }
            function _isUint8Array(obj) {
              return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
            }
            var debugUtil = require2("util");
            var debug;
            if (debugUtil && debugUtil.debuglog) {
              debug = debugUtil.debuglog("stream");
            } else {
              debug = function debug2() {
              };
            }
            var BufferList = require2("./internal/streams/buffer_list");
            var destroyImpl = require2("./internal/streams/destroy");
            var _require = require2("./internal/streams/state"), getHighWaterMark = _require.getHighWaterMark;
            var _require$codes = require2("../errors").codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
            var StringDecoder;
            var createReadableStreamAsyncIterator;
            var from;
            require2("inherits")(Readable, Stream);
            var errorOrDestroy = destroyImpl.errorOrDestroy;
            var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
            function prependListener(emitter, event, fn) {
              if (typeof emitter.prependListener === "function")
                return emitter.prependListener(event, fn);
              if (!emitter._events || !emitter._events[event])
                emitter.on(event, fn);
              else if (Array.isArray(emitter._events[event]))
                emitter._events[event].unshift(fn);
              else
                emitter._events[event] = [fn, emitter._events[event]];
            }
            function ReadableState(options, stream, isDuplex) {
              Duplex = Duplex || require2("./_stream_duplex");
              options = options || {};
              if (typeof isDuplex !== "boolean")
                isDuplex = stream instanceof Duplex;
              this.objectMode = !!options.objectMode;
              if (isDuplex)
                this.objectMode = this.objectMode || !!options.readableObjectMode;
              this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
              this.buffer = new BufferList();
              this.length = 0;
              this.pipes = null;
              this.pipesCount = 0;
              this.flowing = null;
              this.ended = false;
              this.endEmitted = false;
              this.reading = false;
              this.sync = true;
              this.needReadable = false;
              this.emittedReadable = false;
              this.readableListening = false;
              this.resumeScheduled = false;
              this.paused = true;
              this.emitClose = options.emitClose !== false;
              this.autoDestroy = !!options.autoDestroy;
              this.destroyed = false;
              this.defaultEncoding = options.defaultEncoding || "utf8";
              this.awaitDrain = 0;
              this.readingMore = false;
              this.decoder = null;
              this.encoding = null;
              if (options.encoding) {
                if (!StringDecoder)
                  StringDecoder = require2("string_decoder/").StringDecoder;
                this.decoder = new StringDecoder(options.encoding);
                this.encoding = options.encoding;
              }
            }
            function Readable(options) {
              Duplex = Duplex || require2("./_stream_duplex");
              if (!(this instanceof Readable))
                return new Readable(options);
              var isDuplex = this instanceof Duplex;
              this._readableState = new ReadableState(options, this, isDuplex);
              this.readable = true;
              if (options) {
                if (typeof options.read === "function")
                  this._read = options.read;
                if (typeof options.destroy === "function")
                  this._destroy = options.destroy;
              }
              Stream.call(this);
            }
            Object.defineProperty(Readable.prototype, "destroyed", {
              enumerable: false,
              get: function get() {
                if (this._readableState === void 0) {
                  return false;
                }
                return this._readableState.destroyed;
              },
              set: function set(value) {
                if (!this._readableState) {
                  return;
                }
                this._readableState.destroyed = value;
              }
            });
            Readable.prototype.destroy = destroyImpl.destroy;
            Readable.prototype._undestroy = destroyImpl.undestroy;
            Readable.prototype._destroy = function(err, cb) {
              cb(err);
            };
            Readable.prototype.push = function(chunk, encoding) {
              var state = this._readableState;
              var skipChunkCheck;
              if (!state.objectMode) {
                if (typeof chunk === "string") {
                  encoding = encoding || state.defaultEncoding;
                  if (encoding !== state.encoding) {
                    chunk = Buffer.from(chunk, encoding);
                    encoding = "";
                  }
                  skipChunkCheck = true;
                }
              } else {
                skipChunkCheck = true;
              }
              return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
            };
            Readable.prototype.unshift = function(chunk) {
              return readableAddChunk(this, chunk, null, true, false);
            };
            function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
              debug("readableAddChunk", chunk);
              var state = stream._readableState;
              if (chunk === null) {
                state.reading = false;
                onEofChunk(stream, state);
              } else {
                var er;
                if (!skipChunkCheck)
                  er = chunkInvalid(state, chunk);
                if (er) {
                  errorOrDestroy(stream, er);
                } else if (state.objectMode || chunk && chunk.length > 0) {
                  if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
                    chunk = _uint8ArrayToBuffer(chunk);
                  }
                  if (addToFront) {
                    if (state.endEmitted)
                      errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
                    else
                      addChunk(stream, state, chunk, true);
                  } else if (state.ended) {
                    errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
                  } else if (state.destroyed) {
                    return false;
                  } else {
                    state.reading = false;
                    if (state.decoder && !encoding) {
                      chunk = state.decoder.write(chunk);
                      if (state.objectMode || chunk.length !== 0)
                        addChunk(stream, state, chunk, false);
                      else
                        maybeReadMore(stream, state);
                    } else {
                      addChunk(stream, state, chunk, false);
                    }
                  }
                } else if (!addToFront) {
                  state.reading = false;
                  maybeReadMore(stream, state);
                }
              }
              return !state.ended && (state.length < state.highWaterMark || state.length === 0);
            }
            function addChunk(stream, state, chunk, addToFront) {
              if (state.flowing && state.length === 0 && !state.sync) {
                state.awaitDrain = 0;
                stream.emit("data", chunk);
              } else {
                state.length += state.objectMode ? 1 : chunk.length;
                if (addToFront)
                  state.buffer.unshift(chunk);
                else
                  state.buffer.push(chunk);
                if (state.needReadable)
                  emitReadable(stream);
              }
              maybeReadMore(stream, state);
            }
            function chunkInvalid(state, chunk) {
              var er;
              if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
                er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
              }
              return er;
            }
            Readable.prototype.isPaused = function() {
              return this._readableState.flowing === false;
            };
            Readable.prototype.setEncoding = function(enc) {
              if (!StringDecoder)
                StringDecoder = require2("string_decoder/").StringDecoder;
              var decoder = new StringDecoder(enc);
              this._readableState.decoder = decoder;
              this._readableState.encoding = this._readableState.decoder.encoding;
              var p = this._readableState.buffer.head;
              var content = "";
              while (p !== null) {
                content += decoder.write(p.data);
                p = p.next;
              }
              this._readableState.buffer.clear();
              if (content !== "")
                this._readableState.buffer.push(content);
              this._readableState.length = content.length;
              return this;
            };
            var MAX_HWM = 1073741824;
            function computeNewHighWaterMark(n2) {
              if (n2 >= MAX_HWM) {
                n2 = MAX_HWM;
              } else {
                n2--;
                n2 |= n2 >>> 1;
                n2 |= n2 >>> 2;
                n2 |= n2 >>> 4;
                n2 |= n2 >>> 8;
                n2 |= n2 >>> 16;
                n2++;
              }
              return n2;
            }
            function howMuchToRead(n2, state) {
              if (n2 <= 0 || state.length === 0 && state.ended)
                return 0;
              if (state.objectMode)
                return 1;
              if (n2 !== n2) {
                if (state.flowing && state.length)
                  return state.buffer.head.data.length;
                else
                  return state.length;
              }
              if (n2 > state.highWaterMark)
                state.highWaterMark = computeNewHighWaterMark(n2);
              if (n2 <= state.length)
                return n2;
              if (!state.ended) {
                state.needReadable = true;
                return 0;
              }
              return state.length;
            }
            Readable.prototype.read = function(n2) {
              debug("read", n2);
              n2 = parseInt(n2, 10);
              var state = this._readableState;
              var nOrig = n2;
              if (n2 !== 0)
                state.emittedReadable = false;
              if (n2 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
                debug("read: emitReadable", state.length, state.ended);
                if (state.length === 0 && state.ended)
                  endReadable(this);
                else
                  emitReadable(this);
                return null;
              }
              n2 = howMuchToRead(n2, state);
              if (n2 === 0 && state.ended) {
                if (state.length === 0)
                  endReadable(this);
                return null;
              }
              var doRead = state.needReadable;
              debug("need readable", doRead);
              if (state.length === 0 || state.length - n2 < state.highWaterMark) {
                doRead = true;
                debug("length less than watermark", doRead);
              }
              if (state.ended || state.reading) {
                doRead = false;
                debug("reading or ended", doRead);
              } else if (doRead) {
                debug("do read");
                state.reading = true;
                state.sync = true;
                if (state.length === 0)
                  state.needReadable = true;
                this._read(state.highWaterMark);
                state.sync = false;
                if (!state.reading)
                  n2 = howMuchToRead(nOrig, state);
              }
              var ret;
              if (n2 > 0)
                ret = fromList(n2, state);
              else
                ret = null;
              if (ret === null) {
                state.needReadable = state.length <= state.highWaterMark;
                n2 = 0;
              } else {
                state.length -= n2;
                state.awaitDrain = 0;
              }
              if (state.length === 0) {
                if (!state.ended)
                  state.needReadable = true;
                if (nOrig !== n2 && state.ended)
                  endReadable(this);
              }
              if (ret !== null)
                this.emit("data", ret);
              return ret;
            };
            function onEofChunk(stream, state) {
              debug("onEofChunk");
              if (state.ended)
                return;
              if (state.decoder) {
                var chunk = state.decoder.end();
                if (chunk && chunk.length) {
                  state.buffer.push(chunk);
                  state.length += state.objectMode ? 1 : chunk.length;
                }
              }
              state.ended = true;
              if (state.sync) {
                emitReadable(stream);
              } else {
                state.needReadable = false;
                if (!state.emittedReadable) {
                  state.emittedReadable = true;
                  emitReadable_(stream);
                }
              }
            }
            function emitReadable(stream) {
              var state = stream._readableState;
              debug("emitReadable", state.needReadable, state.emittedReadable);
              state.needReadable = false;
              if (!state.emittedReadable) {
                debug("emitReadable", state.flowing);
                state.emittedReadable = true;
                process.nextTick(emitReadable_, stream);
              }
            }
            function emitReadable_(stream) {
              var state = stream._readableState;
              debug("emitReadable_", state.destroyed, state.length, state.ended);
              if (!state.destroyed && (state.length || state.ended)) {
                stream.emit("readable");
                state.emittedReadable = false;
              }
              state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
              flow(stream);
            }
            function maybeReadMore(stream, state) {
              if (!state.readingMore) {
                state.readingMore = true;
                process.nextTick(maybeReadMore_, stream, state);
              }
            }
            function maybeReadMore_(stream, state) {
              while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
                var len = state.length;
                debug("maybeReadMore read 0");
                stream.read(0);
                if (len === state.length)
                  break;
              }
              state.readingMore = false;
            }
            Readable.prototype._read = function(n2) {
              errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
            };
            Readable.prototype.pipe = function(dest, pipeOpts) {
              var src = this;
              var state = this._readableState;
              switch (state.pipesCount) {
                case 0:
                  state.pipes = dest;
                  break;
                case 1:
                  state.pipes = [state.pipes, dest];
                  break;
                default:
                  state.pipes.push(dest);
                  break;
              }
              state.pipesCount += 1;
              debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
              var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
              var endFn = doEnd ? onend : unpipe;
              if (state.endEmitted)
                process.nextTick(endFn);
              else
                src.once("end", endFn);
              dest.on("unpipe", onunpipe);
              function onunpipe(readable, unpipeInfo) {
                debug("onunpipe");
                if (readable === src) {
                  if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                    unpipeInfo.hasUnpiped = true;
                    cleanup();
                  }
                }
              }
              function onend() {
                debug("onend");
                dest.end();
              }
              var ondrain = pipeOnDrain(src);
              dest.on("drain", ondrain);
              var cleanedUp = false;
              function cleanup() {
                debug("cleanup");
                dest.removeListener("close", onclose);
                dest.removeListener("finish", onfinish);
                dest.removeListener("drain", ondrain);
                dest.removeListener("error", onerror);
                dest.removeListener("unpipe", onunpipe);
                src.removeListener("end", onend);
                src.removeListener("end", unpipe);
                src.removeListener("data", ondata);
                cleanedUp = true;
                if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
                  ondrain();
              }
              src.on("data", ondata);
              function ondata(chunk) {
                debug("ondata");
                var ret = dest.write(chunk);
                debug("dest.write", ret);
                if (ret === false) {
                  if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                    debug("false write response, pause", state.awaitDrain);
                    state.awaitDrain++;
                  }
                  src.pause();
                }
              }
              function onerror(er) {
                debug("onerror", er);
                unpipe();
                dest.removeListener("error", onerror);
                if (EElistenerCount(dest, "error") === 0)
                  errorOrDestroy(dest, er);
              }
              prependListener(dest, "error", onerror);
              function onclose() {
                dest.removeListener("finish", onfinish);
                unpipe();
              }
              dest.once("close", onclose);
              function onfinish() {
                debug("onfinish");
                dest.removeListener("close", onclose);
                unpipe();
              }
              dest.once("finish", onfinish);
              function unpipe() {
                debug("unpipe");
                src.unpipe(dest);
              }
              dest.emit("pipe", src);
              if (!state.flowing) {
                debug("pipe resume");
                src.resume();
              }
              return dest;
            };
            function pipeOnDrain(src) {
              return function pipeOnDrainFunctionResult() {
                var state = src._readableState;
                debug("pipeOnDrain", state.awaitDrain);
                if (state.awaitDrain)
                  state.awaitDrain--;
                if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
                  state.flowing = true;
                  flow(src);
                }
              };
            }
            Readable.prototype.unpipe = function(dest) {
              var state = this._readableState;
              var unpipeInfo = {
                hasUnpiped: false
              };
              if (state.pipesCount === 0)
                return this;
              if (state.pipesCount === 1) {
                if (dest && dest !== state.pipes)
                  return this;
                if (!dest)
                  dest = state.pipes;
                state.pipes = null;
                state.pipesCount = 0;
                state.flowing = false;
                if (dest)
                  dest.emit("unpipe", this, unpipeInfo);
                return this;
              }
              if (!dest) {
                var dests = state.pipes;
                var len = state.pipesCount;
                state.pipes = null;
                state.pipesCount = 0;
                state.flowing = false;
                for (var i = 0; i < len; i++) {
                  dests[i].emit("unpipe", this, {
                    hasUnpiped: false
                  });
                }
                return this;
              }
              var index = indexOf(state.pipes, dest);
              if (index === -1)
                return this;
              state.pipes.splice(index, 1);
              state.pipesCount -= 1;
              if (state.pipesCount === 1)
                state.pipes = state.pipes[0];
              dest.emit("unpipe", this, unpipeInfo);
              return this;
            };
            Readable.prototype.on = function(ev, fn) {
              var res = Stream.prototype.on.call(this, ev, fn);
              var state = this._readableState;
              if (ev === "data") {
                state.readableListening = this.listenerCount("readable") > 0;
                if (state.flowing !== false)
                  this.resume();
              } else if (ev === "readable") {
                if (!state.endEmitted && !state.readableListening) {
                  state.readableListening = state.needReadable = true;
                  state.flowing = false;
                  state.emittedReadable = false;
                  debug("on readable", state.length, state.reading);
                  if (state.length) {
                    emitReadable(this);
                  } else if (!state.reading) {
                    process.nextTick(nReadingNextTick, this);
                  }
                }
              }
              return res;
            };
            Readable.prototype.addListener = Readable.prototype.on;
            Readable.prototype.removeListener = function(ev, fn) {
              var res = Stream.prototype.removeListener.call(this, ev, fn);
              if (ev === "readable") {
                process.nextTick(updateReadableListening, this);
              }
              return res;
            };
            Readable.prototype.removeAllListeners = function(ev) {
              var res = Stream.prototype.removeAllListeners.apply(this, arguments);
              if (ev === "readable" || ev === void 0) {
                process.nextTick(updateReadableListening, this);
              }
              return res;
            };
            function updateReadableListening(self2) {
              var state = self2._readableState;
              state.readableListening = self2.listenerCount("readable") > 0;
              if (state.resumeScheduled && !state.paused) {
                state.flowing = true;
              } else if (self2.listenerCount("data") > 0) {
                self2.resume();
              }
            }
            function nReadingNextTick(self2) {
              debug("readable nexttick read 0");
              self2.read(0);
            }
            Readable.prototype.resume = function() {
              var state = this._readableState;
              if (!state.flowing) {
                debug("resume");
                state.flowing = !state.readableListening;
                resume(this, state);
              }
              state.paused = false;
              return this;
            };
            function resume(stream, state) {
              if (!state.resumeScheduled) {
                state.resumeScheduled = true;
                process.nextTick(resume_, stream, state);
              }
            }
            function resume_(stream, state) {
              debug("resume", state.reading);
              if (!state.reading) {
                stream.read(0);
              }
              state.resumeScheduled = false;
              stream.emit("resume");
              flow(stream);
              if (state.flowing && !state.reading)
                stream.read(0);
            }
            Readable.prototype.pause = function() {
              debug("call pause flowing=%j", this._readableState.flowing);
              if (this._readableState.flowing !== false) {
                debug("pause");
                this._readableState.flowing = false;
                this.emit("pause");
              }
              this._readableState.paused = true;
              return this;
            };
            function flow(stream) {
              var state = stream._readableState;
              debug("flow", state.flowing);
              while (state.flowing && stream.read() !== null) {
                ;
              }
            }
            Readable.prototype.wrap = function(stream) {
              var _this = this;
              var state = this._readableState;
              var paused = false;
              stream.on("end", function() {
                debug("wrapped end");
                if (state.decoder && !state.ended) {
                  var chunk = state.decoder.end();
                  if (chunk && chunk.length)
                    _this.push(chunk);
                }
                _this.push(null);
              });
              stream.on("data", function(chunk) {
                debug("wrapped data");
                if (state.decoder)
                  chunk = state.decoder.write(chunk);
                if (state.objectMode && (chunk === null || chunk === void 0))
                  return;
                else if (!state.objectMode && (!chunk || !chunk.length))
                  return;
                var ret = _this.push(chunk);
                if (!ret) {
                  paused = true;
                  stream.pause();
                }
              });
              for (var i in stream) {
                if (this[i] === void 0 && typeof stream[i] === "function") {
                  this[i] = function methodWrap(method) {
                    return function methodWrapReturnFunction() {
                      return stream[method].apply(stream, arguments);
                    };
                  }(i);
                }
              }
              for (var n2 = 0; n2 < kProxyEvents.length; n2++) {
                stream.on(kProxyEvents[n2], this.emit.bind(this, kProxyEvents[n2]));
              }
              this._read = function(n3) {
                debug("wrapped _read", n3);
                if (paused) {
                  paused = false;
                  stream.resume();
                }
              };
              return this;
            };
            if (typeof Symbol === "function") {
              Readable.prototype[Symbol.asyncIterator] = function() {
                if (createReadableStreamAsyncIterator === void 0) {
                  createReadableStreamAsyncIterator = require2("./internal/streams/async_iterator");
                }
                return createReadableStreamAsyncIterator(this);
              };
            }
            Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
              enumerable: false,
              get: function get() {
                return this._readableState.highWaterMark;
              }
            });
            Object.defineProperty(Readable.prototype, "readableBuffer", {
              enumerable: false,
              get: function get() {
                return this._readableState && this._readableState.buffer;
              }
            });
            Object.defineProperty(Readable.prototype, "readableFlowing", {
              enumerable: false,
              get: function get() {
                return this._readableState.flowing;
              },
              set: function set(state) {
                if (this._readableState) {
                  this._readableState.flowing = state;
                }
              }
            });
            Readable._fromList = fromList;
            Object.defineProperty(Readable.prototype, "readableLength", {
              enumerable: false,
              get: function get() {
                return this._readableState.length;
              }
            });
            function fromList(n2, state) {
              if (state.length === 0)
                return null;
              var ret;
              if (state.objectMode)
                ret = state.buffer.shift();
              else if (!n2 || n2 >= state.length) {
                if (state.decoder)
                  ret = state.buffer.join("");
                else if (state.buffer.length === 1)
                  ret = state.buffer.first();
                else
                  ret = state.buffer.concat(state.length);
                state.buffer.clear();
              } else {
                ret = state.buffer.consume(n2, state.decoder);
              }
              return ret;
            }
            function endReadable(stream) {
              var state = stream._readableState;
              debug("endReadable", state.endEmitted);
              if (!state.endEmitted) {
                state.ended = true;
                process.nextTick(endReadableNT, state, stream);
              }
            }
            function endReadableNT(state, stream) {
              debug("endReadableNT", state.endEmitted, state.length);
              if (!state.endEmitted && state.length === 0) {
                state.endEmitted = true;
                stream.readable = false;
                stream.emit("end");
                if (state.autoDestroy) {
                  var wState = stream._writableState;
                  if (!wState || wState.autoDestroy && wState.finished) {
                    stream.destroy();
                  }
                }
              }
            }
            if (typeof Symbol === "function") {
              Readable.from = function(iterable, opts) {
                if (from === void 0) {
                  from = require2("./internal/streams/from");
                }
                return from(Readable, iterable, opts);
              };
            }
            function indexOf(xs, x) {
              for (var i = 0, l = xs.length; i < l; i++) {
                if (xs[i] === x)
                  return i;
              }
              return -1;
            }
          }).call(this);
        }).call(this, require2("_process"), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "../errors": 57, "./_stream_duplex": 58, "./internal/streams/async_iterator": 63, "./internal/streams/buffer_list": 64, "./internal/streams/destroy": 65, "./internal/streams/from": 67, "./internal/streams/state": 69, "./internal/streams/stream": 70, "_process": 54, "buffer": 50, "events": 51, "inherits": 53, "string_decoder/": 71, "util": 49 }], 61: [function(require2, module3, exports3) {
        "use strict";
        module3.exports = Transform;
        var _require$codes = require2("../errors").codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
        var Duplex = require2("./_stream_duplex");
        require2("inherits")(Transform, Duplex);
        function afterTransform(er, data) {
          var ts = this._transformState;
          ts.transforming = false;
          var cb = ts.writecb;
          if (cb === null) {
            return this.emit("error", new ERR_MULTIPLE_CALLBACK());
          }
          ts.writechunk = null;
          ts.writecb = null;
          if (data != null)
            this.push(data);
          cb(er);
          var rs = this._readableState;
          rs.reading = false;
          if (rs.needReadable || rs.length < rs.highWaterMark) {
            this._read(rs.highWaterMark);
          }
        }
        function Transform(options) {
          if (!(this instanceof Transform))
            return new Transform(options);
          Duplex.call(this, options);
          this._transformState = {
            afterTransform: afterTransform.bind(this),
            needTransform: false,
            transforming: false,
            writecb: null,
            writechunk: null,
            writeencoding: null
          };
          this._readableState.needReadable = true;
          this._readableState.sync = false;
          if (options) {
            if (typeof options.transform === "function")
              this._transform = options.transform;
            if (typeof options.flush === "function")
              this._flush = options.flush;
          }
          this.on("prefinish", prefinish);
        }
        function prefinish() {
          var _this = this;
          if (typeof this._flush === "function" && !this._readableState.destroyed) {
            this._flush(function(er, data) {
              done(_this, er, data);
            });
          } else {
            done(this, null, null);
          }
        }
        Transform.prototype.push = function(chunk, encoding) {
          this._transformState.needTransform = false;
          return Duplex.prototype.push.call(this, chunk, encoding);
        };
        Transform.prototype._transform = function(chunk, encoding, cb) {
          cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
        };
        Transform.prototype._write = function(chunk, encoding, cb) {
          var ts = this._transformState;
          ts.writecb = cb;
          ts.writechunk = chunk;
          ts.writeencoding = encoding;
          if (!ts.transforming) {
            var rs = this._readableState;
            if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
              this._read(rs.highWaterMark);
          }
        };
        Transform.prototype._read = function(n2) {
          var ts = this._transformState;
          if (ts.writechunk !== null && !ts.transforming) {
            ts.transforming = true;
            this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
          } else {
            ts.needTransform = true;
          }
        };
        Transform.prototype._destroy = function(err, cb) {
          Duplex.prototype._destroy.call(this, err, function(err2) {
            cb(err2);
          });
        };
        function done(stream, er, data) {
          if (er)
            return stream.emit("error", er);
          if (data != null)
            stream.push(data);
          if (stream._writableState.length)
            throw new ERR_TRANSFORM_WITH_LENGTH_0();
          if (stream._transformState.transforming)
            throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
          return stream.push(null);
        }
      }, { "../errors": 57, "./_stream_duplex": 58, "inherits": 53 }], 62: [function(require2, module3, exports3) {
        (function(process, global2) {
          (function() {
            "use strict";
            module3.exports = Writable;
            function WriteReq(chunk, encoding, cb) {
              this.chunk = chunk;
              this.encoding = encoding;
              this.callback = cb;
              this.next = null;
            }
            function CorkedRequest(state) {
              var _this = this;
              this.next = null;
              this.entry = null;
              this.finish = function() {
                onCorkedFinish(_this, state);
              };
            }
            var Duplex;
            Writable.WritableState = WritableState;
            var internalUtil = {
              deprecate: require2("util-deprecate")
            };
            var Stream = require2("./internal/streams/stream");
            var Buffer = require2("buffer").Buffer;
            var OurUint8Array = global2.Uint8Array || function() {
            };
            function _uint8ArrayToBuffer(chunk) {
              return Buffer.from(chunk);
            }
            function _isUint8Array(obj) {
              return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
            }
            var destroyImpl = require2("./internal/streams/destroy");
            var _require = require2("./internal/streams/state"), getHighWaterMark = _require.getHighWaterMark;
            var _require$codes = require2("../errors").codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
            var errorOrDestroy = destroyImpl.errorOrDestroy;
            require2("inherits")(Writable, Stream);
            function nop() {
            }
            function WritableState(options, stream, isDuplex) {
              Duplex = Duplex || require2("./_stream_duplex");
              options = options || {};
              if (typeof isDuplex !== "boolean")
                isDuplex = stream instanceof Duplex;
              this.objectMode = !!options.objectMode;
              if (isDuplex)
                this.objectMode = this.objectMode || !!options.writableObjectMode;
              this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
              this.finalCalled = false;
              this.needDrain = false;
              this.ending = false;
              this.ended = false;
              this.finished = false;
              this.destroyed = false;
              var noDecode = options.decodeStrings === false;
              this.decodeStrings = !noDecode;
              this.defaultEncoding = options.defaultEncoding || "utf8";
              this.length = 0;
              this.writing = false;
              this.corked = 0;
              this.sync = true;
              this.bufferProcessing = false;
              this.onwrite = function(er) {
                onwrite(stream, er);
              };
              this.writecb = null;
              this.writelen = 0;
              this.bufferedRequest = null;
              this.lastBufferedRequest = null;
              this.pendingcb = 0;
              this.prefinished = false;
              this.errorEmitted = false;
              this.emitClose = options.emitClose !== false;
              this.autoDestroy = !!options.autoDestroy;
              this.bufferedRequestCount = 0;
              this.corkedRequestsFree = new CorkedRequest(this);
            }
            WritableState.prototype.getBuffer = function getBuffer() {
              var current = this.bufferedRequest;
              var out = [];
              while (current) {
                out.push(current);
                current = current.next;
              }
              return out;
            };
            (function() {
              try {
                Object.defineProperty(WritableState.prototype, "buffer", {
                  get: internalUtil.deprecate(function writableStateBufferGetter() {
                    return this.getBuffer();
                  }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
                });
              } catch (_) {
              }
            })();
            var realHasInstance;
            if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
              realHasInstance = Function.prototype[Symbol.hasInstance];
              Object.defineProperty(Writable, Symbol.hasInstance, {
                value: function value(object) {
                  if (realHasInstance.call(this, object))
                    return true;
                  if (this !== Writable)
                    return false;
                  return object && object._writableState instanceof WritableState;
                }
              });
            } else {
              realHasInstance = function realHasInstance2(object) {
                return object instanceof this;
              };
            }
            function Writable(options) {
              Duplex = Duplex || require2("./_stream_duplex");
              var isDuplex = this instanceof Duplex;
              if (!isDuplex && !realHasInstance.call(Writable, this))
                return new Writable(options);
              this._writableState = new WritableState(options, this, isDuplex);
              this.writable = true;
              if (options) {
                if (typeof options.write === "function")
                  this._write = options.write;
                if (typeof options.writev === "function")
                  this._writev = options.writev;
                if (typeof options.destroy === "function")
                  this._destroy = options.destroy;
                if (typeof options.final === "function")
                  this._final = options.final;
              }
              Stream.call(this);
            }
            Writable.prototype.pipe = function() {
              errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
            };
            function writeAfterEnd(stream, cb) {
              var er = new ERR_STREAM_WRITE_AFTER_END();
              errorOrDestroy(stream, er);
              process.nextTick(cb, er);
            }
            function validChunk(stream, state, chunk, cb) {
              var er;
              if (chunk === null) {
                er = new ERR_STREAM_NULL_VALUES();
              } else if (typeof chunk !== "string" && !state.objectMode) {
                er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
              }
              if (er) {
                errorOrDestroy(stream, er);
                process.nextTick(cb, er);
                return false;
              }
              return true;
            }
            Writable.prototype.write = function(chunk, encoding, cb) {
              var state = this._writableState;
              var ret = false;
              var isBuf = !state.objectMode && _isUint8Array(chunk);
              if (isBuf && !Buffer.isBuffer(chunk)) {
                chunk = _uint8ArrayToBuffer(chunk);
              }
              if (typeof encoding === "function") {
                cb = encoding;
                encoding = null;
              }
              if (isBuf)
                encoding = "buffer";
              else if (!encoding)
                encoding = state.defaultEncoding;
              if (typeof cb !== "function")
                cb = nop;
              if (state.ending)
                writeAfterEnd(this, cb);
              else if (isBuf || validChunk(this, state, chunk, cb)) {
                state.pendingcb++;
                ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
              }
              return ret;
            };
            Writable.prototype.cork = function() {
              this._writableState.corked++;
            };
            Writable.prototype.uncork = function() {
              var state = this._writableState;
              if (state.corked) {
                state.corked--;
                if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
                  clearBuffer(this, state);
              }
            };
            Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
              if (typeof encoding === "string")
                encoding = encoding.toLowerCase();
              if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
                throw new ERR_UNKNOWN_ENCODING(encoding);
              this._writableState.defaultEncoding = encoding;
              return this;
            };
            Object.defineProperty(Writable.prototype, "writableBuffer", {
              enumerable: false,
              get: function get() {
                return this._writableState && this._writableState.getBuffer();
              }
            });
            function decodeChunk(state, chunk, encoding) {
              if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
                chunk = Buffer.from(chunk, encoding);
              }
              return chunk;
            }
            Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
              enumerable: false,
              get: function get() {
                return this._writableState.highWaterMark;
              }
            });
            function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
              if (!isBuf) {
                var newChunk = decodeChunk(state, chunk, encoding);
                if (chunk !== newChunk) {
                  isBuf = true;
                  encoding = "buffer";
                  chunk = newChunk;
                }
              }
              var len = state.objectMode ? 1 : chunk.length;
              state.length += len;
              var ret = state.length < state.highWaterMark;
              if (!ret)
                state.needDrain = true;
              if (state.writing || state.corked) {
                var last = state.lastBufferedRequest;
                state.lastBufferedRequest = {
                  chunk,
                  encoding,
                  isBuf,
                  callback: cb,
                  next: null
                };
                if (last) {
                  last.next = state.lastBufferedRequest;
                } else {
                  state.bufferedRequest = state.lastBufferedRequest;
                }
                state.bufferedRequestCount += 1;
              } else {
                doWrite(stream, state, false, len, chunk, encoding, cb);
              }
              return ret;
            }
            function doWrite(stream, state, writev, len, chunk, encoding, cb) {
              state.writelen = len;
              state.writecb = cb;
              state.writing = true;
              state.sync = true;
              if (state.destroyed)
                state.onwrite(new ERR_STREAM_DESTROYED("write"));
              else if (writev)
                stream._writev(chunk, state.onwrite);
              else
                stream._write(chunk, encoding, state.onwrite);
              state.sync = false;
            }
            function onwriteError(stream, state, sync, er, cb) {
              --state.pendingcb;
              if (sync) {
                process.nextTick(cb, er);
                process.nextTick(finishMaybe, stream, state);
                stream._writableState.errorEmitted = true;
                errorOrDestroy(stream, er);
              } else {
                cb(er);
                stream._writableState.errorEmitted = true;
                errorOrDestroy(stream, er);
                finishMaybe(stream, state);
              }
            }
            function onwriteStateUpdate(state) {
              state.writing = false;
              state.writecb = null;
              state.length -= state.writelen;
              state.writelen = 0;
            }
            function onwrite(stream, er) {
              var state = stream._writableState;
              var sync = state.sync;
              var cb = state.writecb;
              if (typeof cb !== "function")
                throw new ERR_MULTIPLE_CALLBACK();
              onwriteStateUpdate(state);
              if (er)
                onwriteError(stream, state, sync, er, cb);
              else {
                var finished = needFinish(state) || stream.destroyed;
                if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
                  clearBuffer(stream, state);
                }
                if (sync) {
                  process.nextTick(afterWrite, stream, state, finished, cb);
                } else {
                  afterWrite(stream, state, finished, cb);
                }
              }
            }
            function afterWrite(stream, state, finished, cb) {
              if (!finished)
                onwriteDrain(stream, state);
              state.pendingcb--;
              cb();
              finishMaybe(stream, state);
            }
            function onwriteDrain(stream, state) {
              if (state.length === 0 && state.needDrain) {
                state.needDrain = false;
                stream.emit("drain");
              }
            }
            function clearBuffer(stream, state) {
              state.bufferProcessing = true;
              var entry = state.bufferedRequest;
              if (stream._writev && entry && entry.next) {
                var l = state.bufferedRequestCount;
                var buffer = new Array(l);
                var holder = state.corkedRequestsFree;
                holder.entry = entry;
                var count = 0;
                var allBuffers = true;
                while (entry) {
                  buffer[count] = entry;
                  if (!entry.isBuf)
                    allBuffers = false;
                  entry = entry.next;
                  count += 1;
                }
                buffer.allBuffers = allBuffers;
                doWrite(stream, state, true, state.length, buffer, "", holder.finish);
                state.pendingcb++;
                state.lastBufferedRequest = null;
                if (holder.next) {
                  state.corkedRequestsFree = holder.next;
                  holder.next = null;
                } else {
                  state.corkedRequestsFree = new CorkedRequest(state);
                }
                state.bufferedRequestCount = 0;
              } else {
                while (entry) {
                  var chunk = entry.chunk;
                  var encoding = entry.encoding;
                  var cb = entry.callback;
                  var len = state.objectMode ? 1 : chunk.length;
                  doWrite(stream, state, false, len, chunk, encoding, cb);
                  entry = entry.next;
                  state.bufferedRequestCount--;
                  if (state.writing) {
                    break;
                  }
                }
                if (entry === null)
                  state.lastBufferedRequest = null;
              }
              state.bufferedRequest = entry;
              state.bufferProcessing = false;
            }
            Writable.prototype._write = function(chunk, encoding, cb) {
              cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
            };
            Writable.prototype._writev = null;
            Writable.prototype.end = function(chunk, encoding, cb) {
              var state = this._writableState;
              if (typeof chunk === "function") {
                cb = chunk;
                chunk = null;
                encoding = null;
              } else if (typeof encoding === "function") {
                cb = encoding;
                encoding = null;
              }
              if (chunk !== null && chunk !== void 0)
                this.write(chunk, encoding);
              if (state.corked) {
                state.corked = 1;
                this.uncork();
              }
              if (!state.ending)
                endWritable(this, state, cb);
              return this;
            };
            Object.defineProperty(Writable.prototype, "writableLength", {
              enumerable: false,
              get: function get() {
                return this._writableState.length;
              }
            });
            function needFinish(state) {
              return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
            }
            function callFinal(stream, state) {
              stream._final(function(err) {
                state.pendingcb--;
                if (err) {
                  errorOrDestroy(stream, err);
                }
                state.prefinished = true;
                stream.emit("prefinish");
                finishMaybe(stream, state);
              });
            }
            function prefinish(stream, state) {
              if (!state.prefinished && !state.finalCalled) {
                if (typeof stream._final === "function" && !state.destroyed) {
                  state.pendingcb++;
                  state.finalCalled = true;
                  process.nextTick(callFinal, stream, state);
                } else {
                  state.prefinished = true;
                  stream.emit("prefinish");
                }
              }
            }
            function finishMaybe(stream, state) {
              var need = needFinish(state);
              if (need) {
                prefinish(stream, state);
                if (state.pendingcb === 0) {
                  state.finished = true;
                  stream.emit("finish");
                  if (state.autoDestroy) {
                    var rState = stream._readableState;
                    if (!rState || rState.autoDestroy && rState.endEmitted) {
                      stream.destroy();
                    }
                  }
                }
              }
              return need;
            }
            function endWritable(stream, state, cb) {
              state.ending = true;
              finishMaybe(stream, state);
              if (cb) {
                if (state.finished)
                  process.nextTick(cb);
                else
                  stream.once("finish", cb);
              }
              state.ended = true;
              stream.writable = false;
            }
            function onCorkedFinish(corkReq, state, err) {
              var entry = corkReq.entry;
              corkReq.entry = null;
              while (entry) {
                var cb = entry.callback;
                state.pendingcb--;
                cb(err);
                entry = entry.next;
              }
              state.corkedRequestsFree.next = corkReq;
            }
            Object.defineProperty(Writable.prototype, "destroyed", {
              enumerable: false,
              get: function get() {
                if (this._writableState === void 0) {
                  return false;
                }
                return this._writableState.destroyed;
              },
              set: function set(value) {
                if (!this._writableState) {
                  return;
                }
                this._writableState.destroyed = value;
              }
            });
            Writable.prototype.destroy = destroyImpl.destroy;
            Writable.prototype._undestroy = destroyImpl.undestroy;
            Writable.prototype._destroy = function(err, cb) {
              cb(err);
            };
          }).call(this);
        }).call(this, require2("_process"), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "../errors": 57, "./_stream_duplex": 58, "./internal/streams/destroy": 65, "./internal/streams/state": 69, "./internal/streams/stream": 70, "_process": 54, "buffer": 50, "inherits": 53, "util-deprecate": 72 }], 63: [function(require2, module3, exports3) {
        (function(process) {
          (function() {
            "use strict";
            var _Object$setPrototypeO;
            function _defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var finished = require2("./end-of-stream");
            var kLastResolve = Symbol("lastResolve");
            var kLastReject = Symbol("lastReject");
            var kError = Symbol("error");
            var kEnded = Symbol("ended");
            var kLastPromise = Symbol("lastPromise");
            var kHandlePromise = Symbol("handlePromise");
            var kStream = Symbol("stream");
            function createIterResult(value, done) {
              return {
                value,
                done
              };
            }
            function readAndResolve(iter) {
              var resolve = iter[kLastResolve];
              if (resolve !== null) {
                var data = iter[kStream].read();
                if (data !== null) {
                  iter[kLastPromise] = null;
                  iter[kLastResolve] = null;
                  iter[kLastReject] = null;
                  resolve(createIterResult(data, false));
                }
              }
            }
            function onReadable(iter) {
              process.nextTick(readAndResolve, iter);
            }
            function wrapForNext(lastPromise, iter) {
              return function(resolve, reject) {
                lastPromise.then(function() {
                  if (iter[kEnded]) {
                    resolve(createIterResult(void 0, true));
                    return;
                  }
                  iter[kHandlePromise](resolve, reject);
                }, reject);
              };
            }
            var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
            });
            var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
              get stream() {
                return this[kStream];
              },
              next: function next() {
                var _this = this;
                var error = this[kError];
                if (error !== null) {
                  return Promise.reject(error);
                }
                if (this[kEnded]) {
                  return Promise.resolve(createIterResult(void 0, true));
                }
                if (this[kStream].destroyed) {
                  return new Promise(function(resolve, reject) {
                    process.nextTick(function() {
                      if (_this[kError]) {
                        reject(_this[kError]);
                      } else {
                        resolve(createIterResult(void 0, true));
                      }
                    });
                  });
                }
                var lastPromise = this[kLastPromise];
                var promise;
                if (lastPromise) {
                  promise = new Promise(wrapForNext(lastPromise, this));
                } else {
                  var data = this[kStream].read();
                  if (data !== null) {
                    return Promise.resolve(createIterResult(data, false));
                  }
                  promise = new Promise(this[kHandlePromise]);
                }
                this[kLastPromise] = promise;
                return promise;
              }
            }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
              return this;
            }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
              var _this2 = this;
              return new Promise(function(resolve, reject) {
                _this2[kStream].destroy(null, function(err) {
                  if (err) {
                    reject(err);
                    return;
                  }
                  resolve(createIterResult(void 0, true));
                });
              });
            }), _Object$setPrototypeO), AsyncIteratorPrototype);
            var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
              var _Object$create;
              var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
                value: stream,
                writable: true
              }), _defineProperty(_Object$create, kLastResolve, {
                value: null,
                writable: true
              }), _defineProperty(_Object$create, kLastReject, {
                value: null,
                writable: true
              }), _defineProperty(_Object$create, kError, {
                value: null,
                writable: true
              }), _defineProperty(_Object$create, kEnded, {
                value: stream._readableState.endEmitted,
                writable: true
              }), _defineProperty(_Object$create, kHandlePromise, {
                value: function value(resolve, reject) {
                  var data = iterator[kStream].read();
                  if (data) {
                    iterator[kLastPromise] = null;
                    iterator[kLastResolve] = null;
                    iterator[kLastReject] = null;
                    resolve(createIterResult(data, false));
                  } else {
                    iterator[kLastResolve] = resolve;
                    iterator[kLastReject] = reject;
                  }
                },
                writable: true
              }), _Object$create));
              iterator[kLastPromise] = null;
              finished(stream, function(err) {
                if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                  var reject = iterator[kLastReject];
                  if (reject !== null) {
                    iterator[kLastPromise] = null;
                    iterator[kLastResolve] = null;
                    iterator[kLastReject] = null;
                    reject(err);
                  }
                  iterator[kError] = err;
                  return;
                }
                var resolve = iterator[kLastResolve];
                if (resolve !== null) {
                  iterator[kLastPromise] = null;
                  iterator[kLastResolve] = null;
                  iterator[kLastReject] = null;
                  resolve(createIterResult(void 0, true));
                }
                iterator[kEnded] = true;
              });
              stream.on("readable", onReadable.bind(null, iterator));
              return iterator;
            };
            module3.exports = createReadableStreamAsyncIterator;
          }).call(this);
        }).call(this, require2("_process"));
      }, { "./end-of-stream": 66, "_process": 54 }], 64: [function(require2, module3, exports3) {
        "use strict";
        function ownKeys(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            if (enumerableOnly)
              symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              });
            keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};
            if (i % 2) {
              ownKeys(Object(source), true).forEach(function(key) {
                _defineProperty(target, key, source[key]);
              });
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
            } else {
              ownKeys(Object(source)).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
              });
            }
          }
          return target;
        }
        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties(Constructor, staticProps);
          return Constructor;
        }
        var _require = require2("buffer"), Buffer = _require.Buffer;
        var _require2 = require2("util"), inspect = _require2.inspect;
        var custom = inspect && inspect.custom || "inspect";
        function copyBuffer(src, target, offset) {
          Buffer.prototype.copy.call(src, target, offset);
        }
        module3.exports = function() {
          function BufferList() {
            _classCallCheck(this, BufferList);
            this.head = null;
            this.tail = null;
            this.length = 0;
          }
          _createClass(BufferList, [{
            key: "push",
            value: function push(v) {
              var entry = {
                data: v,
                next: null
              };
              if (this.length > 0)
                this.tail.next = entry;
              else
                this.head = entry;
              this.tail = entry;
              ++this.length;
            }
          }, {
            key: "unshift",
            value: function unshift(v) {
              var entry = {
                data: v,
                next: this.head
              };
              if (this.length === 0)
                this.tail = entry;
              this.head = entry;
              ++this.length;
            }
          }, {
            key: "shift",
            value: function shift() {
              if (this.length === 0)
                return;
              var ret = this.head.data;
              if (this.length === 1)
                this.head = this.tail = null;
              else
                this.head = this.head.next;
              --this.length;
              return ret;
            }
          }, {
            key: "clear",
            value: function clear() {
              this.head = this.tail = null;
              this.length = 0;
            }
          }, {
            key: "join",
            value: function join(s) {
              if (this.length === 0)
                return "";
              var p = this.head;
              var ret = "" + p.data;
              while (p = p.next) {
                ret += s + p.data;
              }
              return ret;
            }
          }, {
            key: "concat",
            value: function concat(n2) {
              if (this.length === 0)
                return Buffer.alloc(0);
              var ret = Buffer.allocUnsafe(n2 >>> 0);
              var p = this.head;
              var i = 0;
              while (p) {
                copyBuffer(p.data, ret, i);
                i += p.data.length;
                p = p.next;
              }
              return ret;
            }
          }, {
            key: "consume",
            value: function consume(n2, hasStrings) {
              var ret;
              if (n2 < this.head.data.length) {
                ret = this.head.data.slice(0, n2);
                this.head.data = this.head.data.slice(n2);
              } else if (n2 === this.head.data.length) {
                ret = this.shift();
              } else {
                ret = hasStrings ? this._getString(n2) : this._getBuffer(n2);
              }
              return ret;
            }
          }, {
            key: "first",
            value: function first() {
              return this.head.data;
            }
          }, {
            key: "_getString",
            value: function _getString(n2) {
              var p = this.head;
              var c = 1;
              var ret = p.data;
              n2 -= ret.length;
              while (p = p.next) {
                var str = p.data;
                var nb = n2 > str.length ? str.length : n2;
                if (nb === str.length)
                  ret += str;
                else
                  ret += str.slice(0, n2);
                n2 -= nb;
                if (n2 === 0) {
                  if (nb === str.length) {
                    ++c;
                    if (p.next)
                      this.head = p.next;
                    else
                      this.head = this.tail = null;
                  } else {
                    this.head = p;
                    p.data = str.slice(nb);
                  }
                  break;
                }
                ++c;
              }
              this.length -= c;
              return ret;
            }
          }, {
            key: "_getBuffer",
            value: function _getBuffer(n2) {
              var ret = Buffer.allocUnsafe(n2);
              var p = this.head;
              var c = 1;
              p.data.copy(ret);
              n2 -= p.data.length;
              while (p = p.next) {
                var buf = p.data;
                var nb = n2 > buf.length ? buf.length : n2;
                buf.copy(ret, ret.length - n2, 0, nb);
                n2 -= nb;
                if (n2 === 0) {
                  if (nb === buf.length) {
                    ++c;
                    if (p.next)
                      this.head = p.next;
                    else
                      this.head = this.tail = null;
                  } else {
                    this.head = p;
                    p.data = buf.slice(nb);
                  }
                  break;
                }
                ++c;
              }
              this.length -= c;
              return ret;
            }
          }, {
            key: custom,
            value: function value(_, options) {
              return inspect(this, _objectSpread({}, options, {
                depth: 0,
                customInspect: false
              }));
            }
          }]);
          return BufferList;
        }();
      }, { "buffer": 50, "util": 49 }], 65: [function(require2, module3, exports3) {
        (function(process) {
          (function() {
            "use strict";
            function destroy(err, cb) {
              var _this = this;
              var readableDestroyed = this._readableState && this._readableState.destroyed;
              var writableDestroyed = this._writableState && this._writableState.destroyed;
              if (readableDestroyed || writableDestroyed) {
                if (cb) {
                  cb(err);
                } else if (err) {
                  if (!this._writableState) {
                    process.nextTick(emitErrorNT, this, err);
                  } else if (!this._writableState.errorEmitted) {
                    this._writableState.errorEmitted = true;
                    process.nextTick(emitErrorNT, this, err);
                  }
                }
                return this;
              }
              if (this._readableState) {
                this._readableState.destroyed = true;
              }
              if (this._writableState) {
                this._writableState.destroyed = true;
              }
              this._destroy(err || null, function(err2) {
                if (!cb && err2) {
                  if (!_this._writableState) {
                    process.nextTick(emitErrorAndCloseNT, _this, err2);
                  } else if (!_this._writableState.errorEmitted) {
                    _this._writableState.errorEmitted = true;
                    process.nextTick(emitErrorAndCloseNT, _this, err2);
                  } else {
                    process.nextTick(emitCloseNT, _this);
                  }
                } else if (cb) {
                  process.nextTick(emitCloseNT, _this);
                  cb(err2);
                } else {
                  process.nextTick(emitCloseNT, _this);
                }
              });
              return this;
            }
            function emitErrorAndCloseNT(self2, err) {
              emitErrorNT(self2, err);
              emitCloseNT(self2);
            }
            function emitCloseNT(self2) {
              if (self2._writableState && !self2._writableState.emitClose)
                return;
              if (self2._readableState && !self2._readableState.emitClose)
                return;
              self2.emit("close");
            }
            function undestroy() {
              if (this._readableState) {
                this._readableState.destroyed = false;
                this._readableState.reading = false;
                this._readableState.ended = false;
                this._readableState.endEmitted = false;
              }
              if (this._writableState) {
                this._writableState.destroyed = false;
                this._writableState.ended = false;
                this._writableState.ending = false;
                this._writableState.finalCalled = false;
                this._writableState.prefinished = false;
                this._writableState.finished = false;
                this._writableState.errorEmitted = false;
              }
            }
            function emitErrorNT(self2, err) {
              self2.emit("error", err);
            }
            function errorOrDestroy(stream, err) {
              var rState = stream._readableState;
              var wState = stream._writableState;
              if (rState && rState.autoDestroy || wState && wState.autoDestroy)
                stream.destroy(err);
              else
                stream.emit("error", err);
            }
            module3.exports = {
              destroy,
              undestroy,
              errorOrDestroy
            };
          }).call(this);
        }).call(this, require2("_process"));
      }, { "_process": 54 }], 66: [function(require2, module3, exports3) {
        "use strict";
        var ERR_STREAM_PREMATURE_CLOSE = require2("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
        function once(callback) {
          var called = false;
          return function() {
            if (called)
              return;
            called = true;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            callback.apply(this, args);
          };
        }
        function noop() {
        }
        function isRequest(stream) {
          return stream.setHeader && typeof stream.abort === "function";
        }
        function eos(stream, opts, callback) {
          if (typeof opts === "function")
            return eos(stream, null, opts);
          if (!opts)
            opts = {};
          callback = once(callback || noop);
          var readable = opts.readable || opts.readable !== false && stream.readable;
          var writable = opts.writable || opts.writable !== false && stream.writable;
          var onlegacyfinish = function onlegacyfinish2() {
            if (!stream.writable)
              onfinish();
          };
          var writableEnded = stream._writableState && stream._writableState.finished;
          var onfinish = function onfinish2() {
            writable = false;
            writableEnded = true;
            if (!readable)
              callback.call(stream);
          };
          var readableEnded = stream._readableState && stream._readableState.endEmitted;
          var onend = function onend2() {
            readable = false;
            readableEnded = true;
            if (!writable)
              callback.call(stream);
          };
          var onerror = function onerror2(err) {
            callback.call(stream, err);
          };
          var onclose = function onclose2() {
            var err;
            if (readable && !readableEnded) {
              if (!stream._readableState || !stream._readableState.ended)
                err = new ERR_STREAM_PREMATURE_CLOSE();
              return callback.call(stream, err);
            }
            if (writable && !writableEnded) {
              if (!stream._writableState || !stream._writableState.ended)
                err = new ERR_STREAM_PREMATURE_CLOSE();
              return callback.call(stream, err);
            }
          };
          var onrequest = function onrequest2() {
            stream.req.on("finish", onfinish);
          };
          if (isRequest(stream)) {
            stream.on("complete", onfinish);
            stream.on("abort", onclose);
            if (stream.req)
              onrequest();
            else
              stream.on("request", onrequest);
          } else if (writable && !stream._writableState) {
            stream.on("end", onlegacyfinish);
            stream.on("close", onlegacyfinish);
          }
          stream.on("end", onend);
          stream.on("finish", onfinish);
          if (opts.error !== false)
            stream.on("error", onerror);
          stream.on("close", onclose);
          return function() {
            stream.removeListener("complete", onfinish);
            stream.removeListener("abort", onclose);
            stream.removeListener("request", onrequest);
            if (stream.req)
              stream.req.removeListener("finish", onfinish);
            stream.removeListener("end", onlegacyfinish);
            stream.removeListener("close", onlegacyfinish);
            stream.removeListener("finish", onfinish);
            stream.removeListener("end", onend);
            stream.removeListener("error", onerror);
            stream.removeListener("close", onclose);
          };
        }
        module3.exports = eos;
      }, { "../../../errors": 57 }], 67: [function(require2, module3, exports3) {
        module3.exports = function() {
          throw new Error("Readable.from is not available in the browser");
        };
      }, {}], 68: [function(require2, module3, exports3) {
        "use strict";
        var eos;
        function once(callback) {
          var called = false;
          return function() {
            if (called)
              return;
            called = true;
            callback.apply(void 0, arguments);
          };
        }
        var _require$codes = require2("../../../errors").codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
        function noop(err) {
          if (err)
            throw err;
        }
        function isRequest(stream) {
          return stream.setHeader && typeof stream.abort === "function";
        }
        function destroyer(stream, reading, writing, callback) {
          callback = once(callback);
          var closed = false;
          stream.on("close", function() {
            closed = true;
          });
          if (eos === void 0)
            eos = require2("./end-of-stream");
          eos(stream, {
            readable: reading,
            writable: writing
          }, function(err) {
            if (err)
              return callback(err);
            closed = true;
            callback();
          });
          var destroyed = false;
          return function(err) {
            if (closed)
              return;
            if (destroyed)
              return;
            destroyed = true;
            if (isRequest(stream))
              return stream.abort();
            if (typeof stream.destroy === "function")
              return stream.destroy();
            callback(err || new ERR_STREAM_DESTROYED("pipe"));
          };
        }
        function call(fn) {
          fn();
        }
        function pipe(from, to) {
          return from.pipe(to);
        }
        function popCallback(streams) {
          if (!streams.length)
            return noop;
          if (typeof streams[streams.length - 1] !== "function")
            return noop;
          return streams.pop();
        }
        function pipeline() {
          for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
            streams[_key] = arguments[_key];
          }
          var callback = popCallback(streams);
          if (Array.isArray(streams[0]))
            streams = streams[0];
          if (streams.length < 2) {
            throw new ERR_MISSING_ARGS("streams");
          }
          var error;
          var destroys = streams.map(function(stream, i) {
            var reading = i < streams.length - 1;
            var writing = i > 0;
            return destroyer(stream, reading, writing, function(err) {
              if (!error)
                error = err;
              if (err)
                destroys.forEach(call);
              if (reading)
                return;
              destroys.forEach(call);
              callback(error);
            });
          });
          return streams.reduce(pipe);
        }
        module3.exports = pipeline;
      }, { "../../../errors": 57, "./end-of-stream": 66 }], 69: [function(require2, module3, exports3) {
        "use strict";
        var ERR_INVALID_OPT_VALUE = require2("../../../errors").codes.ERR_INVALID_OPT_VALUE;
        function highWaterMarkFrom(options, isDuplex, duplexKey) {
          return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
        }
        function getHighWaterMark(state, options, duplexKey, isDuplex) {
          var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
          if (hwm != null) {
            if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
              var name = isDuplex ? duplexKey : "highWaterMark";
              throw new ERR_INVALID_OPT_VALUE(name, hwm);
            }
            return Math.floor(hwm);
          }
          return state.objectMode ? 16 : 16 * 1024;
        }
        module3.exports = {
          getHighWaterMark
        };
      }, { "../../../errors": 57 }], 70: [function(require2, module3, exports3) {
        module3.exports = require2("events").EventEmitter;
      }, { "events": 51 }], 71: [function(require2, module3, exports3) {
        "use strict";
        var Buffer = require2("safe-buffer").Buffer;
        var isEncoding = Buffer.isEncoding || function(encoding) {
          encoding = "" + encoding;
          switch (encoding && encoding.toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
              return true;
            default:
              return false;
          }
        };
        function _normalizeEncoding(enc) {
          if (!enc)
            return "utf8";
          var retried;
          while (true) {
            switch (enc) {
              case "utf8":
              case "utf-8":
                return "utf8";
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return "utf16le";
              case "latin1":
              case "binary":
                return "latin1";
              case "base64":
              case "ascii":
              case "hex":
                return enc;
              default:
                if (retried)
                  return;
                enc = ("" + enc).toLowerCase();
                retried = true;
            }
          }
        }
        ;
        function normalizeEncoding(enc) {
          var nenc = _normalizeEncoding(enc);
          if (typeof nenc !== "string" && (Buffer.isEncoding === isEncoding || !isEncoding(enc)))
            throw new Error("Unknown encoding: " + enc);
          return nenc || enc;
        }
        exports3.StringDecoder = StringDecoder;
        function StringDecoder(encoding) {
          this.encoding = normalizeEncoding(encoding);
          var nb;
          switch (this.encoding) {
            case "utf16le":
              this.text = utf16Text;
              this.end = utf16End;
              nb = 4;
              break;
            case "utf8":
              this.fillLast = utf8FillLast;
              nb = 4;
              break;
            case "base64":
              this.text = base64Text;
              this.end = base64End;
              nb = 3;
              break;
            default:
              this.write = simpleWrite;
              this.end = simpleEnd;
              return;
          }
          this.lastNeed = 0;
          this.lastTotal = 0;
          this.lastChar = Buffer.allocUnsafe(nb);
        }
        StringDecoder.prototype.write = function(buf) {
          if (buf.length === 0)
            return "";
          var r2;
          var i;
          if (this.lastNeed) {
            r2 = this.fillLast(buf);
            if (r2 === void 0)
              return "";
            i = this.lastNeed;
            this.lastNeed = 0;
          } else {
            i = 0;
          }
          if (i < buf.length)
            return r2 ? r2 + this.text(buf, i) : this.text(buf, i);
          return r2 || "";
        };
        StringDecoder.prototype.end = utf8End;
        StringDecoder.prototype.text = utf8Text;
        StringDecoder.prototype.fillLast = function(buf) {
          if (this.lastNeed <= buf.length) {
            buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
            return this.lastChar.toString(this.encoding, 0, this.lastTotal);
          }
          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
          this.lastNeed -= buf.length;
        };
        function utf8CheckByte(byte) {
          if (byte <= 127)
            return 0;
          else if (byte >> 5 === 6)
            return 2;
          else if (byte >> 4 === 14)
            return 3;
          else if (byte >> 3 === 30)
            return 4;
          return byte >> 6 === 2 ? -1 : -2;
        }
        function utf8CheckIncomplete(self2, buf, i) {
          var j = buf.length - 1;
          if (j < i)
            return 0;
          var nb = utf8CheckByte(buf[j]);
          if (nb >= 0) {
            if (nb > 0)
              self2.lastNeed = nb - 1;
            return nb;
          }
          if (--j < i || nb === -2)
            return 0;
          nb = utf8CheckByte(buf[j]);
          if (nb >= 0) {
            if (nb > 0)
              self2.lastNeed = nb - 2;
            return nb;
          }
          if (--j < i || nb === -2)
            return 0;
          nb = utf8CheckByte(buf[j]);
          if (nb >= 0) {
            if (nb > 0) {
              if (nb === 2)
                nb = 0;
              else
                self2.lastNeed = nb - 3;
            }
            return nb;
          }
          return 0;
        }
        function utf8CheckExtraBytes(self2, buf, p) {
          if ((buf[0] & 192) !== 128) {
            self2.lastNeed = 0;
            return "\uFFFD";
          }
          if (self2.lastNeed > 1 && buf.length > 1) {
            if ((buf[1] & 192) !== 128) {
              self2.lastNeed = 1;
              return "\uFFFD";
            }
            if (self2.lastNeed > 2 && buf.length > 2) {
              if ((buf[2] & 192) !== 128) {
                self2.lastNeed = 2;
                return "\uFFFD";
              }
            }
          }
        }
        function utf8FillLast(buf) {
          var p = this.lastTotal - this.lastNeed;
          var r2 = utf8CheckExtraBytes(this, buf, p);
          if (r2 !== void 0)
            return r2;
          if (this.lastNeed <= buf.length) {
            buf.copy(this.lastChar, p, 0, this.lastNeed);
            return this.lastChar.toString(this.encoding, 0, this.lastTotal);
          }
          buf.copy(this.lastChar, p, 0, buf.length);
          this.lastNeed -= buf.length;
        }
        function utf8Text(buf, i) {
          var total = utf8CheckIncomplete(this, buf, i);
          if (!this.lastNeed)
            return buf.toString("utf8", i);
          this.lastTotal = total;
          var end = buf.length - (total - this.lastNeed);
          buf.copy(this.lastChar, 0, end);
          return buf.toString("utf8", i, end);
        }
        function utf8End(buf) {
          var r2 = buf && buf.length ? this.write(buf) : "";
          if (this.lastNeed)
            return r2 + "\uFFFD";
          return r2;
        }
        function utf16Text(buf, i) {
          if ((buf.length - i) % 2 === 0) {
            var r2 = buf.toString("utf16le", i);
            if (r2) {
              var c = r2.charCodeAt(r2.length - 1);
              if (c >= 55296 && c <= 56319) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r2.slice(0, -1);
              }
            }
            return r2;
          }
          this.lastNeed = 1;
          this.lastTotal = 2;
          this.lastChar[0] = buf[buf.length - 1];
          return buf.toString("utf16le", i, buf.length - 1);
        }
        function utf16End(buf) {
          var r2 = buf && buf.length ? this.write(buf) : "";
          if (this.lastNeed) {
            var end = this.lastTotal - this.lastNeed;
            return r2 + this.lastChar.toString("utf16le", 0, end);
          }
          return r2;
        }
        function base64Text(buf, i) {
          var n2 = (buf.length - i) % 3;
          if (n2 === 0)
            return buf.toString("base64", i);
          this.lastNeed = 3 - n2;
          this.lastTotal = 3;
          if (n2 === 1) {
            this.lastChar[0] = buf[buf.length - 1];
          } else {
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
          }
          return buf.toString("base64", i, buf.length - n2);
        }
        function base64End(buf) {
          var r2 = buf && buf.length ? this.write(buf) : "";
          if (this.lastNeed)
            return r2 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
          return r2;
        }
        function simpleWrite(buf) {
          return buf.toString(this.encoding);
        }
        function simpleEnd(buf) {
          return buf && buf.length ? this.write(buf) : "";
        }
      }, { "safe-buffer": 55 }], 72: [function(require2, module3, exports3) {
        (function(global2) {
          (function() {
            module3.exports = deprecate;
            function deprecate(fn, msg) {
              if (config("noDeprecation")) {
                return fn;
              }
              var warned = false;
              function deprecated() {
                if (!warned) {
                  if (config("throwDeprecation")) {
                    throw new Error(msg);
                  } else if (config("traceDeprecation")) {
                    console.trace(msg);
                  } else {
                    console.warn(msg);
                  }
                  warned = true;
                }
                return fn.apply(this, arguments);
              }
              return deprecated;
            }
            function config(name) {
              try {
                if (!global2.localStorage)
                  return false;
              } catch (_) {
                return false;
              }
              var val = global2.localStorage[name];
              if (null == val)
                return false;
              return String(val).toLowerCase() === "true";
            }
          }).call(this);
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}] }, {}, [9])(9);
    });
  }
});

// node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
    var global2 = typeof self !== "undefined" ? self : exports;
    var __self__ = function() {
      function F() {
        this.fetch = false;
        this.DOMException = global2.DOMException;
      }
      F.prototype = global2;
      return new F();
    }();
    (function(self2) {
      var irrelevant = function(exports2) {
        var support = {
          searchParams: "URLSearchParams" in self2,
          iterable: "Symbol" in self2 && "iterator" in Symbol,
          blob: "FileReader" in self2 && "Blob" in self2 && function() {
            try {
              new Blob();
              return true;
            } catch (e2) {
              return false;
            }
          }(),
          formData: "FormData" in self2,
          arrayBuffer: "ArrayBuffer" in self2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = "statusText" in options ? options.statusText : "OK";
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = self2.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              resolve(new Response(body, options));
            };
            xhr.onerror = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.ontimeout = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.onabort = function() {
              reject(new exports2.DOMException("Aborted", "AbortError"));
            };
            xhr.open(request.method, request.url, true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr && support.blob) {
              xhr.responseType = "blob";
            }
            request.headers.forEach(function(value, name) {
              xhr.setRequestHeader(name, value);
            });
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch.polyfill = true;
        if (!self2.fetch) {
          self2.fetch = fetch;
          self2.Headers = Headers;
          self2.Request = Request;
          self2.Response = Response;
        }
        exports2.Headers = Headers;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      }({});
    })(__self__);
    __self__.fetch.ponyfill = true;
    delete __self__.fetch.polyfill;
    var ctx = __self__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  }
});

// node_modules/botframework-directlinejs/lib/directLineStreaming.js
var require_directLineStreaming = __commonJS({
  "node_modules/botframework-directlinejs/lib/directLineStreaming.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    var _typeof = require_typeof();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DirectLineStreaming = void 0;
    var _objectWithoutProperties2 = _interopRequireDefault(require_objectWithoutProperties());
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _BehaviorSubject = require_BehaviorSubject();
    var _buffer = require_buffer();
    var _Observable = require_Observable();
    var BFSE = _interopRequireWildcard(require_index_browser());
    var _crossFetch = _interopRequireDefault(require_browser_ponyfill());
    var _directLine = require_directLine();
    var _excluded = ["attachments"];
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var DIRECT_LINE_VERSION = "DirectLine/3.0";
    var MAX_RETRY_COUNT = 3;
    var refreshTokenLifetime = 30 * 60 * 1e3;
    var timeout = 20 * 1e3;
    var refreshTokenInterval = refreshTokenLifetime / 2;
    var StreamHandler = function() {
      function StreamHandler2(s, c$, sq) {
        (0, _classCallCheck2["default"])(this, StreamHandler2);
        (0, _defineProperty2["default"])(this, "activityQueue", []);
        this.subscriber = s;
        this.connectionStatus$ = c$;
        this.shouldQueue = sq;
      }
      (0, _createClass2["default"])(StreamHandler2, [{
        key: "setSubscriber",
        value: function setSubscriber(s) {
          this.subscriber = s;
        }
      }, {
        key: "processRequest",
        value: function() {
          var _processRequest = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(request, logger) {
            var streams, stream0, activitySetJson, activitySet, activity, attachments, stream, attachment, dataUri;
            return _regenerator["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    streams = (0, _toConsumableArray2["default"])(request.streams);
                    stream0 = streams.shift();
                    _context.next = 4;
                    return stream0.readAsString();
                  case 4:
                    activitySetJson = _context.sent;
                    activitySet = JSON.parse(activitySetJson);
                    if (!(activitySet.activities.length !== 1)) {
                      _context.next = 9;
                      break;
                    }
                    this.subscriber.error(new Error("there should be exactly one activity"));
                    return _context.abrupt("return", BFSE.StreamingResponse.create(500));
                  case 9:
                    activity = activitySet.activities[0];
                    if (!(streams.length > 0)) {
                      _context.next = 21;
                      break;
                    }
                    attachments = (0, _toConsumableArray2["default"])(activity.attachments);
                  case 12:
                    if (!(stream = streams.shift())) {
                      _context.next = 20;
                      break;
                    }
                    _context.next = 15;
                    return stream.readAsString();
                  case 15:
                    attachment = _context.sent;
                    dataUri = "data:text/plain;base64," + attachment;
                    attachments.push({
                      contentType: stream.contentType,
                      contentUrl: dataUri
                    });
                    _context.next = 12;
                    break;
                  case 20:
                    activity.attachments = attachments;
                  case 21:
                    if (this.shouldQueue()) {
                      this.activityQueue.push(activity);
                    } else {
                      this.subscriber.next(activity);
                    }
                    return _context.abrupt("return", BFSE.StreamingResponse.create(200));
                  case 23:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function processRequest(_x, _x2) {
            return _processRequest.apply(this, arguments);
          }
          return processRequest;
        }()
      }, {
        key: "flush",
        value: function flush() {
          var _this = this;
          this.connectionStatus$.subscribe(function(cs) {
          });
          this.activityQueue.forEach(function(a) {
            return _this.subscriber.next(a);
          });
          this.activityQueue = [];
        }
      }]);
      return StreamHandler2;
    }();
    var DirectLineStreaming = function() {
      function DirectLineStreaming2(options) {
        var _this2 = this;
        (0, _classCallCheck2["default"])(this, DirectLineStreaming2);
        (0, _defineProperty2["default"])(this, "connectionStatus$", new _BehaviorSubject.BehaviorSubject(_directLine.ConnectionStatus.Uninitialized));
        (0, _defineProperty2["default"])(this, "_botAgent", "");
        this.token = options.token;
        this.refreshToken();
        this.domain = options.domain;
        if (options.conversationId) {
          this.conversationId = options.conversationId;
        }
        this._botAgent = this.getBotAgent(options.botAgent);
        this.queueActivities = true;
        this.activity$ = _Observable.Observable.create(function() {
          var _ref = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2(subscriber) {
            return _regenerator["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _this2.activitySubscriber = subscriber;
                    _this2.theStreamHandler = new StreamHandler(subscriber, _this2.connectionStatus$, function() {
                      return _this2.queueActivities;
                    });
                    _this2.connectWithRetryAsync();
                  case 3:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }));
          return function(_x3) {
            return _ref.apply(this, arguments);
          };
        }()).share();
      }
      (0, _createClass2["default"])(DirectLineStreaming2, [{
        key: "reconnect",
        value: function reconnect(_ref2) {
          var conversationId = _ref2.conversationId, token = _ref2.token;
          this.conversationId = conversationId;
          this.token = token;
          this.connectAsync();
        }
      }, {
        key: "end",
        value: function end() {
          this.connectionStatus$.next(_directLine.ConnectionStatus.Ended);
          this.streamConnection.disconnect();
        }
      }, {
        key: "commonHeaders",
        value: function commonHeaders() {
          return {
            "Authorization": "Bearer ".concat(this.token),
            "x-ms-bot-agent": this._botAgent
          };
        }
      }, {
        key: "getBotAgent",
        value: function getBotAgent() {
          var customAgent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          var clientAgent = "directlineStreaming";
          if (customAgent) {
            clientAgent += "; ".concat(customAgent);
          }
          return "".concat(DIRECT_LINE_VERSION, " (").concat(clientAgent, ")");
        }
      }, {
        key: "refreshToken",
        value: function() {
          var _refreshToken = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3() {
            var firstCall, retryCount, numberOfAttempts, res, _yield$res$json, token, _args3 = arguments;
            return _regenerator["default"].wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    firstCall = _args3.length > 0 && _args3[0] !== void 0 ? _args3[0] : true;
                    retryCount = _args3.length > 1 && _args3[1] !== void 0 ? _args3[1] : 0;
                    _context3.next = 4;
                    return this.waitUntilOnline();
                  case 4:
                    numberOfAttempts = 0;
                  case 5:
                    if (!(numberOfAttempts < MAX_RETRY_COUNT)) {
                      _context3.next = 30;
                      break;
                    }
                    numberOfAttempts++;
                    _context3.next = 9;
                    return new Promise(function(r2) {
                      return setTimeout(r2, refreshTokenInterval);
                    });
                  case 9:
                    _context3.prev = 9;
                    _context3.next = 12;
                    return (0, _crossFetch["default"])("".concat(this.domain, "/tokens/refresh"), {
                      method: "POST",
                      headers: this.commonHeaders()
                    });
                  case 12:
                    res = _context3.sent;
                    if (!res.ok) {
                      _context3.next = 22;
                      break;
                    }
                    numberOfAttempts = 0;
                    _context3.next = 17;
                    return res.json();
                  case 17:
                    _yield$res$json = _context3.sent;
                    token = _yield$res$json.token;
                    this.token = token;
                    _context3.next = 23;
                    break;
                  case 22:
                    if (res.status === 403 || res.status === 403) {
                      console.error("Fatal error while refreshing the token: ".concat(res.status, " ").concat(res.statusText));
                      this.streamConnection.disconnect();
                    } else {
                      console.warn("Refresh attempt #".concat(numberOfAttempts, " failed: ").concat(res.status, " ").concat(res.statusText));
                    }
                  case 23:
                    _context3.next = 28;
                    break;
                  case 25:
                    _context3.prev = 25;
                    _context3.t0 = _context3["catch"](9);
                    console.warn("Refresh attempt #".concat(numberOfAttempts, " threw an exception: ").concat(_context3.t0));
                  case 28:
                    _context3.next = 5;
                    break;
                  case 30:
                    console.error("Retries exhausted");
                    this.streamConnection.disconnect();
                  case 32:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this, [[9, 25]]);
          }));
          function refreshToken() {
            return _refreshToken.apply(this, arguments);
          }
          return refreshToken;
        }()
      }, {
        key: "postActivity",
        value: function postActivity(activity) {
          var _this3 = this;
          if (activity.type === "message" && activity.attachments && activity.attachments.length > 0) {
            return this.postMessageWithAttachments(activity);
          }
          var resp$ = _Observable.Observable.create(function() {
            var _ref3 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee4(subscriber) {
              var request, resp, numberOfStreams, idString, _JSON$parse, id;
              return _regenerator["default"].wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      request = BFSE.StreamingRequest.create("POST", "/v3/directline/conversations/" + _this3.conversationId + "/activities");
                      request.setBody(JSON.stringify(activity));
                      _context4.next = 4;
                      return _this3.streamConnection.send(request);
                    case 4:
                      resp = _context4.sent;
                      _context4.prev = 5;
                      if (!(resp.statusCode !== 200)) {
                        _context4.next = 8;
                        break;
                      }
                      throw new Error("PostActivity returned " + resp.statusCode);
                    case 8:
                      numberOfStreams = resp.streams.length;
                      if (!(numberOfStreams !== 1)) {
                        _context4.next = 11;
                        break;
                      }
                      throw new Error("Expected one stream but got " + numberOfStreams);
                    case 11:
                      _context4.next = 13;
                      return resp.streams[0].readAsString();
                    case 13:
                      idString = _context4.sent;
                      _JSON$parse = JSON.parse(idString), id = _JSON$parse.Id;
                      return _context4.abrupt("return", subscriber.next(id));
                    case 18:
                      _context4.prev = 18;
                      _context4.t0 = _context4["catch"](5);
                      console.warn(_context4.t0);
                      _this3.streamConnection.disconnect();
                      return _context4.abrupt("return", subscriber.error(_context4.t0));
                    case 23:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4, null, [[5, 18]]);
            }));
            return function(_x4) {
              return _ref3.apply(this, arguments);
            };
          }());
          return resp$;
        }
      }, {
        key: "postMessageWithAttachments",
        value: function postMessageWithAttachments(message) {
          var _this4 = this;
          var attachments = message.attachments, messageWithoutAttachments = (0, _objectWithoutProperties2["default"])(message, _excluded);
          return _Observable.Observable.create(function(subscriber) {
            var httpContentList = [];
            (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee6() {
              var arrayBuffers, url, request, activityStream, resp, _yield$resp$streams$, id;
              return _regenerator["default"].wrap(function _callee6$(_context6) {
                while (1) {
                  switch (_context6.prev = _context6.next) {
                    case 0:
                      _context6.prev = 0;
                      _context6.next = 3;
                      return Promise.all(attachments.map(function() {
                        var _ref5 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee5(attachment) {
                          var media, res;
                          return _regenerator["default"].wrap(function _callee5$(_context5) {
                            while (1) {
                              switch (_context5.prev = _context5.next) {
                                case 0:
                                  media = attachment;
                                  _context5.next = 3;
                                  return (0, _crossFetch["default"])(media.contentUrl);
                                case 3:
                                  res = _context5.sent;
                                  if (!res.ok) {
                                    _context5.next = 12;
                                    break;
                                  }
                                  _context5.next = 7;
                                  return res.arrayBuffer();
                                case 7:
                                  _context5.t0 = _context5.sent;
                                  _context5.t1 = media;
                                  return _context5.abrupt("return", {
                                    arrayBuffer: _context5.t0,
                                    media: _context5.t1
                                  });
                                case 12:
                                  throw new Error("...");
                                case 13:
                                case "end":
                                  return _context5.stop();
                              }
                            }
                          }, _callee5);
                        }));
                        return function(_x5) {
                          return _ref5.apply(this, arguments);
                        };
                      }()));
                    case 3:
                      arrayBuffers = _context6.sent;
                      arrayBuffers.forEach(function(_ref6) {
                        var arrayBuffer = _ref6.arrayBuffer, media = _ref6.media;
                        var buffer = _buffer.Buffer.from(arrayBuffer);
                        console.log(buffer);
                        var stream = new BFSE.SubscribableStream();
                        stream.write(buffer);
                        var httpContent = new BFSE.HttpContent({
                          type: media.contentType,
                          contentLength: buffer.length
                        }, stream);
                        httpContentList.push(httpContent);
                      });
                      url = "/v3/directline/conversations/".concat(_this4.conversationId, "/users/").concat(messageWithoutAttachments.from.id, "/upload");
                      request = BFSE.StreamingRequest.create("PUT", url);
                      activityStream = new BFSE.SubscribableStream();
                      activityStream.write(JSON.stringify(messageWithoutAttachments), "utf-8");
                      request.addStream(new BFSE.HttpContent({
                        type: "application/vnd.microsoft.activity",
                        contentLength: activityStream.length
                      }, activityStream));
                      httpContentList.forEach(function(e2) {
                        return request.addStream(e2);
                      });
                      _context6.next = 13;
                      return _this4.streamConnection.send(request);
                    case 13:
                      resp = _context6.sent;
                      if (!(resp.streams && resp.streams.length !== 1)) {
                        _context6.next = 18;
                        break;
                      }
                      subscriber.error(new Error("Invalid stream count ".concat(resp.streams.length)));
                      _context6.next = 23;
                      break;
                    case 18:
                      _context6.next = 20;
                      return resp.streams[0].readAsJson();
                    case 20:
                      _yield$resp$streams$ = _context6.sent;
                      id = _yield$resp$streams$.Id;
                      subscriber.next(id);
                    case 23:
                      _context6.next = 28;
                      break;
                    case 25:
                      _context6.prev = 25;
                      _context6.t0 = _context6["catch"](0);
                      subscriber.error(_context6.t0);
                    case 28:
                    case "end":
                      return _context6.stop();
                  }
                }
              }, _callee6, null, [[0, 25]]);
            }))();
          });
        }
      }, {
        key: "waitUntilOnline",
        value: function() {
          var _waitUntilOnline = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee7() {
            var _this5 = this;
            return _regenerator["default"].wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    return _context7.abrupt("return", new Promise(function(resolve, reject) {
                      _this5.connectionStatus$.subscribe(function(cs) {
                        if (cs === _directLine.ConnectionStatus.Online)
                          return resolve();
                      }, function(e2) {
                        return reject(e2);
                      });
                    }));
                  case 1:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7);
          }));
          function waitUntilOnline() {
            return _waitUntilOnline.apply(this, arguments);
          }
          return waitUntilOnline;
        }()
      }, {
        key: "connectAsync",
        value: function() {
          var _connectAsync = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee9() {
            var _this6 = this;
            var re, params, urlSearchParams, wsUrl;
            return _regenerator["default"].wrap(function _callee9$(_context9) {
              while (1) {
                switch (_context9.prev = _context9.next) {
                  case 0:
                    re = new RegExp("^http(s?)");
                    if (re.test(this.domain)) {
                      _context9.next = 3;
                      break;
                    }
                    throw "Domain must begin with http or https";
                  case 3:
                    params = {
                      token: this.token
                    };
                    if (this.conversationId)
                      params["conversationId"] = this.conversationId;
                    urlSearchParams = new URLSearchParams(params).toString();
                    wsUrl = "".concat(this.domain.replace(re, "ws$1"), "/conversations/connect?").concat(urlSearchParams);
                    return _context9.abrupt("return", new Promise(function() {
                      var _ref7 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee8(resolve, reject) {
                        var request, response, responseString, conversation;
                        return _regenerator["default"].wrap(function _callee8$(_context8) {
                          while (1) {
                            switch (_context8.prev = _context8.next) {
                              case 0:
                                _context8.prev = 0;
                                _this6.streamConnection = new BFSE.WebSocketClient({
                                  url: wsUrl,
                                  requestHandler: _this6.theStreamHandler,
                                  disconnectionHandler: function disconnectionHandler(e2) {
                                    return resolve(e2);
                                  }
                                });
                                _this6.queueActivities = true;
                                _context8.next = 5;
                                return _this6.streamConnection.connect();
                              case 5:
                                request = BFSE.StreamingRequest.create("POST", "/v3/directline/conversations");
                                _context8.next = 8;
                                return _this6.streamConnection.send(request);
                              case 8:
                                response = _context8.sent;
                                if (!(response.statusCode !== 200)) {
                                  _context8.next = 11;
                                  break;
                                }
                                throw new Error("Connection response code " + response.statusCode);
                              case 11:
                                if (!(response.streams.length !== 1)) {
                                  _context8.next = 13;
                                  break;
                                }
                                throw new Error("Expected 1 stream but got " + response.streams.length);
                              case 13:
                                _context8.next = 15;
                                return response.streams[0].readAsString();
                              case 15:
                                responseString = _context8.sent;
                                conversation = JSON.parse(responseString);
                                _this6.conversationId = conversation.conversationId;
                                _this6.connectionStatus$.next(_directLine.ConnectionStatus.Online);
                                _context8.next = 21;
                                return _this6.waitUntilOnline();
                              case 21:
                                _this6.theStreamHandler.flush();
                                _this6.queueActivities = false;
                                _context8.next = 28;
                                break;
                              case 25:
                                _context8.prev = 25;
                                _context8.t0 = _context8["catch"](0);
                                reject(_context8.t0);
                              case 28:
                              case "end":
                                return _context8.stop();
                            }
                          }
                        }, _callee8, null, [[0, 25]]);
                      }));
                      return function(_x6, _x7) {
                        return _ref7.apply(this, arguments);
                      };
                    }()));
                  case 8:
                  case "end":
                    return _context9.stop();
                }
              }
            }, _callee9, this);
          }));
          function connectAsync() {
            return _connectAsync.apply(this, arguments);
          }
          return connectAsync;
        }()
      }, {
        key: "connectWithRetryAsync",
        value: function() {
          var _connectWithRetryAsync = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee10() {
            var _this7 = this;
            var numRetries, start, res;
            return _regenerator["default"].wrap(function _callee10$(_context10) {
              while (1) {
                switch (_context10.prev = _context10.next) {
                  case 0:
                    numRetries = MAX_RETRY_COUNT;
                  case 1:
                    if (!(numRetries > 0)) {
                      _context10.next = 23;
                      break;
                    }
                    numRetries--;
                    start = Date.now();
                    _context10.prev = 4;
                    this.connectionStatus$.next(_directLine.ConnectionStatus.Connecting);
                    _context10.next = 8;
                    return this.connectAsync();
                  case 8:
                    res = _context10.sent;
                    console.warn("Retrying connection ".concat(res));
                    if (!(6e4 < Date.now() - start)) {
                      _context10.next = 13;
                      break;
                    }
                    numRetries = MAX_RETRY_COUNT;
                    return _context10.abrupt("continue", 1);
                  case 13:
                    _context10.next = 19;
                    break;
                  case 15:
                    _context10.prev = 15;
                    _context10.t0 = _context10["catch"](4);
                    console.error("Failed to connect ".concat(_context10.t0));
                    throw _context10.t0;
                  case 19:
                    _context10.next = 21;
                    return new Promise(function(r2) {
                      return setTimeout(r2, _this7.getRetryDelay());
                    });
                  case 21:
                    _context10.next = 1;
                    break;
                  case 23:
                  case "end":
                    return _context10.stop();
                }
              }
            }, _callee10, this, [[4, 15]]);
          }));
          function connectWithRetryAsync() {
            return _connectWithRetryAsync.apply(this, arguments);
          }
          return connectWithRetryAsync;
        }()
      }, {
        key: "getRetryDelay",
        value: function getRetryDelay() {
          return Math.floor(3e3 + Math.random() * 12e3);
        }
      }]);
      return DirectLineStreaming2;
    }();
    exports.DirectLineStreaming = DirectLineStreaming;
  }
});

// node_modules/botframework-directlinejs/lib/directLine.js
var require_directLine = __commonJS({
  "node_modules/botframework-directlinejs/lib/directLine.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    var _typeof = require_typeof();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "DirectLineStreaming", {
      enumerable: true,
      get: function get() {
        return _directLineStreaming.DirectLineStreaming;
      }
    });
    exports.DirectLine = exports.ConnectionStatus = void 0;
    var _objectWithoutProperties2 = _interopRequireDefault(require_objectWithoutProperties());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    require_promise2();
    require_url_search_params_polyfill();
    var _BehaviorSubject = require_BehaviorSubject();
    var _Observable = require_Observable();
    var _async = require_async();
    var _jwtDecode = _interopRequireWildcard((init_jwt_decode_esm(), __toCommonJS(jwt_decode_esm_exports)));
    require_catch2();
    require_combineLatest3();
    require_count3();
    require_delay3();
    require_do2();
    require_filter3();
    require_map3();
    require_mergeMap3();
    require_concatMap3();
    require_retryWhen3();
    require_share3();
    require_take3();
    require_ajax2();
    require_empty2();
    require_from2();
    require_interval2();
    require_of2();
    require_throw2();
    var _dedupeFilenames = _interopRequireDefault(require_dedupeFilenames());
    var _directLineStreaming = require_directLineStreaming();
    var _excluded = ["contentUrl"];
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        }
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            (0, _defineProperty2["default"])(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    var DIRECT_LINE_VERSION = "DirectLine/3.0";
    var ConnectionStatus;
    exports.ConnectionStatus = ConnectionStatus;
    (function(ConnectionStatus2) {
      ConnectionStatus2[ConnectionStatus2["Uninitialized"] = 0] = "Uninitialized";
      ConnectionStatus2[ConnectionStatus2["Connecting"] = 1] = "Connecting";
      ConnectionStatus2[ConnectionStatus2["Online"] = 2] = "Online";
      ConnectionStatus2[ConnectionStatus2["ExpiredToken"] = 3] = "ExpiredToken";
      ConnectionStatus2[ConnectionStatus2["FailedToConnect"] = 4] = "FailedToConnect";
      ConnectionStatus2[ConnectionStatus2["Ended"] = 5] = "Ended";
    })(ConnectionStatus || (exports.ConnectionStatus = ConnectionStatus = {}));
    var wrapAjaxWithRetry = function wrapAjaxWithRetry2(source, scheduler) {
      var notImplemented = function notImplemented2() {
        throw new Error("not implemented");
      };
      var inner = function inner2(response$) {
        return response$["catch"](function(err) {
          if (err.status === 429) {
            var retryAfterValue = err.xhr.getResponseHeader("Retry-After");
            var retryAfter = Number(retryAfterValue);
            if (!isNaN(retryAfter)) {
              return _Observable.Observable.timer(retryAfter, scheduler).flatMap(function(_) {
                return _Observable.Observable["throw"](err, scheduler);
              });
            }
          }
          return _Observable.Observable["throw"](err, scheduler);
        });
      };
      var outer = function outer2(urlOrRequest) {
        return inner(source(urlOrRequest));
      };
      return Object.assign(outer, {
        get: function get(url, headers) {
          return notImplemented();
        },
        post: function post(url, body, headers) {
          return notImplemented();
        },
        put: function put(url, body, headers) {
          return notImplemented();
        },
        patch: function patch(url, body, headers) {
          return notImplemented();
        },
        "delete": function _delete(url, headers) {
          return notImplemented();
        },
        getJSON: function getJSON(url, headers) {
          return notImplemented();
        }
      });
    };
    var makeServices = function makeServices2(services) {
      var scheduler = services.scheduler || _async.async;
      return {
        scheduler,
        ajax: wrapAjaxWithRetry(services.ajax || _Observable.Observable.ajax, scheduler),
        WebSocket: services.WebSocket || WebSocket,
        random: services.random || Math.random
      };
    };
    var lifetimeRefreshToken = 30 * 60 * 1e3;
    var intervalRefreshToken = lifetimeRefreshToken / 2;
    var POLLING_INTERVAL_LOWER_BOUND = 200;
    var errorExpiredToken = new Error("expired token");
    var errorConversationEnded = new Error("conversation ended");
    var errorFailedToConnect = new Error("failed to connect");
    var konsole = {
      log: function log(message) {
        var _console;
        for (var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          optionalParams[_key - 1] = arguments[_key];
        }
        if (typeof window !== "undefined" && window["botchatDebug"] && message)
          (_console = console).log.apply(_console, [message].concat(optionalParams));
      }
    };
    var DirectLine = function() {
      function DirectLine2(options) {
        (0, _classCallCheck2["default"])(this, DirectLine2);
        (0, _defineProperty2["default"])(this, "connectionStatus$", new _BehaviorSubject.BehaviorSubject(ConnectionStatus.Uninitialized));
        (0, _defineProperty2["default"])(this, "domain", "https://directline.botframework.com/v3/directline");
        (0, _defineProperty2["default"])(this, "watermark", "");
        (0, _defineProperty2["default"])(this, "_botAgent", "");
        (0, _defineProperty2["default"])(this, "timeout", 20 * 1e3);
        (0, _defineProperty2["default"])(this, "pollingInterval", 1e3);
        this.secret = options.secret;
        this.token = options.secret || options.token;
        this.webSocket = (options.webSocket === void 0 ? true : options.webSocket) && typeof WebSocket !== "undefined" && WebSocket !== void 0;
        if (options.conversationStartProperties && options.conversationStartProperties.locale) {
          if (Object.prototype.toString.call(options.conversationStartProperties.locale) === "[object String]") {
            this.localeOnStartConversation = options.conversationStartProperties.locale;
          } else {
            console.warn("DirectLineJS: conversationStartProperties.locale was ignored: the locale name may be a BCP 47 language tag");
          }
        }
        if (options.domain) {
          this.domain = options.domain;
        }
        if (options.conversationId) {
          this.conversationId = options.conversationId;
        }
        if (options.watermark) {
          this.watermark = options.watermark;
        }
        if (options.streamUrl) {
          if (options.token && options.conversationId) {
            this.streamUrl = options.streamUrl;
          } else {
            console.warn("DirectLineJS: streamUrl was ignored: you need to provide a token and a conversationid");
          }
        }
        if (options.timeout !== void 0) {
          this.timeout = options.timeout;
        }
        this.retries = (lifetimeRefreshToken - intervalRefreshToken) / this.timeout;
        this._botAgent = this.getBotAgent(options.botAgent);
        this.services = makeServices(options);
        var parsedPollingInterval = ~~options.pollingInterval;
        if (parsedPollingInterval < POLLING_INTERVAL_LOWER_BOUND) {
          if (typeof options.pollingInterval !== "undefined") {
            console.warn("DirectLineJS: provided pollingInterval (".concat(options.pollingInterval, ") is under lower bound (200ms), using default of 1000ms"));
          }
        } else {
          this.pollingInterval = parsedPollingInterval;
        }
        this.expiredTokenExhaustion = this.setConnectionStatusFallback(ConnectionStatus.ExpiredToken, ConnectionStatus.FailedToConnect, 5);
        this.activity$ = (this.webSocket ? this.webSocketActivity$() : this.pollingGetActivity$()).share();
      }
      (0, _createClass2["default"])(DirectLine2, [{
        key: "checkConnection",
        value: function checkConnection() {
          var _this = this;
          var once = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
          var obs = this.connectionStatus$.flatMap(function(connectionStatus) {
            if (connectionStatus === ConnectionStatus.Uninitialized) {
              _this.connectionStatus$.next(ConnectionStatus.Connecting);
              if (_this.token && _this.streamUrl) {
                _this.connectionStatus$.next(ConnectionStatus.Online);
                return _Observable.Observable.of(connectionStatus, _this.services.scheduler);
              } else {
                return _this.startConversation()["do"](function(conversation) {
                  _this.conversationId = conversation.conversationId;
                  _this.token = _this.secret || conversation.token;
                  _this.streamUrl = conversation.streamUrl;
                  _this.referenceGrammarId = conversation.referenceGrammarId;
                  if (!_this.secret)
                    _this.refreshTokenLoop();
                  _this.connectionStatus$.next(ConnectionStatus.Online);
                }, function(error) {
                  _this.connectionStatus$.next(ConnectionStatus.FailedToConnect);
                }).map(function(_) {
                  return connectionStatus;
                });
              }
            } else {
              return _Observable.Observable.of(connectionStatus, _this.services.scheduler);
            }
          }).filter(function(connectionStatus) {
            return connectionStatus != ConnectionStatus.Uninitialized && connectionStatus != ConnectionStatus.Connecting;
          }).flatMap(function(connectionStatus) {
            switch (connectionStatus) {
              case ConnectionStatus.Ended:
                return _Observable.Observable["throw"](errorConversationEnded, _this.services.scheduler);
              case ConnectionStatus.FailedToConnect:
                return _Observable.Observable["throw"](errorFailedToConnect, _this.services.scheduler);
              case ConnectionStatus.ExpiredToken:
                return _Observable.Observable.of(connectionStatus, _this.services.scheduler);
              default:
                return _Observable.Observable.of(connectionStatus, _this.services.scheduler);
            }
          });
          return once ? obs.take(1) : obs;
        }
      }, {
        key: "setConnectionStatusFallback",
        value: function setConnectionStatusFallback(connectionStatusFrom, connectionStatusTo) {
          var maxAttempts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5;
          maxAttempts--;
          var attempts = 0;
          var currStatus = null;
          return function(status) {
            if (status === connectionStatusFrom && currStatus === status && attempts >= maxAttempts) {
              attempts = 0;
              return connectionStatusTo;
            }
            attempts++;
            currStatus = status;
            return status;
          };
        }
      }, {
        key: "expiredToken",
        value: function expiredToken() {
          var connectionStatus = this.connectionStatus$.getValue();
          if (connectionStatus != ConnectionStatus.Ended && connectionStatus != ConnectionStatus.FailedToConnect)
            this.connectionStatus$.next(ConnectionStatus.ExpiredToken);
          var protectedConnectionStatus = this.expiredTokenExhaustion(this.connectionStatus$.getValue());
          this.connectionStatus$.next(protectedConnectionStatus);
        }
      }, {
        key: "startConversation",
        value: function startConversation() {
          var _this2 = this;
          var url = this.conversationId ? "".concat(this.domain, "/conversations/").concat(this.conversationId, "?watermark=").concat(this.watermark) : "".concat(this.domain, "/conversations");
          var method = this.conversationId ? "GET" : "POST";
          var body = this.conversationId ? void 0 : {
            user: {
              id: this.userIdOnStartConversation
            },
            locale: this.localeOnStartConversation
          };
          return this.services.ajax({
            method,
            url,
            body,
            timeout: this.timeout,
            headers: _objectSpread({
              "Accept": "application/json",
              "Content-Type": "application/json"
            }, this.commonHeaders())
          }).map(function(ajaxResponse) {
            return ajaxResponse.response;
          }).retryWhen(function(error$) {
            return error$.mergeMap(function(error) {
              return error.status >= 400 && error.status < 600 ? _Observable.Observable["throw"](error, _this2.services.scheduler) : _Observable.Observable.of(error, _this2.services.scheduler);
            }).delay(_this2.timeout, _this2.services.scheduler).take(_this2.retries);
          });
        }
      }, {
        key: "refreshTokenLoop",
        value: function refreshTokenLoop() {
          var _this3 = this;
          this.tokenRefreshSubscription = _Observable.Observable.interval(intervalRefreshToken, this.services.scheduler).flatMap(function(_) {
            return _this3.refreshToken();
          }).subscribe(function(token) {
            konsole.log("refreshing token", token, "at", new Date());
            _this3.token = token;
          });
        }
      }, {
        key: "refreshToken",
        value: function refreshToken() {
          var _this4 = this;
          return this.checkConnection(true).flatMap(function(_) {
            return _this4.services.ajax({
              method: "POST",
              url: "".concat(_this4.domain, "/tokens/refresh"),
              timeout: _this4.timeout,
              headers: _objectSpread({}, _this4.commonHeaders())
            }).map(function(ajaxResponse) {
              return ajaxResponse.response.token;
            }).retryWhen(function(error$) {
              return error$.mergeMap(function(error) {
                if (error.status === 403) {
                  _this4.expiredToken();
                  return _Observable.Observable["throw"](error, _this4.services.scheduler);
                } else if (error.status === 404) {
                  return _Observable.Observable["throw"](error, _this4.services.scheduler);
                }
                return _Observable.Observable.of(error, _this4.services.scheduler);
              }).delay(_this4.timeout, _this4.services.scheduler).take(_this4.retries);
            });
          });
        }
      }, {
        key: "reconnect",
        value: function reconnect(conversation) {
          this.token = conversation.token;
          this.streamUrl = conversation.streamUrl;
          if (this.connectionStatus$.getValue() === ConnectionStatus.ExpiredToken)
            this.connectionStatus$.next(ConnectionStatus.Online);
        }
      }, {
        key: "end",
        value: function end() {
          if (this.tokenRefreshSubscription)
            this.tokenRefreshSubscription.unsubscribe();
          try {
            this.connectionStatus$.next(ConnectionStatus.Ended);
          } catch (e2) {
            if (e2 === errorConversationEnded)
              return;
            throw e2;
          }
        }
      }, {
        key: "getSessionId",
        value: function getSessionId() {
          var _this5 = this;
          konsole.log("getSessionId");
          return this.checkConnection(true).flatMap(function(_) {
            return _this5.services.ajax({
              method: "GET",
              url: "".concat(_this5.domain, "/session/getsessionid"),
              withCredentials: true,
              timeout: _this5.timeout,
              headers: _objectSpread({
                "Content-Type": "application/json"
              }, _this5.commonHeaders())
            }).map(function(ajaxResponse) {
              if (ajaxResponse && ajaxResponse.response && ajaxResponse.response.sessionId) {
                konsole.log("getSessionId response: " + ajaxResponse.response.sessionId);
                return ajaxResponse.response.sessionId;
              }
              return "";
            })["catch"](function(error) {
              konsole.log("getSessionId error: " + error.status);
              return _Observable.Observable.of("", _this5.services.scheduler);
            });
          })["catch"](function(error) {
            return _this5.catchExpiredToken(error);
          });
        }
      }, {
        key: "postActivity",
        value: function postActivity(activity) {
          var _this6 = this;
          if (this.userIdOnStartConversation && activity.from && activity.from.id !== this.userIdOnStartConversation) {
            console.warn("DirectLineJS: Activity.from.id does not match with user id, ignoring activity.from.id");
            activity.from.id = this.userIdOnStartConversation;
          }
          if (activity.type === "message" && activity.attachments && activity.attachments.length > 0)
            return this.postMessageWithAttachments(activity);
          konsole.log("postActivity", activity);
          return this.checkConnection(true).flatMap(function(_) {
            return _this6.services.ajax({
              method: "POST",
              url: "".concat(_this6.domain, "/conversations/").concat(_this6.conversationId, "/activities"),
              body: activity,
              timeout: _this6.timeout,
              headers: _objectSpread({
                "Content-Type": "application/json"
              }, _this6.commonHeaders())
            }).map(function(ajaxResponse) {
              return ajaxResponse.response.id;
            })["catch"](function(error) {
              return _this6.catchPostError(error);
            });
          })["catch"](function(error) {
            return _this6.catchExpiredToken(error);
          });
        }
      }, {
        key: "postMessageWithAttachments",
        value: function postMessageWithAttachments(message) {
          var _this7 = this;
          var attachments = message.attachments;
          var attachmentNames = (0, _dedupeFilenames["default"])(attachments.map(function(media) {
            return media.name || "blob";
          }));
          var cleansedAttachments = attachments.map(function(attachment, index) {
            return _objectSpread(_objectSpread({}, attachment), {}, {
              name: attachmentNames[index]
            });
          });
          var formData;
          return this.checkConnection(true).flatMap(function(_) {
            formData = new FormData();
            formData.append("activity", new Blob([JSON.stringify(_objectSpread(_objectSpread({}, message), {}, {
              attachments: cleansedAttachments.map(function(_ref) {
                var string = _ref.contentUrl, others = (0, _objectWithoutProperties2["default"])(_ref, _excluded);
                return _objectSpread({}, others);
              })
            }))], {
              type: "application/vnd.microsoft.activity"
            }));
            return _Observable.Observable.from(cleansedAttachments, _this7.services.scheduler).flatMap(function(media) {
              return _this7.services.ajax({
                method: "GET",
                url: media.contentUrl,
                responseType: "arraybuffer"
              })["do"](function(ajaxResponse) {
                return formData.append("file", new Blob([ajaxResponse.response], {
                  type: media.contentType
                }), media.name);
              });
            }).count();
          }).flatMap(function(_) {
            return _this7.services.ajax({
              method: "POST",
              url: "".concat(_this7.domain, "/conversations/").concat(_this7.conversationId, "/upload?userId=").concat(message.from.id),
              body: formData,
              timeout: _this7.timeout,
              headers: _objectSpread({}, _this7.commonHeaders())
            }).map(function(ajaxResponse) {
              return ajaxResponse.response.id;
            })["catch"](function(error) {
              return _this7.catchPostError(error);
            });
          })["catch"](function(error) {
            return _this7.catchPostError(error);
          });
        }
      }, {
        key: "catchPostError",
        value: function catchPostError(error) {
          if (error.status === 403)
            this.expiredToken();
          else if (error.status >= 400 && error.status < 500)
            return _Observable.Observable["throw"](error, this.services.scheduler);
          return _Observable.Observable.of("retry", this.services.scheduler);
        }
      }, {
        key: "catchExpiredToken",
        value: function catchExpiredToken(error) {
          return error === errorExpiredToken ? _Observable.Observable.of("retry", this.services.scheduler) : _Observable.Observable["throw"](error, this.services.scheduler);
        }
      }, {
        key: "pollingGetActivity$",
        value: function pollingGetActivity$() {
          var _this8 = this;
          var poller$ = _Observable.Observable.create(function(subscriber) {
            var trigger$ = new _BehaviorSubject.BehaviorSubject({});
            trigger$.subscribe(function() {
              if (_this8.connectionStatus$.getValue() === ConnectionStatus.Online) {
                var startTimestamp = Date.now();
                _this8.services.ajax({
                  headers: _objectSpread({
                    Accept: "application/json"
                  }, _this8.commonHeaders()),
                  method: "GET",
                  url: "".concat(_this8.domain, "/conversations/").concat(_this8.conversationId, "/activities?watermark=").concat(_this8.watermark),
                  timeout: _this8.timeout
                }).subscribe(function(result) {
                  subscriber.next(result);
                  setTimeout(function() {
                    return trigger$.next(null);
                  }, Math.max(0, _this8.pollingInterval - Date.now() + startTimestamp));
                }, function(error) {
                  switch (error.status) {
                    case 403:
                      _this8.connectionStatus$.next(ConnectionStatus.ExpiredToken);
                      setTimeout(function() {
                        return trigger$.next(null);
                      }, _this8.pollingInterval);
                      break;
                    case 404:
                      _this8.connectionStatus$.next(ConnectionStatus.Ended);
                      break;
                    default:
                      subscriber.error(error);
                      break;
                  }
                });
              }
            });
          });
          return this.checkConnection().flatMap(function(_) {
            return poller$["catch"](function() {
              return _Observable.Observable.empty();
            }).map(function(ajaxResponse) {
              return ajaxResponse.response;
            }).flatMap(function(activityGroup) {
              return _this8.observableFromActivityGroup(activityGroup);
            });
          });
        }
      }, {
        key: "observableFromActivityGroup",
        value: function observableFromActivityGroup(activityGroup) {
          if (activityGroup.watermark)
            this.watermark = activityGroup.watermark;
          return _Observable.Observable.from(activityGroup.activities, this.services.scheduler);
        }
      }, {
        key: "webSocketActivity$",
        value: function webSocketActivity$() {
          var _this9 = this;
          return this.checkConnection().flatMap(function(_) {
            return _this9.observableWebSocket().retryWhen(function(error$) {
              return error$.delay(_this9.getRetryDelay(), _this9.services.scheduler).mergeMap(function(error) {
                return _this9.reconnectToConversation();
              });
            });
          }).flatMap(function(activityGroup) {
            return _this9.observableFromActivityGroup(activityGroup);
          });
        }
      }, {
        key: "getRetryDelay",
        value: function getRetryDelay() {
          return Math.floor(3e3 + this.services.random() * 12e3);
        }
      }, {
        key: "observableWebSocket",
        value: function observableWebSocket() {
          var _this10 = this;
          return _Observable.Observable.create(function(subscriber) {
            konsole.log("creating WebSocket", _this10.streamUrl);
            var ws = new _this10.services.WebSocket(_this10.streamUrl);
            var sub;
            var closed;
            ws.onopen = function(open) {
              konsole.log("WebSocket open", open);
              sub = _Observable.Observable.interval(_this10.timeout, _this10.services.scheduler).subscribe(function(_) {
                try {
                  ws.send("");
                } catch (e2) {
                  konsole.log("Ping error", e2);
                }
              });
            };
            ws.onclose = function(close) {
              konsole.log("WebSocket close", close);
              if (sub)
                sub.unsubscribe();
              closed || subscriber.error(close);
              closed = true;
            };
            ws.onerror = function(error) {
              konsole.log("WebSocket error", error);
              if (sub)
                sub.unsubscribe();
              closed || subscriber.error(error);
              closed = true;
            };
            ws.onmessage = function(message) {
              return message.data && subscriber.next(JSON.parse(message.data));
            };
            return function() {
              if (ws.readyState === 0 || ws.readyState === 1)
                ws.close();
            };
          });
        }
      }, {
        key: "reconnectToConversation",
        value: function reconnectToConversation() {
          var _this11 = this;
          return this.checkConnection(true).flatMap(function(_) {
            return _this11.services.ajax({
              method: "GET",
              url: "".concat(_this11.domain, "/conversations/").concat(_this11.conversationId, "?watermark=").concat(_this11.watermark),
              timeout: _this11.timeout,
              headers: _objectSpread({
                "Accept": "application/json"
              }, _this11.commonHeaders())
            })["do"](function(result) {
              if (!_this11.secret)
                _this11.token = result.response.token;
              _this11.streamUrl = result.response.streamUrl;
            }).map(function(_2) {
              return null;
            }).retryWhen(function(error$) {
              return error$.mergeMap(function(error) {
                if (error.status === 403) {
                  _this11.expiredToken();
                } else if (error.status === 404) {
                  return _Observable.Observable["throw"](errorConversationEnded, _this11.services.scheduler);
                }
                return _Observable.Observable.of(error, _this11.services.scheduler);
              }).delay(_this11.timeout, _this11.services.scheduler).take(_this11.retries);
            });
          });
        }
      }, {
        key: "commonHeaders",
        value: function commonHeaders() {
          return {
            "Authorization": "Bearer ".concat(this.token),
            "x-ms-bot-agent": this._botAgent
          };
        }
      }, {
        key: "getBotAgent",
        value: function getBotAgent() {
          var customAgent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          var clientAgent = "directlinejs";
          if (customAgent) {
            clientAgent += "; ".concat(customAgent);
          }
          return "".concat(DIRECT_LINE_VERSION, " (").concat(clientAgent, " ").concat("0.15.1", ")");
        }
      }, {
        key: "setUserId",
        value: function setUserId(userId) {
          if (this.connectionStatus$.getValue() === ConnectionStatus.Online) {
            throw new Error("DirectLineJS: It is connected, we cannot set user id.");
          }
          var userIdFromToken = this.parseToken(this.token);
          if (userIdFromToken) {
            return console.warn("DirectLineJS: user id is already set in token, will ignore this user id.");
          }
          if (/^dl_/.test(userId)) {
            return console.warn('DirectLineJS: user id prefixed with "dl_" is reserved and must be embedded into the Direct Line token to prevent forgery.');
          }
          this.userIdOnStartConversation = userId;
        }
      }, {
        key: "parseToken",
        value: function parseToken(token) {
          try {
            var _ref2 = (0, _jwtDecode["default"])(token), user = _ref2.user;
            return user;
          } catch (e2) {
            if (e2 instanceof _jwtDecode.InvalidTokenError) {
              return void 0;
            }
          }
        }
      }]);
      return DirectLine2;
    }();
    exports.DirectLine = DirectLine;
  }
});

// dep:botframework-directlinejs
var botframework_directlinejs_default = require_directLine();
export {
  botframework_directlinejs_default as default
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
//# sourceMappingURL=botframework-directlinejs.js.map
